[
    {
        "_id": 0,
        "Query": "This function is used to convert the input to a string type if it's not already a string. Although the `reverse` function is expected to receive a string, having this conversion could handle cases where users might pass non-string inputs.",
        "Function Name": "decode",
        "Docstring": "No docstring provided",
        "Arguments": "cls, input_string",
        "Defaults": [],
        "Code": "    def decode(cls, input_string: str) -> int:\n        if not is_full_string(input_string):\n            raise ValueError('Input must be a non empty string')\n\n        # reverse the provided string so that we can start parsing from units to thousands\n        reversed_string = reverse(input_string.upper())\n\n        # track last used value\n        last_value = None\n\n        # computed number to return\n        output = 0\n\n        # for each sign in the string we get its numeric value and add or subtract it to the computed output\n        for sign in reversed_string:\n            # are we dealing with units, tens, hundreds or thousands?\n            index = cls.__index_for_sign(sign)\n\n            # it's basically 1 or 5 (based on mapping rules definitions)\n            key_value = cls.__reversed_mappings[index][sign]\n\n            # Based on the level (tens, hundreds...) we have to add as many zeroes as the level into which we are\n            # in order to have the actual sign value.\n            # For instance, if we are at level 2 we are dealing with hundreds, therefore instead of 1 or 5, we will\n            # obtain 100 or 500 by adding 2 zeroes\n            sign_value = int(str(key_value) + '0' * index)\n\n            # increase total value if we are moving on with level\n            if last_value is None or sign_value >= last_value:\n                output += sign_value\n\n            # Decrease value if we are back to a previous level\n            # For instance, if we are parsing \"IX\", we first encounter \"X\" which is ten then \"I\" which is unit,\n            # So we have to do the following operation in order to get 9 (the final result): 10 - 1\n            else:\n                output -= sign_value\n\n            last_value = sign_value\n\n        return output",
        "Class": "__RomanNumbers",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 0,
        "Query": "This function is used to determine the length of the `input_string`. While it's not strictly necessary for reversing the string, it could be used for potential validation or error-checking (e.g., rejecting empty strings or strings that exceed a certain length).",
        "Function Name": "__require_valid_input_and_encoding",
        "Docstring": "No docstring provided",
        "Arguments": "input_string, encoding",
        "Defaults": [],
        "Code": "    def __require_valid_input_and_encoding(input_string: str, encoding: str):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        if len(input_string) == 0:\n            raise ValueError('Input string cannot be empty')\n\n        if not is_string(encoding):\n            raise ValueError('Invalid encoding')",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 0,
        "Query": "This function is used to validate that the input is indeed a string before proceeding. By checking the type, the function can avoid runtime errors and provide clearer error messages.",
        "Function Name": "__require_valid_input_and_encoding",
        "Docstring": "No docstring provided",
        "Arguments": "input_string, encoding",
        "Defaults": [],
        "Code": "    def __require_valid_input_and_encoding(input_string: str, encoding: str):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        if len(input_string) == 0:\n            raise ValueError('Input string cannot be empty')\n\n        if not is_string(encoding):\n            raise ValueError('Invalid encoding')",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 0,
        "Query": "This function could theoretically be used if the reversal was to be constructed manually by iterating over the string characters. However, using slicing is more efficient, so it's not necessary in the given implementation.",
        "Function Name": "decode",
        "Docstring": "No docstring provided",
        "Arguments": "cls, input_string",
        "Defaults": [],
        "Code": "    def decode(cls, input_string: str) -> int:\n        if not is_full_string(input_string):\n            raise ValueError('Input must be a non empty string')\n\n        # reverse the provided string so that we can start parsing from units to thousands\n        reversed_string = reverse(input_string.upper())\n\n        # track last used value\n        last_value = None\n\n        # computed number to return\n        output = 0\n\n        # for each sign in the string we get its numeric value and add or subtract it to the computed output\n        for sign in reversed_string:\n            # are we dealing with units, tens, hundreds or thousands?\n            index = cls.__index_for_sign(sign)\n\n            # it's basically 1 or 5 (based on mapping rules definitions)\n            key_value = cls.__reversed_mappings[index][sign]\n\n            # Based on the level (tens, hundreds...) we have to add as many zeroes as the level into which we are\n            # in order to have the actual sign value.\n            # For instance, if we are at level 2 we are dealing with hundreds, therefore instead of 1 or 5, we will\n            # obtain 100 or 500 by adding 2 zeroes\n            sign_value = int(str(key_value) + '0' * index)\n\n            # increase total value if we are moving on with level\n            if last_value is None or sign_value >= last_value:\n                output += sign_value\n\n            # Decrease value if we are back to a previous level\n            # For instance, if we are parsing \"IX\", we first encounter \"X\" which is ten then \"I\" which is unit,\n            # So we have to do the following operation in order to get 9 (the final result): 10 - 1\n            else:\n                output -= sign_value\n\n            last_value = sign_value\n\n        return output",
        "Class": "__RomanNumbers",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 0,
        "Query": "This function may not be a direct part of the core functionality but could be utilized for debugging or logging purposes within the development environment to display the input or output values.",
        "Function Name": "__placeholder_key",
        "Docstring": "No docstring provided",
        "Arguments": "",
        "Defaults": [],
        "Code": "    def __placeholder_key():\n        return '$' + uuid4().hex + '$'",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 0,
        "Query": "This function could be called if the input is invalid (not a string) and you want to terminate the program immediately. However, this is usually not ideal; raising an exception would be preferred.",
        "Function Name": "contains_html",
        "Docstring": "Checks if the given string contains HTML/XML tags.\n\nBy design, this function matches ANY type of tag, so don't expect to use it\nas an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n*Examples:*\n\n>>> contains_html('my string is <strong>bold</strong>') # returns true\n>>> contains_html('my string is not bold') # returns false\n\n:param input_string: Text to check\n:type input_string: str\n:return: True if string contains html, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def contains_html(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string contains HTML/XML tags.\n\n    By design, this function matches ANY type of tag, so don't expect to use it\n    as an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n    *Examples:*\n\n    >>> contains_html('my string is <strong>bold</strong>') # returns true\n    >>> contains_html('my string is not bold') # returns false\n\n    :param input_string: Text to check\n    :type input_string: str\n    :return: True if string contains html, false otherwise.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return HTML_RE.search(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 0,
        "Query": "This is the regex module that might not be directly needed in this specific case, but if future expansions of the function allowed reversing of strings while ignoring certain characters (like spaces or punctuation), it could be called.",
        "Function Name": "decode",
        "Docstring": "No docstring provided",
        "Arguments": "cls, input_string",
        "Defaults": [],
        "Code": "    def decode(cls, input_string: str) -> int:\n        if not is_full_string(input_string):\n            raise ValueError('Input must be a non empty string')\n\n        # reverse the provided string so that we can start parsing from units to thousands\n        reversed_string = reverse(input_string.upper())\n\n        # track last used value\n        last_value = None\n\n        # computed number to return\n        output = 0\n\n        # for each sign in the string we get its numeric value and add or subtract it to the computed output\n        for sign in reversed_string:\n            # are we dealing with units, tens, hundreds or thousands?\n            index = cls.__index_for_sign(sign)\n\n            # it's basically 1 or 5 (based on mapping rules definitions)\n            key_value = cls.__reversed_mappings[index][sign]\n\n            # Based on the level (tens, hundreds...) we have to add as many zeroes as the level into which we are\n            # in order to have the actual sign value.\n            # For instance, if we are at level 2 we are dealing with hundreds, therefore instead of 1 or 5, we will\n            # obtain 100 or 500 by adding 2 zeroes\n            sign_value = int(str(key_value) + '0' * index)\n\n            # increase total value if we are moving on with level\n            if last_value is None or sign_value >= last_value:\n                output += sign_value\n\n            # Decrease value if we are back to a previous level\n            # For instance, if we are parsing \"IX\", we first encounter \"X\" which is ten then \"I\" which is unit,\n            # So we have to do the following operation in order to get 9 (the final result): 10 - 1\n            else:\n                output -= sign_value\n\n            last_value = sign_value\n\n        return output",
        "Class": "__RomanNumbers",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 0,
        "Query": "This function could be used to remove any leading or trailing whitespace characters from the `input_string` before reversing it, ensuring that the output is clean.",
        "Function Name": "__remove_internal_spaces",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __remove_internal_spaces(self, regex_match):\n        return regex_match.group(1).strip()",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 0,
        "Query": "These functions could be called if the reversed string was intended to be transformed to a consistent case, but this is not part of the specified functionality.",
        "Function Name": "decode",
        "Docstring": "No docstring provided",
        "Arguments": "cls, input_string",
        "Defaults": [],
        "Code": "    def decode(cls, input_string: str) -> int:\n        if not is_full_string(input_string):\n            raise ValueError('Input must be a non empty string')\n\n        # reverse the provided string so that we can start parsing from units to thousands\n        reversed_string = reverse(input_string.upper())\n\n        # track last used value\n        last_value = None\n\n        # computed number to return\n        output = 0\n\n        # for each sign in the string we get its numeric value and add or subtract it to the computed output\n        for sign in reversed_string:\n            # are we dealing with units, tens, hundreds or thousands?\n            index = cls.__index_for_sign(sign)\n\n            # it's basically 1 or 5 (based on mapping rules definitions)\n            key_value = cls.__reversed_mappings[index][sign]\n\n            # Based on the level (tens, hundreds...) we have to add as many zeroes as the level into which we are\n            # in order to have the actual sign value.\n            # For instance, if we are at level 2 we are dealing with hundreds, therefore instead of 1 or 5, we will\n            # obtain 100 or 500 by adding 2 zeroes\n            sign_value = int(str(key_value) + '0' * index)\n\n            # increase total value if we are moving on with level\n            if last_value is None or sign_value >= last_value:\n                output += sign_value\n\n            # Decrease value if we are back to a previous level\n            # For instance, if we are parsing \"IX\", we first encounter \"X\" which is ten then \"I\" which is unit,\n            # So we have to do the following operation in order to get 9 (the final result): 10 - 1\n            else:\n                output -= sign_value\n\n            last_value = sign_value\n\n        return output",
        "Class": "__RomanNumbers",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 1,
        "Query": "This function is used to validate whether the input string follows camel case conventions, checking for invalid characters and ensuring that the string contains both uppercase and lowercase letters.",
        "Function Name": "is_camel_case",
        "Docstring": "Checks if a string is formatted as camel case.\n\nA string is considered camel case when:\n\n- it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n- it contains both lowercase and uppercase letters\n- it does not start with a number\n\n*Examples:*\n\n>>> is_camel_case('MyString') # returns true\n>>> is_camel_case('mystring') # returns false\n\n:param input_string: String to test.\n:type input_string: str\n:return: True for a camel case string, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_camel_case(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and CAMEL_CASE_TEST_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 1,
        "Query": "This function is used to convert a character or a string to its lowercase equivalent, which may be invoked whenever an uppercase character is encountered in the input string.",
        "Function Name": "snake_case_to_camel",
        "Docstring": "Convert a snake case string into a camel case one.\n(The original string is returned if is not a valid snake case string)\n\n*Example:*\n\n>>> snake_case_to_camel('the_snake_is_green') # returns 'TheSnakeIsGreen'\n\n:param input_string: String to convert.\n:type input_string: str\n:param upper_case_first: True to turn the first letter into uppercase (default).\n:type upper_case_first: bool\n:param separator: Sign to use as separator (default to \"_\").\n:type separator: str\n:return: Converted string",
        "Arguments": "input_string, upper_case_first, separator",
        "Defaults": [
            "True",
            "'_'"
        ],
        "Code": "def snake_case_to_camel(input_string: str, upper_case_first: bool = True, separator: str = '_') -> str:\n    \"\"\"\n    Convert a snake case string into a camel case one.\n    (The original string is returned if is not a valid snake case string)\n\n    *Example:*\n\n    >>> snake_case_to_camel('the_snake_is_green') # returns 'TheSnakeIsGreen'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param upper_case_first: True to turn the first letter into uppercase (default).\n    :type upper_case_first: bool\n    :param separator: Sign to use as separator (default to \"_\").\n    :type separator: str\n    :return: Converted string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_snake_case(input_string, separator):\n        return input_string\n\n    tokens = [s.title() for s in input_string.split(separator) if is_full_string(s)]\n\n    if not upper_case_first:\n        tokens[0] = tokens[0].lower()\n\n    out = ''.join(tokens)\n\n    return out",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 1,
        "Query": "This function is used to handle the insertion of the specified separator before adding a new part when converting from camel case to snake case. It may handle edge cases, such as preventing multiple consecutive separators.",
        "Function Name": "snake_case_to_camel",
        "Docstring": "Convert a snake case string into a camel case one.\n(The original string is returned if is not a valid snake case string)\n\n*Example:*\n\n>>> snake_case_to_camel('the_snake_is_green') # returns 'TheSnakeIsGreen'\n\n:param input_string: String to convert.\n:type input_string: str\n:param upper_case_first: True to turn the first letter into uppercase (default).\n:type upper_case_first: bool\n:param separator: Sign to use as separator (default to \"_\").\n:type separator: str\n:return: Converted string",
        "Arguments": "input_string, upper_case_first, separator",
        "Defaults": [
            "True",
            "'_'"
        ],
        "Code": "def snake_case_to_camel(input_string: str, upper_case_first: bool = True, separator: str = '_') -> str:\n    \"\"\"\n    Convert a snake case string into a camel case one.\n    (The original string is returned if is not a valid snake case string)\n\n    *Example:*\n\n    >>> snake_case_to_camel('the_snake_is_green') # returns 'TheSnakeIsGreen'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param upper_case_first: True to turn the first letter into uppercase (default).\n    :type upper_case_first: bool\n    :param separator: Sign to use as separator (default to \"_\").\n    :type separator: str\n    :return: Converted string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_snake_case(input_string, separator):\n        return input_string\n\n    tokens = [s.title() for s in input_string.split(separator) if is_full_string(s)]\n\n    if not upper_case_first:\n        tokens[0] = tokens[0].lower()\n\n    out = ''.join(tokens)\n\n    return out",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 1,
        "Query": "This function is used to remove any leading or trailing whitespace from the input string before conversion, ensuring that the conversion process works with clean input.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 1,
        "Query": "This function is used to check that the input string is of the correct type (string) and possibly not empty, throwing an error or returning the original string if the input is not valid.",
        "Function Name": "__require_valid_input_and_encoding",
        "Docstring": "No docstring provided",
        "Arguments": "input_string, encoding",
        "Defaults": [],
        "Code": "    def __require_valid_input_and_encoding(input_string: str, encoding: str):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        if len(input_string) == 0:\n            raise ValueError('Input string cannot be empty')\n\n        if not is_string(encoding):\n            raise ValueError('Invalid encoding')",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 1,
        "Query": "This function is used to assist in breaking down a camel case string by identifying transitions between lowercase and uppercase letters, potentially creating a preliminary list of string parts before the final conversion.",
        "Function Name": "is_camel_case",
        "Docstring": "Checks if a string is formatted as camel case.\n\nA string is considered camel case when:\n\n- it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n- it contains both lowercase and uppercase letters\n- it does not start with a number\n\n*Examples:*\n\n>>> is_camel_case('MyString') # returns true\n>>> is_camel_case('mystring') # returns false\n\n:param input_string: String to test.\n:type input_string: str\n:return: True for a camel case string, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_camel_case(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and CAMEL_CASE_TEST_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 1,
        "Query": "This function is used to combine all parts of the string list with the specified separator after the conversion process, streamlining the final output creation.",
        "Function Name": "shuffle",
        "Docstring": "Return a new string containing same chars of the given one but in a randomized order.\n\n*Example:*\n\n>>> shuffle('hello world') # possible output: 'l wodheorll'\n\n:param input_string: String to shuffle\n:type input_string: str\n:return: Shuffled string",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def shuffle(input_string: str) -> str:\n    \"\"\"\n    Return a new string containing same chars of the given one but in a randomized order.\n\n    *Example:*\n\n    >>> shuffle('hello world') # possible output: 'l wodheorll'\n\n    :param input_string: String to shuffle\n    :type input_string: str\n    :return: Shuffled string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    # turn the string into a list of chars\n    chars = list(input_string)\n\n    # shuffle the list\n    random.shuffle(chars)\n\n    # convert the shuffled list back to string\n    return ''.join(chars)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 2,
        "Query": "This function is used to check if the `input_string` adheres to valid snake_case formatting, ensuring that it only contains lowercase letters, digits, and the specified `separator`.",
        "Function Name": "is_snake_case",
        "Docstring": "Checks if a string is formatted as \"snake case\".\n\nA string is considered snake case when:\n\n- it's composed only by lowercase/uppercase letters and digits\n- it contains at least one underscore (or provided separator)\n- it does not start with a number\n\n*Examples:*\n\n>>> is_snake_case('foo_bar_baz') # returns true\n>>> is_snake_case('foo') # returns false\n\n:param input_string: String to test.\n:type input_string: str\n:param separator: String to use as separator.\n:type separator: str\n:return: True for a snake case string, false otherwise.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'_'"
        ],
        "Code": "def is_snake_case(input_string: Any, separator: str = '_') -> bool:\n    \"\"\"\n    Checks if a string is formatted as \"snake case\".\n\n    A string is considered snake case when:\n\n    - it's composed only by lowercase/uppercase letters and digits\n    - it contains at least one underscore (or provided separator)\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_snake_case('foo_bar_baz') # returns true\n    >>> is_snake_case('foo') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :param separator: String to use as separator.\n    :type separator: str\n    :return: True for a snake case string, false otherwise.\n    \"\"\"\n    if is_full_string(input_string):\n        re_map = {\n            '_': SNAKE_CASE_TEST_RE,\n            '-': SNAKE_CASE_TEST_DASH_RE\n        }\n        re_template = r'([a-z]+\\d*{sign}[a-z\\d{sign}]*|{sign}+[a-z\\d]+[a-z\\d{sign}]*)'\n        r = re_map.get(\n            separator,\n            re.compile(re_template.format(sign=re.escape(separator)), re.IGNORECASE)\n        )\n\n        return r.match(input_string) is not None\n\n    return False",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 2,
        "Query": "This function is used to convert all letters in the `input_string` to lowercase to ensure uniform formatting before performing additional processing.",
        "Function Name": "__uppercase_first_letter_after_sign",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __uppercase_first_letter_after_sign(self, regex_match):\n        match = regex_match.group(1)\n        return match[:-1] + match[2].upper()",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 2,
        "Query": "This function is used to capitalize the first letter of a given word while ensuring the rest of the letters are in lowercase. This allows for more modular processing of each individual word.",
        "Function Name": "__uppercase_first_letter_after_sign",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __uppercase_first_letter_after_sign(self, regex_match):\n        match = regex_match.group(1)\n        return match[:-1] + match[2].upper()",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 2,
        "Query": "This function is used to remove any leading or trailing separators from the `input_string`, which helps in preventing any invalid results when splitting the string into words.",
        "Function Name": "__remove_internal_spaces",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __remove_internal_spaces(self, regex_match):\n        return regex_match.group(1).strip()",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 2,
        "Query": "This function can be used to validate the formatting of the `input_string`, checking if there are any invalid characters present that would disqualify the string from being considered valid snake_case.",
        "Function Name": "is_snake_case",
        "Docstring": "Checks if a string is formatted as \"snake case\".\n\nA string is considered snake case when:\n\n- it's composed only by lowercase/uppercase letters and digits\n- it contains at least one underscore (or provided separator)\n- it does not start with a number\n\n*Examples:*\n\n>>> is_snake_case('foo_bar_baz') # returns true\n>>> is_snake_case('foo') # returns false\n\n:param input_string: String to test.\n:type input_string: str\n:param separator: String to use as separator.\n:type separator: str\n:return: True for a snake case string, false otherwise.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'_'"
        ],
        "Code": "def is_snake_case(input_string: Any, separator: str = '_') -> bool:\n    \"\"\"\n    Checks if a string is formatted as \"snake case\".\n\n    A string is considered snake case when:\n\n    - it's composed only by lowercase/uppercase letters and digits\n    - it contains at least one underscore (or provided separator)\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_snake_case('foo_bar_baz') # returns true\n    >>> is_snake_case('foo') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :param separator: String to use as separator.\n    :type separator: str\n    :return: True for a snake case string, false otherwise.\n    \"\"\"\n    if is_full_string(input_string):\n        re_map = {\n            '_': SNAKE_CASE_TEST_RE,\n            '-': SNAKE_CASE_TEST_DASH_RE\n        }\n        re_template = r'([a-z]+\\d*{sign}[a-z\\d{sign}]*|{sign}+[a-z\\d]+[a-z\\d{sign}]*)'\n        r = re_map.get(\n            separator,\n            re.compile(re_template.format(sign=re.escape(separator)), re.IGNORECASE)\n        )\n\n        return r.match(input_string) is not None\n\n    return False",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 2,
        "Query": "This function is used to join the processed list of words back into a single string, enabling a more abstracted way of creating the camelCase output.",
        "Function Name": "camel_case_to_snake",
        "Docstring": "Convert a camel case string into a snake case one.\n(The original string is returned if is not a valid camel case string)\n\n*Example:*\n\n>>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign to use as separator.\n:type separator: str\n:return: Converted string.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'_'"
        ],
        "Code": "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_camel_case(input_string):\n        return input_string\n\n    return CAMEL_CASE_REPLACE_RE.sub(lambda m: m.group(1) + separator, input_string).lower()",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 2,
        "Query": "This function is used to remove any whitespace from both ends of the `input_string`, ensuring that whitespace does not interfere with the processing of the string.\n\nEach of these functions contributes to the clarity and maintainability of the `snake_case_to_camel` function, allowing it to focus on the overall conversion logic while relying on helper functions to manage specific tasks.",
        "Function Name": "camel_case_to_snake",
        "Docstring": "Convert a camel case string into a snake case one.\n(The original string is returned if is not a valid camel case string)\n\n*Example:*\n\n>>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign to use as separator.\n:type separator: str\n:return: Converted string.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'_'"
        ],
        "Code": "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_camel_case(input_string):\n        return input_string\n\n    return CAMEL_CASE_REPLACE_RE.sub(lambda m: m.group(1) + separator, input_string).lower()",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 3,
        "Query": "This function is used to find all occurrences of a pattern in the input string, which may help in extracting content between HTML tags if `keep_tag_content` is `True`.",
        "Function Name": "contains_html",
        "Docstring": "Checks if the given string contains HTML/XML tags.\n\nBy design, this function matches ANY type of tag, so don't expect to use it\nas an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n*Examples:*\n\n>>> contains_html('my string is <strong>bold</strong>') # returns true\n>>> contains_html('my string is not bold') # returns false\n\n:param input_string: Text to check\n:type input_string: str\n:return: True if string contains html, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def contains_html(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string contains HTML/XML tags.\n\n    By design, this function matches ANY type of tag, so don't expect to use it\n    as an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n    *Examples:*\n\n    >>> contains_html('my string is <strong>bold</strong>') # returns true\n    >>> contains_html('my string is not bold') # returns false\n\n    :param input_string: Text to check\n    :type input_string: str\n    :return: True if string contains html, false otherwise.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return HTML_RE.search(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 3,
        "Query": "This function is used to replace specific substrings in the string, which may be helpful for removing unwanted characters or whitespace that could result from stripping HTML tags.",
        "Function Name": "contains_html",
        "Docstring": "Checks if the given string contains HTML/XML tags.\n\nBy design, this function matches ANY type of tag, so don't expect to use it\nas an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n*Examples:*\n\n>>> contains_html('my string is <strong>bold</strong>') # returns true\n>>> contains_html('my string is not bold') # returns false\n\n:param input_string: Text to check\n:type input_string: str\n:return: True if string contains html, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def contains_html(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string contains HTML/XML tags.\n\n    By design, this function matches ANY type of tag, so don't expect to use it\n    as an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n    *Examples:*\n\n    >>> contains_html('my string is <strong>bold</strong>') # returns true\n    >>> contains_html('my string is not bold') # returns false\n\n    :param input_string: Text to check\n    :type input_string: str\n    :return: True if string contains html, false otherwise.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return HTML_RE.search(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 3,
        "Query": "This function is used to convert the string to lowercase, which might be useful if the HTML tags need to be matched in a case-insensitive manner during the stripping process.",
        "Function Name": "camel_case_to_snake",
        "Docstring": "Convert a camel case string into a snake case one.\n(The original string is returned if is not a valid camel case string)\n\n*Example:*\n\n>>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign to use as separator.\n:type separator: str\n:return: Converted string.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'_'"
        ],
        "Code": "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_camel_case(input_string):\n        return input_string\n\n    return CAMEL_CASE_REPLACE_RE.sub(lambda m: m.group(1) + separator, input_string).lower()",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 3,
        "Query": "This function is used to convert the string to uppercase, which could be beneficial if there's a need to standardize tag names for easier comparison or processing.",
        "Function Name": "snake_case_to_camel",
        "Docstring": "Convert a snake case string into a camel case one.\n(The original string is returned if is not a valid snake case string)\n\n*Example:*\n\n>>> snake_case_to_camel('the_snake_is_green') # returns 'TheSnakeIsGreen'\n\n:param input_string: String to convert.\n:type input_string: str\n:param upper_case_first: True to turn the first letter into uppercase (default).\n:type upper_case_first: bool\n:param separator: Sign to use as separator (default to \"_\").\n:type separator: str\n:return: Converted string",
        "Arguments": "input_string, upper_case_first, separator",
        "Defaults": [
            "True",
            "'_'"
        ],
        "Code": "def snake_case_to_camel(input_string: str, upper_case_first: bool = True, separator: str = '_') -> str:\n    \"\"\"\n    Convert a snake case string into a camel case one.\n    (The original string is returned if is not a valid snake case string)\n\n    *Example:*\n\n    >>> snake_case_to_camel('the_snake_is_green') # returns 'TheSnakeIsGreen'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param upper_case_first: True to turn the first letter into uppercase (default).\n    :type upper_case_first: bool\n    :param separator: Sign to use as separator (default to \"_\").\n    :type separator: str\n    :return: Converted string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_snake_case(input_string, separator):\n        return input_string\n\n    tokens = [s.title() for s in input_string.split(separator) if is_full_string(s)]\n\n    if not upper_case_first:\n        tokens[0] = tokens[0].lower()\n\n    out = ''.join(tokens)\n\n    return out",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 3,
        "Query": "This function is used to convert HTML entities (like `&amp;`, `&lt;`, etc.) back to their corresponding characters, which may be necessary if the `keep_tag_content` option is used, to ensure that the final output is human-readable.",
        "Function Name": "slugify",
        "Docstring": "Converts a string into a \"slug\" using provided separator.\nThe returned string has the following properties:\n\n- it has no spaces\n- all letters are in lower case\n- all punctuation signs and non alphanumeric chars are removed\n- words are divided using provided separator\n- all chars are encoded as ascii (by using `asciify()`)\n- is safe for URL\n\n*Examples:*\n\n>>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n>>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign used to join string tokens (default to \"-\").\n:type separator: str\n:return: Slug string",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'-'"
        ],
        "Code": "def slugify(input_string: str, separator: str = '-') -> str:\n    \"\"\"\n    Converts a string into a \"slug\" using provided separator.\n    The returned string has the following properties:\n\n    - it has no spaces\n    - all letters are in lower case\n    - all punctuation signs and non alphanumeric chars are removed\n    - words are divided using provided separator\n    - all chars are encoded as ascii (by using `asciify()`)\n    - is safe for URL\n\n    *Examples:*\n\n    >>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n    >>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign used to join string tokens (default to \"-\").\n    :type separator: str\n    :return: Slug string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    # replace any character that is NOT letter or number with spaces\n    out = NO_LETTERS_OR_NUMBERS_RE.sub(' ', input_string.lower()).strip()\n\n    # replace spaces with join sign\n    out = SPACES_RE.sub(separator, out)\n\n    # normalize joins (remove duplicates)\n    out = re.sub(re.escape(separator) + r'+', separator, out)\n\n    return asciify(out)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 3,
        "Query": "This function is used to split the input string into lines, which might help to isolate individual pieces of HTML content if processing multi-line strings.",
        "Function Name": "strip_margin",
        "Docstring": "Removes tab indentation from multi line strings (inspired by analogous Scala function).\n\n*Example:*\n\n>>> strip_margin('''\n>>>                 line 1\n>>>                 line 2\n>>>                 line 3\n>>> ''')\n>>> # returns:\n>>> '''\n>>> line 1\n>>> line 2\n>>> line 3\n>>> '''\n\n:param input_string: String to format\n:type input_string: str\n:return: A string without left margins",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def strip_margin(input_string: str) -> str:\n    \"\"\"\n    Removes tab indentation from multi line strings (inspired by analogous Scala function).\n\n    *Example:*\n\n    >>> strip_margin('''\n    >>>                 line 1\n    >>>                 line 2\n    >>>                 line 3\n    >>> ''')\n    >>> # returns:\n    >>> '''\n    >>> line 1\n    >>> line 2\n    >>> line 3\n    >>> '''\n\n    :param input_string: String to format\n    :type input_string: str\n    :return: A string without left margins\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    line_separator = '\\n'\n    lines = [MARGIN_RE.sub('', line) for line in input_string.split(line_separator)]\n    out = line_separator.join(lines)\n\n    return out",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 3,
        "Query": "This method could be used to build a list of content extracted from HTML tags, especially when `keep_tag_content` is `True`, before joining it back into a string.",
        "Function Name": "__remove_internal_spaces",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __remove_internal_spaces(self, regex_match):\n        return regex_match.group(1).strip()",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 3,
        "Query": "This function may be used to locate the positions of specific tags within the string, aiding in determining how to slice the string appropriately.",
        "Function Name": "contains_html",
        "Docstring": "Checks if the given string contains HTML/XML tags.\n\nBy design, this function matches ANY type of tag, so don't expect to use it\nas an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n*Examples:*\n\n>>> contains_html('my string is <strong>bold</strong>') # returns true\n>>> contains_html('my string is not bold') # returns false\n\n:param input_string: Text to check\n:type input_string: str\n:return: True if string contains html, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def contains_html(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string contains HTML/XML tags.\n\n    By design, this function matches ANY type of tag, so don't expect to use it\n    as an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n    *Examples:*\n\n    >>> contains_html('my string is <strong>bold</strong>') # returns true\n    >>> contains_html('my string is not bold') # returns false\n\n    :param input_string: Text to check\n    :type input_string: str\n    :return: True if string contains html, false otherwise.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return HTML_RE.search(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 3,
        "Query": "Similar to `str.strip`, this function can be used specifically to remove trailing whitespace after the final processing of the string, ensuring a clean output without excess spaces.\n\nThese functions can enhance the `strip_html` function by streamlining operations related to string manipulation and HTML content processing.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 4,
        "Query": "This function is used to remove leading and trailing spaces from the input string, ensuring it does not start or end with spaces.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 4,
        "Query": "This function is used to convert the first character of the string to uppercase, as well as the first character after each defined punctuation mark (dot `.`, exclamation `!`, or question `?`).",
        "Function Name": "__uppercase_first_letter_after_sign",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __uppercase_first_letter_after_sign(self, regex_match):\n        match = regex_match.group(1)\n        return match[:-1] + match[2].upper()",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 4,
        "Query": "This function is used to divide the string into individual words based on spaces, which helps in handling multiple sequential spaces.",
        "Function Name": "__ensure_spaces_around",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_spaces_around(self, regex_match):\n        return ' ' + regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 4,
        "Query": "This function is used to concatenate the words back into a single string with a single space separating them, ensuring there are no multiple spaces in the output.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 4,
        "Query": "This function is used to modify specific phrases or characters throughout the string, such as changing formatting around arithmetic operators and punctuation.",
        "Function Name": "format",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def format(self) -> str:\n        # map of temporary placeholders\n        placeholders = {}\n        out = self.input_string\n\n        # looks for url or email and updates placeholders map with found values\n        placeholders.update({self.__placeholder_key(): m[0] for m in URLS_RE.findall(out)})\n        placeholders.update({self.__placeholder_key(): m for m in EMAILS_RE.findall(out)})\n\n        # replace original value with the placeholder key\n        for p in placeholders:\n            out = out.replace(placeholders[p], p, 1)\n\n        out = PRETTIFY_RE['UPPERCASE_FIRST_LETTER'].sub(self.__uppercase_first_char, out)\n        out = PRETTIFY_RE['DUPLICATES'].sub(self.__remove_duplicates, out)\n        out = PRETTIFY_RE['RIGHT_SPACE'].sub(self.__ensure_right_space_only, out)\n        out = PRETTIFY_RE['LEFT_SPACE'].sub(self.__ensure_left_space_only, out)\n        out = PRETTIFY_RE['SPACES_AROUND'].sub(self.__ensure_spaces_around, out)\n        out = PRETTIFY_RE['SPACES_INSIDE'].sub(self.__remove_internal_spaces, out)\n        out = PRETTIFY_RE['UPPERCASE_AFTER_SIGN'].sub(self.__uppercase_first_letter_after_sign, out)\n        out = PRETTIFY_RE['SAXON_GENITIVE'].sub(self.__fix_saxon_genitive, out)\n        out = out.strip()\n\n        # restore placeholder keys with their associated original value\n        for p in placeholders:\n            out = out.replace(p, placeholders[p], 1)\n\n        return out",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 4,
        "Query": "This function is used for applying regular expressions to search for patterns in the string, particularly useful for handling spacing around double quotes, round brackets, and percentage signs.",
        "Function Name": "__ensure_spaces_around",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_spaces_around(self, regex_match):\n        return ' ' + regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 4,
        "Query": "This function may be used to identify the positions of characters or sequences in the string to facilitate correct formatting, like ensuring spaces around punctuation and arithmetic operators.",
        "Function Name": "__ensure_spaces_around",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_spaces_around(self, regex_match):\n        return ' ' + regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 4,
        "Query": "This function may be used to find specific patterns in the string, such as validating presence and correct format of mathematical operators or special cases like Saxon genitives.",
        "Function Name": "__fix_saxon_genitive",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __fix_saxon_genitive(self, regex_match):\n        return regex_match.group(1).replace(' ', '') + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 4,
        "Query": "This function could be utilized to split the input string based on more complex punctuation rules directly, accommodating for multiple punctuation marks.",
        "Function Name": "words_count",
        "Docstring": "Returns the number of words contained into the given string.\n\nThis method is smart, it does consider only sequence of one or more letter and/or numbers\nas \"words\", so a string like this: \"! @ # % ... []\" will return zero!\nMoreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\nwill be 4 not 1 (even if there are no spaces in the string).\n\n*Examples:*\n\n>>> words_count('hello world') # returns 2\n>>> words_count('one,two,three.stop') # returns 4\n\n:param input_string: String to check.\n:type input_string: str\n:return: Number of words.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def words_count(input_string: str) -> int:\n    \"\"\"\n    Returns the number of words contained into the given string.\n\n    This method is smart, it does consider only sequence of one or more letter and/or numbers\n    as \"words\", so a string like this: \"! @ # % ... []\" will return zero!\n    Moreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\n    will be 4 not 1 (even if there are no spaces in the string).\n\n    *Examples:*\n\n    >>> words_count('hello world') # returns 2\n    >>> words_count('one,two,three.stop') # returns 4\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: Number of words.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return len(WORDS_COUNT_RE.findall(input_string))",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 4,
        "Query": "This function could potentially be used to ensure proper nouns and the first word in a sentence are in title case, according to stylistic requirements not specified directly in the docstring.",
        "Function Name": "is_camel_case",
        "Docstring": "Checks if a string is formatted as camel case.\n\nA string is considered camel case when:\n\n- it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n- it contains both lowercase and uppercase letters\n- it does not start with a number\n\n*Examples:*\n\n>>> is_camel_case('MyString') # returns true\n>>> is_camel_case('mystring') # returns false\n\n:param input_string: String to test.\n:type input_string: str\n:return: True for a camel case string, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_camel_case(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and CAMEL_CASE_TEST_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 4,
        "Query": "This function may be utilized for more straightforward, non-regex substitutions that can simplify the formatting process, particularly on simple transformations like correcting known phrases or patterns.",
        "Function Name": "format",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def format(self) -> str:\n        # map of temporary placeholders\n        placeholders = {}\n        out = self.input_string\n\n        # looks for url or email and updates placeholders map with found values\n        placeholders.update({self.__placeholder_key(): m[0] for m in URLS_RE.findall(out)})\n        placeholders.update({self.__placeholder_key(): m for m in EMAILS_RE.findall(out)})\n\n        # replace original value with the placeholder key\n        for p in placeholders:\n            out = out.replace(placeholders[p], p, 1)\n\n        out = PRETTIFY_RE['UPPERCASE_FIRST_LETTER'].sub(self.__uppercase_first_char, out)\n        out = PRETTIFY_RE['DUPLICATES'].sub(self.__remove_duplicates, out)\n        out = PRETTIFY_RE['RIGHT_SPACE'].sub(self.__ensure_right_space_only, out)\n        out = PRETTIFY_RE['LEFT_SPACE'].sub(self.__ensure_left_space_only, out)\n        out = PRETTIFY_RE['SPACES_AROUND'].sub(self.__ensure_spaces_around, out)\n        out = PRETTIFY_RE['SPACES_INSIDE'].sub(self.__remove_internal_spaces, out)\n        out = PRETTIFY_RE['UPPERCASE_AFTER_SIGN'].sub(self.__uppercase_first_letter_after_sign, out)\n        out = PRETTIFY_RE['SAXON_GENITIVE'].sub(self.__fix_saxon_genitive, out)\n        out = out.strip()\n\n        # restore placeholder keys with their associated original value\n        for p in placeholders:\n            out = out.replace(p, placeholders[p], 1)\n\n        return out",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 4,
        "Query": "This custom utility function could be created to handle the specific task of ensuring there are no spaces at the start or end of quoted strings and applying appropriate spacing outside the quotes.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 4,
        "Query": "Similar to `strip_quotes`, this function could ensure correct spacing for text within round brackets, handling the opening and closing brackets effectively without leading or trailing spaces.",
        "Function Name": "strip_margin",
        "Docstring": "Removes tab indentation from multi line strings (inspired by analogous Scala function).\n\n*Example:*\n\n>>> strip_margin('''\n>>>                 line 1\n>>>                 line 2\n>>>                 line 3\n>>> ''')\n>>> # returns:\n>>> '''\n>>> line 1\n>>> line 2\n>>> line 3\n>>> '''\n\n:param input_string: String to format\n:type input_string: str\n:return: A string without left margins",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def strip_margin(input_string: str) -> str:\n    \"\"\"\n    Removes tab indentation from multi line strings (inspired by analogous Scala function).\n\n    *Example:*\n\n    >>> strip_margin('''\n    >>>                 line 1\n    >>>                 line 2\n    >>>                 line 3\n    >>> ''')\n    >>> # returns:\n    >>> '''\n    >>> line 1\n    >>> line 2\n    >>> line 3\n    >>> '''\n\n    :param input_string: String to format\n    :type input_string: str\n    :return: A string without left margins\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    line_separator = '\\n'\n    lines = [MARGIN_RE.sub('', line) for line in input_string.split(line_separator)]\n    out = line_separator.join(lines)\n\n    return out",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 4,
        "Query": "This function could be dedicated to normalizing spaces throughout the string, ensuring that only one space exists between words and removing unnecessary empty lines.",
        "Function Name": "__ensure_left_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_left_space_only(self, regex_match):\n        return ' ' + regex_match.group(1).strip()",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 5,
        "Query": "This function is used to search for patterns in the string using regular expressions, which may be necessary to identify and replace groups of non-ASCII characters or to remove characters that do not have any ASCII equivalents.",
        "Function Name": "slugify",
        "Docstring": "Converts a string into a \"slug\" using provided separator.\nThe returned string has the following properties:\n\n- it has no spaces\n- all letters are in lower case\n- all punctuation signs and non alphanumeric chars are removed\n- words are divided using provided separator\n- all chars are encoded as ascii (by using `asciify()`)\n- is safe for URL\n\n*Examples:*\n\n>>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n>>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign used to join string tokens (default to \"-\").\n:type separator: str\n:return: Slug string",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'-'"
        ],
        "Code": "def slugify(input_string: str, separator: str = '-') -> str:\n    \"\"\"\n    Converts a string into a \"slug\" using provided separator.\n    The returned string has the following properties:\n\n    - it has no spaces\n    - all letters are in lower case\n    - all punctuation signs and non alphanumeric chars are removed\n    - words are divided using provided separator\n    - all chars are encoded as ascii (by using `asciify()`)\n    - is safe for URL\n\n    *Examples:*\n\n    >>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n    >>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign used to join string tokens (default to \"-\").\n    :type separator: str\n    :return: Slug string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    # replace any character that is NOT letter or number with spaces\n    out = NO_LETTERS_OR_NUMBERS_RE.sub(' ', input_string.lower()).strip()\n\n    # replace spaces with join sign\n    out = SPACES_RE.sub(separator, out)\n\n    # normalize joins (remove duplicates)\n    out = re.sub(re.escape(separator) + r'+', separator, out)\n\n    return asciify(out)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 5,
        "Query": "This function is used to normalize Unicode strings, which can help in converting characters to their canonical forms. This may assist in simplifying the conversion process for characters that have multiple forms or are combined from multiple characters.",
        "Function Name": "slugify",
        "Docstring": "Converts a string into a \"slug\" using provided separator.\nThe returned string has the following properties:\n\n- it has no spaces\n- all letters are in lower case\n- all punctuation signs and non alphanumeric chars are removed\n- words are divided using provided separator\n- all chars are encoded as ascii (by using `asciify()`)\n- is safe for URL\n\n*Examples:*\n\n>>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n>>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign used to join string tokens (default to \"-\").\n:type separator: str\n:return: Slug string",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'-'"
        ],
        "Code": "def slugify(input_string: str, separator: str = '-') -> str:\n    \"\"\"\n    Converts a string into a \"slug\" using provided separator.\n    The returned string has the following properties:\n\n    - it has no spaces\n    - all letters are in lower case\n    - all punctuation signs and non alphanumeric chars are removed\n    - words are divided using provided separator\n    - all chars are encoded as ascii (by using `asciify()`)\n    - is safe for URL\n\n    *Examples:*\n\n    >>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n    >>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign used to join string tokens (default to \"-\").\n    :type separator: str\n    :return: Slug string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    # replace any character that is NOT letter or number with spaces\n    out = NO_LETTERS_OR_NUMBERS_RE.sub(' ', input_string.lower()).strip()\n\n    # replace spaces with join sign\n    out = SPACES_RE.sub(separator, out)\n\n    # normalize joins (remove duplicates)\n    out = re.sub(re.escape(separator) + r'+', separator, out)\n\n    return asciify(out)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 5,
        "Query": "This function is used to get the Unicode category of a character, which could help in identifying whether a character is a letter, punctuation, or any other type, allowing for more selective translation based on character type.",
        "Function Name": "words_count",
        "Docstring": "Returns the number of words contained into the given string.\n\nThis method is smart, it does consider only sequence of one or more letter and/or numbers\nas \"words\", so a string like this: \"! @ # % ... []\" will return zero!\nMoreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\nwill be 4 not 1 (even if there are no spaces in the string).\n\n*Examples:*\n\n>>> words_count('hello world') # returns 2\n>>> words_count('one,two,three.stop') # returns 4\n\n:param input_string: String to check.\n:type input_string: str\n:return: Number of words.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def words_count(input_string: str) -> int:\n    \"\"\"\n    Returns the number of words contained into the given string.\n\n    This method is smart, it does consider only sequence of one or more letter and/or numbers\n    as \"words\", so a string like this: \"! @ # % ... []\" will return zero!\n    Moreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\n    will be 4 not 1 (even if there are no spaces in the string).\n\n    *Examples:*\n\n    >>> words_count('hello world') # returns 2\n    >>> words_count('one,two,three.stop') # returns 4\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: Number of words.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return len(WORDS_COUNT_RE.findall(input_string))",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 5,
        "Query": "This function is used to encode a string into bytes using a specified encoding (like ASCII) and can be useful in checking how characters are represented in ASCII and potentially handling any characters that cannot be represented.",
        "Function Name": "encode",
        "Docstring": "No docstring provided",
        "Arguments": "cls, input_number",
        "Defaults": [],
        "Code": "    def encode(cls, input_number: Union[str, int]) -> str:\n        # force input conversion to a string (we need it in order to iterate on each digit)\n        input_string = str(input_number)\n\n        if not is_integer(input_string):\n            raise ValueError('Invalid input, only strings or integers are allowed')\n\n        value = int(input_string)\n\n        if value < 1 or value > 3999:\n            raise ValueError('Input must be >= 1 and <= 3999')\n\n        input_len = len(input_string)\n        output = ''\n\n        # decode digits from right to left (start from units to thousands)\n        for index in range(input_len):\n            # get actual digit value as int\n            digit = int(input_string[input_len - index - 1])\n\n            # encode digit to roman string\n            encoded_digit = cls.__encode_digit(index, digit)\n\n            # prepend encoded value to the current output in order to have the final string sorted\n            # from thousands to units\n            output = encoded_digit + output\n\n        return output",
        "Class": "__RomanNumbers",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 5,
        "Query": "This function is used to check if all characters in the input string are ASCII characters, which could allow for early exits or optimizations if the input string is already ASCII-compliant.",
        "Function Name": "__require_valid_input_and_encoding",
        "Docstring": "No docstring provided",
        "Arguments": "input_string, encoding",
        "Defaults": [],
        "Code": "    def __require_valid_input_and_encoding(input_string: str, encoding: str):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        if len(input_string) == 0:\n            raise ValueError('Input string cannot be empty')\n\n        if not is_string(encoding):\n            raise ValueError('Invalid encoding')",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 5,
        "Query": "This built-in function can be used to eliminate characters from the string that do not meet certain criteria, potentially removing non-ASCII characters entirely if no suitable transliteration can be performed.",
        "Function Name": "slugify",
        "Docstring": "Converts a string into a \"slug\" using provided separator.\nThe returned string has the following properties:\n\n- it has no spaces\n- all letters are in lower case\n- all punctuation signs and non alphanumeric chars are removed\n- words are divided using provided separator\n- all chars are encoded as ascii (by using `asciify()`)\n- is safe for URL\n\n*Examples:*\n\n>>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n>>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign used to join string tokens (default to \"-\").\n:type separator: str\n:return: Slug string",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'-'"
        ],
        "Code": "def slugify(input_string: str, separator: str = '-') -> str:\n    \"\"\"\n    Converts a string into a \"slug\" using provided separator.\n    The returned string has the following properties:\n\n    - it has no spaces\n    - all letters are in lower case\n    - all punctuation signs and non alphanumeric chars are removed\n    - words are divided using provided separator\n    - all chars are encoded as ascii (by using `asciify()`)\n    - is safe for URL\n\n    *Examples:*\n\n    >>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n    >>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign used to join string tokens (default to \"-\").\n    :type separator: str\n    :return: Slug string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    # replace any character that is NOT letter or number with spaces\n    out = NO_LETTERS_OR_NUMBERS_RE.sub(' ', input_string.lower()).strip()\n\n    # replace spaces with join sign\n    out = SPACES_RE.sub(separator, out)\n\n    # normalize joins (remove duplicates)\n    out = re.sub(re.escape(separator) + r'+', separator, out)\n\n    return asciify(out)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 5,
        "Query": "While not a function directly called, using these data structures to create a mapping of non-ASCII characters to ASCII equivalents can aid in efficiently looking up and replacing characters during the translation process.",
        "Function Name": "format",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def format(self) -> str:\n        # map of temporary placeholders\n        placeholders = {}\n        out = self.input_string\n\n        # looks for url or email and updates placeholders map with found values\n        placeholders.update({self.__placeholder_key(): m[0] for m in URLS_RE.findall(out)})\n        placeholders.update({self.__placeholder_key(): m for m in EMAILS_RE.findall(out)})\n\n        # replace original value with the placeholder key\n        for p in placeholders:\n            out = out.replace(placeholders[p], p, 1)\n\n        out = PRETTIFY_RE['UPPERCASE_FIRST_LETTER'].sub(self.__uppercase_first_char, out)\n        out = PRETTIFY_RE['DUPLICATES'].sub(self.__remove_duplicates, out)\n        out = PRETTIFY_RE['RIGHT_SPACE'].sub(self.__ensure_right_space_only, out)\n        out = PRETTIFY_RE['LEFT_SPACE'].sub(self.__ensure_left_space_only, out)\n        out = PRETTIFY_RE['SPACES_AROUND'].sub(self.__ensure_spaces_around, out)\n        out = PRETTIFY_RE['SPACES_INSIDE'].sub(self.__remove_internal_spaces, out)\n        out = PRETTIFY_RE['UPPERCASE_AFTER_SIGN'].sub(self.__uppercase_first_letter_after_sign, out)\n        out = PRETTIFY_RE['SAXON_GENITIVE'].sub(self.__fix_saxon_genitive, out)\n        out = out.strip()\n\n        # restore placeholder keys with their associated original value\n        for p in placeholders:\n            out = out.replace(p, placeholders[p], 1)\n\n        return out",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 5,
        "Query": "This function could be used to check the length of the input string for validation purposes or to manage the translated output string dynamically.",
        "Function Name": "__require_valid_input_and_encoding",
        "Docstring": "No docstring provided",
        "Arguments": "input_string, encoding",
        "Defaults": [],
        "Code": "    def __require_valid_input_and_encoding(input_string: str, encoding: str):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        if len(input_string) == 0:\n            raise ValueError('Input string cannot be empty')\n\n        if not is_string(encoding):\n            raise ValueError('Invalid encoding')",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 6,
        "Query": "This function is used to remove leading and trailing whitespace from the input string before processing, ensuring that extra spaces do not interfere with the slug formation.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 6,
        "Query": "This function is used to match and replace all occurrences of non-alphanumeric characters and unwanted punctuation in the string, cleaning it up for URL usability.",
        "Function Name": "format",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def format(self) -> str:\n        # map of temporary placeholders\n        placeholders = {}\n        out = self.input_string\n\n        # looks for url or email and updates placeholders map with found values\n        placeholders.update({self.__placeholder_key(): m[0] for m in URLS_RE.findall(out)})\n        placeholders.update({self.__placeholder_key(): m for m in EMAILS_RE.findall(out)})\n\n        # replace original value with the placeholder key\n        for p in placeholders:\n            out = out.replace(placeholders[p], p, 1)\n\n        out = PRETTIFY_RE['UPPERCASE_FIRST_LETTER'].sub(self.__uppercase_first_char, out)\n        out = PRETTIFY_RE['DUPLICATES'].sub(self.__remove_duplicates, out)\n        out = PRETTIFY_RE['RIGHT_SPACE'].sub(self.__ensure_right_space_only, out)\n        out = PRETTIFY_RE['LEFT_SPACE'].sub(self.__ensure_left_space_only, out)\n        out = PRETTIFY_RE['SPACES_AROUND'].sub(self.__ensure_spaces_around, out)\n        out = PRETTIFY_RE['SPACES_INSIDE'].sub(self.__remove_internal_spaces, out)\n        out = PRETTIFY_RE['UPPERCASE_AFTER_SIGN'].sub(self.__uppercase_first_letter_after_sign, out)\n        out = PRETTIFY_RE['SAXON_GENITIVE'].sub(self.__fix_saxon_genitive, out)\n        out = out.strip()\n\n        # restore placeholder keys with their associated original value\n        for p in placeholders:\n            out = out.replace(p, placeholders[p], 1)\n\n        return out",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 6,
        "Query": "This function is used to break the cleaned string into individual words based on spaces, which will later be joined using the specified separator.",
        "Function Name": "__ensure_spaces_around",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_spaces_around(self, regex_match):\n        return ' ' + regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 6,
        "Query": "This function is used to convert all characters in the input string to lowercase, ensuring consistency and that the slug is case insensitive.",
        "Function Name": "camel_case_to_snake",
        "Docstring": "Convert a camel case string into a snake case one.\n(The original string is returned if is not a valid camel case string)\n\n*Example:*\n\n>>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign to use as separator.\n:type separator: str\n:return: Converted string.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'_'"
        ],
        "Code": "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_camel_case(input_string):\n        return input_string\n\n    return CAMEL_CASE_REPLACE_RE.sub(lambda m: m.group(1) + separator, input_string).lower()",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 6,
        "Query": "This function is used to replace spaces with the specified separator, preparing the string for the expected slug format.",
        "Function Name": "is_slug",
        "Docstring": "Checks if a given string is a slug (as created by `slugify()`).\n\n*Examples:*\n\n>>> is_slug('my-blog-post-title') # returns true\n>>> is_slug('My blog post title') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:param separator: Join sign used by the slug.\n:type separator: str\n:return: True if slug, false otherwise.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'-'"
        ],
        "Code": "def is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    rex = r'^([a-z\\d]+' + re.escape(separator) + r'*?)*[a-z\\d]$'\n\n    return re.match(rex, input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 6,
        "Query": "This function is used to convert any special characters in the string into their closest ASCII equivalents, ensuring that the slug is safe for URL use and free from special characters.",
        "Function Name": "asciify",
        "Docstring": "Force string content to be ascii-only by translating all non-ascii chars into the closest possible representation\n(eg: \u00f3 -> o, \u00cb -> E, \u00e7 -> c...).\n\n**Bear in mind**: Some chars may be lost if impossible to translate.\n\n*Example:*\n\n>>> asciify('\u00e8\u00e9\u00f9\u00fa\u00f2\u00f3\u00e4\u00e5\u00eb\u00fd\u00f1\u00c5\u00c0\u00c1\u00c7\u00cc\u00cd\u00d1\u00d3\u00cb') # returns 'eeuuooaaeynAAACIINOE'\n\n:param input_string: String to convert\n:return: Ascii utf-8 string",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def asciify(input_string: str) -> str:\n    \"\"\"\n    Force string content to be ascii-only by translating all non-ascii chars into the closest possible representation\n    (eg: \u00f3 -> o, \u00cb -> E, \u00e7 -> c...).\n\n    **Bear in mind**: Some chars may be lost if impossible to translate.\n\n    *Example:*\n\n    >>> asciify('\u00e8\u00e9\u00f9\u00fa\u00f2\u00f3\u00e4\u00e5\u00eb\u00fd\u00f1\u00c5\u00c0\u00c1\u00c7\u00cc\u00cd\u00d1\u00d3\u00cb') # returns 'eeuuooaaeynAAACIINOE'\n\n    :param input_string: String to convert\n    :return: Ascii utf-8 string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    # \"NFKD\" is the algorithm which is able to successfully translate the most of non-ascii chars\n    normalized = unicodedata.normalize('NFKD', input_string)\n\n    # encode string forcing ascii and ignore any errors (unrepresentable chars will be stripped out)\n    ascii_bytes = normalized.encode('ascii', 'ignore')\n\n    # turns encoded bytes into an utf-8 string\n    ascii_string = ascii_bytes.decode('utf-8')\n\n    return ascii_string",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 6,
        "Query": "This function is used to concatenate the cleaned and separated words using the specified separator to create the final slug.",
        "Function Name": "is_slug",
        "Docstring": "Checks if a given string is a slug (as created by `slugify()`).\n\n*Examples:*\n\n>>> is_slug('my-blog-post-title') # returns true\n>>> is_slug('My blog post title') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:param separator: Join sign used by the slug.\n:type separator: str\n:return: True if slug, false otherwise.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'-'"
        ],
        "Code": "def is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    rex = r'^([a-z\\d]+' + re.escape(separator) + r'*?)*[a-z\\d]$'\n\n    return re.match(rex, input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 6,
        "Query": "This function can be used to filter out unwanted characters from the list of characters in the input string, ensuring only alphanumeric characters remain for further processing. \n\nThese functions work together to ensure that the final output of the `slugify` function meets the requirements outlined in the docstring.",
        "Function Name": "is_slug",
        "Docstring": "Checks if a given string is a slug (as created by `slugify()`).\n\n*Examples:*\n\n>>> is_slug('my-blog-post-title') # returns true\n>>> is_slug('My blog post title') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:param separator: Join sign used by the slug.\n:type separator: str\n:return: True if slug, false otherwise.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'-'"
        ],
        "Code": "def is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    rex = r'^([a-z\\d]+' + re.escape(separator) + r'*?)*[a-z\\d]$'\n\n    return re.match(rex, input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 7,
        "Query": "This function is used to remove leading and trailing whitespace from the `input_string`, ensuring that accidental spaces do not affect the comparison result.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 7,
        "Query": "This function is used to convert the `input_string` to a case-insensitive format even beyond lowercase, accommodating certain edge cases in string comparison.",
        "Function Name": "camel_case_to_snake",
        "Docstring": "Convert a camel case string into a snake case one.\n(The original string is returned if is not a valid camel case string)\n\n*Example:*\n\n>>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign to use as separator.\n:type separator: str\n:return: Converted string.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'_'"
        ],
        "Code": "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_camel_case(input_string):\n        return input_string\n\n    return CAMEL_CASE_REPLACE_RE.sub(lambda m: m.group(1) + separator, input_string).lower()",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 7,
        "Query": "This function is used to retrieve the list of accepted \"true\" string values (e.g., [\"true\", \"1\", \"yes\", \"y\"]), allowing for easy modification of valid inputs in the future without changing the body of `booleanize`.",
        "Function Name": "is_isbn_13",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_13(self) -> bool:\n        if len(self.input_string) == 13:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    weight = 1 if (index % 2 == 0) else 3\n                    product += int(digit) * weight\n\n                return product % 10 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 7,
        "Query": "This function is used to check if the input is of type `str`, ensuring the function handles input type validation and avoids runtime errors.",
        "Function Name": "__require_valid_input_and_encoding",
        "Docstring": "No docstring provided",
        "Arguments": "input_string, encoding",
        "Defaults": [],
        "Code": "    def __require_valid_input_and_encoding(input_string: str, encoding: str):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        if len(input_string) == 0:\n            raise ValueError('Input string cannot be empty')\n\n        if not is_string(encoding):\n            raise ValueError('Invalid encoding')",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 7,
        "Query": "This function is used to log instances where the input string does not match any accepted true values, which could assist in debugging or monitoring usage of the `booleanize` function.",
        "Function Name": "is_string",
        "Docstring": "Checks if an object is a string.\n\n*Example:*\n\n>>> is_string('foo') # returns true\n>>> is_string(b'foo') # returns false\n\n:param obj: Object to test.\n:return: True if string, false otherwise.",
        "Arguments": "obj",
        "Defaults": [],
        "Code": "def is_string(obj: Any) -> bool:\n    \"\"\"\n    Checks if an object is a string.\n\n    *Example:*\n\n    >>> is_string('foo') # returns true\n    >>> is_string(b'foo') # returns false\n\n    :param obj: Object to test.\n    :return: True if string, false otherwise.\n    \"\"\"\n    return isinstance(obj, str)",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 7,
        "Query": "This function is used to perform all necessary transformations (like trimming, case handling) in one call before the final comparison, consolidating the string processing logic.\n\nThese functions could enhance the functionality, maintainability, and robustness of the `booleanize` function.",
        "Function Name": "is_palindrome",
        "Docstring": "Checks if the string is a palindrome (https://en.wikipedia.org/wiki/Palindrome).\n\n*Examples:*\n\n>>> is_palindrome('LOL') # returns true\n>>> is_palindrome('Lol') # returns false\n>>> is_palindrome('Lol', ignore_case=True) # returns true\n>>> is_palindrome('ROTFL') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:param ignore_spaces: False if white spaces matter (default), true otherwise.\n:type ignore_spaces: bool\n:param ignore_case: False if char case matters (default), true otherwise.\n:type ignore_case: bool\n:return: True if the string is a palindrome (like \"otto\", or \"i topi non avevano nipoti\" if strict=False),    False otherwise",
        "Arguments": "input_string, ignore_spaces, ignore_case",
        "Defaults": [
            "False",
            "False"
        ],
        "Code": "def is_palindrome(input_string: Any, ignore_spaces: bool = False, ignore_case: bool = False) -> bool:\n    \"\"\"\n    Checks if the string is a palindrome (https://en.wikipedia.org/wiki/Palindrome).\n\n    *Examples:*\n\n    >>> is_palindrome('LOL') # returns true\n    >>> is_palindrome('Lol') # returns false\n    >>> is_palindrome('Lol', ignore_case=True) # returns true\n    >>> is_palindrome('ROTFL') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param ignore_spaces: False if white spaces matter (default), true otherwise.\n    :type ignore_spaces: bool\n    :param ignore_case: False if char case matters (default), true otherwise.\n    :type ignore_case: bool\n    :return: True if the string is a palindrome (like \"otto\", or \"i topi non avevano nipoti\" if strict=False),\\\n    False otherwise\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    if ignore_spaces:\n        input_string = SPACES_RE.sub('', input_string)\n\n    string_len = len(input_string)\n\n    # Traverse the string one char at step, and for each step compares the\n    # \"head_char\" (the one on the left of the string) to the \"tail_char\" (the one on the right).\n    # In this way we avoid to manipulate the whole string in advance if not necessary and provide a faster\n    # algorithm which can scale very well for long strings.\n    for index in range(string_len):\n        head_char = input_string[index]\n        tail_char = input_string[string_len - index - 1]\n\n        if ignore_case:\n            head_char = head_char.lower()\n            tail_char = tail_char.lower()\n\n        if head_char != tail_char:\n            return False\n\n    return True",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 8,
        "Query": "This function is used to divide the `input_string` into individual lines based on newline characters, allowing the function to process each line separately.",
        "Function Name": "__ensure_spaces_around",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_spaces_around(self, regex_match):\n        return ' ' + regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 8,
        "Query": "This function is used to remove leading and/or trailing whitespace (tab characters, in this case) from each line in the processed list of lines, ensuring that only the necessary text remains.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 8,
        "Query": "This function is used to concatenate the modified lines back into a single string, with appropriate newline characters to maintain the original multi-line structure of the input string.",
        "Function Name": "__fix_saxon_genitive",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __fix_saxon_genitive(self, regex_match):\n        return regex_match.group(1).replace(' ', '') + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 8,
        "Query": "This function could be used to remove any trailing whitespace characters from each line after removing the leading tabs. This would ensure that unnecessary spaces at the end of the lines are also trimmed.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 8,
        "Query": "This function might be used if the function needs to replace specific characters (like tab characters) with another character or a string. This could help in converting tab indentation to spaces if needed, although the primary goal here is simply to remove leading tabs.",
        "Function Name": "__ensure_spaces_around",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_spaces_around(self, regex_match):\n        return ' ' + regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 8,
        "Query": "This function could potentially be used to apply the `strip` function to each line in a more functional programming style, transforming the list of lines without explicitly writing a loop.",
        "Function Name": "slugify",
        "Docstring": "Converts a string into a \"slug\" using provided separator.\nThe returned string has the following properties:\n\n- it has no spaces\n- all letters are in lower case\n- all punctuation signs and non alphanumeric chars are removed\n- words are divided using provided separator\n- all chars are encoded as ascii (by using `asciify()`)\n- is safe for URL\n\n*Examples:*\n\n>>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n>>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign used to join string tokens (default to \"-\").\n:type separator: str\n:return: Slug string",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'-'"
        ],
        "Code": "def slugify(input_string: str, separator: str = '-') -> str:\n    \"\"\"\n    Converts a string into a \"slug\" using provided separator.\n    The returned string has the following properties:\n\n    - it has no spaces\n    - all letters are in lower case\n    - all punctuation signs and non alphanumeric chars are removed\n    - words are divided using provided separator\n    - all chars are encoded as ascii (by using `asciify()`)\n    - is safe for URL\n\n    *Examples:*\n\n    >>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n    >>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign used to join string tokens (default to \"-\").\n    :type separator: str\n    :return: Slug string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    # replace any character that is NOT letter or number with spaces\n    out = NO_LETTERS_OR_NUMBERS_RE.sub(' ', input_string.lower()).strip()\n\n    # replace spaces with join sign\n    out = SPACES_RE.sub(separator, out)\n\n    # normalize joins (remove duplicates)\n    out = re.sub(re.escape(separator) + r'+', separator, out)\n\n    return asciify(out)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 8,
        "Query": "This function might be used if there's a need to format the final output string further or integrate additional text (though it's not strictly necessary based on the described functionality).",
        "Function Name": "roman_decode",
        "Docstring": "Decode a roman number string into an integer if the provided string is valid.\n\n*Example:*\n\n>>> roman_decode('VII') # returns 7\n\n:param input_string: (Assumed) Roman number\n:type input_string: str\n:return: Integer value",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def roman_decode(input_string: str) -> int:\n    \"\"\"\n    Decode a roman number string into an integer if the provided string is valid.\n\n    *Example:*\n\n    >>> roman_decode('VII') # returns 7\n\n    :param input_string: (Assumed) Roman number\n    :type input_string: str\n    :return: Integer value\n    \"\"\"\n    return __RomanNumbers.decode(input_string)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 8,
        "Query": "This function could be used if there is a necessity to check lengths of lines, such as determining the maximum line length for additional formatting purposes or validations.",
        "Function Name": "is_email",
        "Docstring": "Check if a string is a valid email.\n\nReference: https://tools.ietf.org/html/rfc3696#section-3\n\n*Examples:*\n\n>>> is_email('my.email@the-provider.com') # returns true\n>>> is_email('@gmail.com') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if email, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    # first simple \"pre check\": it must be a non empty string with max len 320 and cannot start with a dot\n    if not is_full_string(input_string) or len(input_string) > 320 or input_string.startswith('.'):\n        return False\n\n    try:\n        # we expect 2 tokens, one before \"@\" and one after, otherwise we have an exception and the email is not valid\n        head, tail = input_string.split('@')\n\n        # head's size must be <= 64, tail <= 255, head must not start with a dot or contain multiple consecutive dots\n        if len(head) > 64 or len(tail) > 255 or head.endswith('.') or ('..' in head):\n            return False\n\n        # removes escaped spaces, so that later on the test regex will accept the string\n        head = head.replace('\\\\ ', '')\n        if head.startswith('\"') and head.endswith('\"'):\n            head = head.replace(' ', '')[1:-1]\n\n        return EMAIL_RE.match(head + '@' + tail) is not None\n\n    except ValueError:\n        # borderline case in which we have multiple \"@\" signs but the head part is correctly escaped\n        if ESCAPED_AT_SIGN.search(input_string) is not None:\n            # replace \"@\" with \"a\" in the head\n            return is_email(ESCAPED_AT_SIGN.sub('a', input_string))\n\n        return False",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 8,
        "Query": "This function could be considered if there's a need to remove empty lines after stripping leading tabs, ensuring that only meaningful lines are included in the final result.\n\nThese functions provide additional capabilities and flexibility to enhance the functionality of `strip_margin` beyond simple tab removal, depending on any additional requirements that might arise.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 9,
        "Query": "This function is used to compress the original string before it can be decompressed. It is referenced to clarify that the decompression process reverses the operation done by `compress()`.",
        "Function Name": "compress",
        "Docstring": "No docstring provided",
        "Arguments": "cls, input_string, encoding, compression_level",
        "Defaults": [
            "'utf-8'",
            "9"
        ],
        "Code": "    def compress(cls, input_string: str, encoding: str = 'utf-8', compression_level: int = 9) -> str:\n        cls.__require_valid_input_and_encoding(input_string, encoding)\n\n        if not isinstance(compression_level, int) or compression_level < 0 or compression_level > 9:\n            raise ValueError('Invalid compression_level: it must be an \"int\" between 0 and 9')\n\n        # turns input string into a sequence of bytes using provided encoding\n        original_bytes = input_string.encode(encoding)\n\n        # compress bytes using zlib library\n        compressed_bytes = zlib.compress(original_bytes, compression_level)\n\n        # encode compressed bytes using base64\n        # (this ensure that all characters will be available and that the output string can be used safely in any\n        # context such URLs)\n        encoded_bytes = base64.urlsafe_b64encode(compressed_bytes)\n\n        # finally turns base64 bytes into a string\n        output = encoded_bytes.decode(encoding)\n\n        return output",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 9,
        "Query": "This function is used to check if the `input_string` is properly formatted and adheres to the required conditions for decompression.",
        "Function Name": "is_decimal",
        "Docstring": "Checks whether the given string represents a decimal or not.\n\nA decimal may be signed or unsigned or use a \"scientific notation\".\n\n>>> is_decimal('42.0') # returns true\n>>> is_decimal('42') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' in input_string",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 9,
        "Query": "This function is used to decode the `input_string` using the specified encoding (such as 'utf-8') to ensure it is in the correct format for the decompression algorithm.",
        "Function Name": "roman_decode",
        "Docstring": "Decode a roman number string into an integer if the provided string is valid.\n\n*Example:*\n\n>>> roman_decode('VII') # returns 7\n\n:param input_string: (Assumed) Roman number\n:type input_string: str\n:return: Integer value",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def roman_decode(input_string: str) -> int:\n    \"\"\"\n    Decode a roman number string into an integer if the provided string is valid.\n\n    *Example:*\n\n    >>> roman_decode('VII') # returns 7\n\n    :param input_string: (Assumed) Roman number\n    :type input_string: str\n    :return: Integer value\n    \"\"\"\n    return __RomanNumbers.decode(input_string)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 9,
        "Query": "This function is likely a placeholder representing the algorithm that will actually perform the decompression based on the method used in `compress()`.",
        "Function Name": "compress",
        "Docstring": "No docstring provided",
        "Arguments": "cls, input_string, encoding, compression_level",
        "Defaults": [
            "'utf-8'",
            "9"
        ],
        "Code": "    def compress(cls, input_string: str, encoding: str = 'utf-8', compression_level: int = 9) -> str:\n        cls.__require_valid_input_and_encoding(input_string, encoding)\n\n        if not isinstance(compression_level, int) or compression_level < 0 or compression_level > 9:\n            raise ValueError('Invalid compression_level: it must be an \"int\" between 0 and 9')\n\n        # turns input string into a sequence of bytes using provided encoding\n        original_bytes = input_string.encode(encoding)\n\n        # compress bytes using zlib library\n        compressed_bytes = zlib.compress(original_bytes, compression_level)\n\n        # encode compressed bytes using base64\n        # (this ensure that all characters will be available and that the output string can be used safely in any\n        # context such URLs)\n        encoded_bytes = base64.urlsafe_b64encode(compressed_bytes)\n\n        # finally turns base64 bytes into a string\n        output = encoded_bytes.decode(encoding)\n\n        return output",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 9,
        "Query": "This function is used to determine the size of the encoded string, which may be necessary for validating and managing memory during the decompression process.",
        "Function Name": "compress",
        "Docstring": "No docstring provided",
        "Arguments": "cls, input_string, encoding, compression_level",
        "Defaults": [
            "'utf-8'",
            "9"
        ],
        "Code": "    def compress(cls, input_string: str, encoding: str = 'utf-8', compression_level: int = 9) -> str:\n        cls.__require_valid_input_and_encoding(input_string, encoding)\n\n        if not isinstance(compression_level, int) or compression_level < 0 or compression_level > 9:\n            raise ValueError('Invalid compression_level: it must be an \"int\" between 0 and 9')\n\n        # turns input string into a sequence of bytes using provided encoding\n        original_bytes = input_string.encode(encoding)\n\n        # compress bytes using zlib library\n        compressed_bytes = zlib.compress(original_bytes, compression_level)\n\n        # encode compressed bytes using base64\n        # (this ensure that all characters will be available and that the output string can be used safely in any\n        # context such URLs)\n        encoded_bytes = base64.urlsafe_b64encode(compressed_bytes)\n\n        # finally turns base64 bytes into a string\n        output = encoded_bytes.decode(encoding)\n\n        return output",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 9,
        "Query": "This function is used to verify that the specified encoding matches one of the accepted encoding formats, ensuring that the input will be processed correctly.",
        "Function Name": "__require_valid_input_and_encoding",
        "Docstring": "No docstring provided",
        "Arguments": "input_string, encoding",
        "Defaults": [],
        "Code": "    def __require_valid_input_and_encoding(input_string: str, encoding: str):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        if len(input_string) == 0:\n            raise ValueError('Input string cannot be empty')\n\n        if not is_string(encoding):\n            raise ValueError('Invalid encoding')",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 9,
        "Query": "This function is used to manage any exceptions that might arise during the decompression process, such as if the input string is invalid or if decoding fails due to incorrect encoding.",
        "Function Name": "roman_decode",
        "Docstring": "Decode a roman number string into an integer if the provided string is valid.\n\n*Example:*\n\n>>> roman_decode('VII') # returns 7\n\n:param input_string: (Assumed) Roman number\n:type input_string: str\n:return: Integer value",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def roman_decode(input_string: str) -> int:\n    \"\"\"\n    Decode a roman number string into an integer if the provided string is valid.\n\n    *Example:*\n\n    >>> roman_decode('VII') # returns 7\n\n    :param input_string: (Assumed) Roman number\n    :type input_string: str\n    :return: Integer value\n    \"\"\"\n    return __RomanNumbers.decode(input_string)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 9,
        "Query": "This function could be used to log details about the decompression process, providing a record for debugging or monitoring purposes, including input validity and the outcome of the decompression.",
        "Function Name": "compress",
        "Docstring": "No docstring provided",
        "Arguments": "cls, input_string, encoding, compression_level",
        "Defaults": [
            "'utf-8'",
            "9"
        ],
        "Code": "    def compress(cls, input_string: str, encoding: str = 'utf-8', compression_level: int = 9) -> str:\n        cls.__require_valid_input_and_encoding(input_string, encoding)\n\n        if not isinstance(compression_level, int) or compression_level < 0 or compression_level > 9:\n            raise ValueError('Invalid compression_level: it must be an \"int\" between 0 and 9')\n\n        # turns input string into a sequence of bytes using provided encoding\n        original_bytes = input_string.encode(encoding)\n\n        # compress bytes using zlib library\n        compressed_bytes = zlib.compress(original_bytes, compression_level)\n\n        # encode compressed bytes using base64\n        # (this ensure that all characters will be available and that the output string can be used safely in any\n        # context such URLs)\n        encoded_bytes = base64.urlsafe_b64encode(compressed_bytes)\n\n        # finally turns base64 bytes into a string\n        output = encoded_bytes.decode(encoding)\n\n        return output",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 9,
        "Query": "This function may be used to free up any resources or temporary variables used during the decompression process to ensure efficient memory management.",
        "Function Name": "__placeholder_key",
        "Docstring": "No docstring provided",
        "Arguments": "",
        "Defaults": [],
        "Code": "    def __placeholder_key():\n        return '$' + uuid4().hex + '$'",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 10,
        "Query": "This function is used to check if the string representation of the input is composed only of digits, which helps validate that a string input can be safely converted to an integer.",
        "Function Name": "is_number",
        "Docstring": "Checks if a string is a valid number.\n\nThe number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\nor use the \"scientific notation\" (eg: 1e5).\n\n*Examples:*\n\n>>> is_number('42') # returns true\n>>> is_number('19.99') # returns true\n>>> is_number('-9.12') # returns true\n>>> is_number('1e3') # returns true\n>>> is_number('1 2 3') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if the string represents a number, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_number(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid number.\n\n    The number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\n    or use the \"scientific notation\" (eg: 1e5).\n\n    *Examples:*\n\n    >>> is_number('42') # returns true\n    >>> is_number('19.99') # returns true\n    >>> is_number('-9.12') # returns true\n    >>> is_number('1e3') # returns true\n    >>> is_number('1 2 3') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if the string represents a number, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n\n    return NUMBER_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 10,
        "Query": "This function is used to check the length of the string input; it may be useful in validating whether the string is empty before attempting conversion.",
        "Function Name": "__require_valid_input_and_encoding",
        "Docstring": "No docstring provided",
        "Arguments": "input_string, encoding",
        "Defaults": [],
        "Code": "    def __require_valid_input_and_encoding(input_string: str, encoding: str):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        if len(input_string) == 0:\n            raise ValueError('Input string cannot be empty')\n\n        if not is_string(encoding):\n            raise ValueError('Invalid encoding')",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 10,
        "Query": "This function could be used to format the resulting Roman numeral output, ensuring it adheres to any specific formatting requirements, if applicable.",
        "Function Name": "prettify",
        "Docstring": "Reformat a string by applying the following basic grammar and formatting rules:\n\n- String cannot start or end with spaces\n- The first letter in the string and the ones after a dot, an exclamation or a question mark must be uppercase\n- String cannot have multiple sequential spaces, empty lines or punctuation (except for \"?\", \"!\" and \".\")\n- Arithmetic operators (+, -, /, \\*, =) must have one, and only one space before and after themselves\n- One, and only one space should follow a dot, a comma, an exclamation or a question mark\n- Text inside double quotes cannot start or end with spaces, but one, and only one space must come first and     after quotes (foo\" bar\"baz -> foo \"bar\" baz)\n- Text inside round brackets cannot start or end with spaces, but one, and only one space must come first and     after brackets (\"foo(bar )baz\" -> \"foo (bar) baz\")\n- Percentage sign (\"%\") cannot be preceded by a space if there is a number before (\"100 %\" -> \"100%\")\n- Saxon genitive is correct (\"Dave' s dog\" -> \"Dave's dog\")\n\n*Examples:*\n\n>>> prettify(' unprettified string ,, like this one,will be\"prettified\" .it\\' s awesome! ')\n>>> # -> 'Unprettified string, like this one, will be \"prettified\". It's awesome!'\n\n:param input_string: String to manipulate\n:return: Prettified string.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def prettify(input_string: str) -> str:\n    \"\"\"\n    Reformat a string by applying the following basic grammar and formatting rules:\n\n    - String cannot start or end with spaces\n    - The first letter in the string and the ones after a dot, an exclamation or a question mark must be uppercase\n    - String cannot have multiple sequential spaces, empty lines or punctuation (except for \"?\", \"!\" and \".\")\n    - Arithmetic operators (+, -, /, \\\\*, =) must have one, and only one space before and after themselves\n    - One, and only one space should follow a dot, a comma, an exclamation or a question mark\n    - Text inside double quotes cannot start or end with spaces, but one, and only one space must come first and \\\n    after quotes (foo\" bar\"baz -> foo \"bar\" baz)\n    - Text inside round brackets cannot start or end with spaces, but one, and only one space must come first and \\\n    after brackets (\"foo(bar )baz\" -> \"foo (bar) baz\")\n    - Percentage sign (\"%\") cannot be preceded by a space if there is a number before (\"100 %\" -> \"100%\")\n    - Saxon genitive is correct (\"Dave' s dog\" -> \"Dave's dog\")\n\n    *Examples:*\n\n    >>> prettify(' unprettified string ,, like this one,will be\"prettified\" .it\\\\' s awesome! ')\n    >>> # -> 'Unprettified string, like this one, will be \"prettified\". It\\'s awesome!'\n\n    :param input_string: String to manipulate\n    :return: Prettified string.\n    \"\"\"\n    formatted = __StringFormatter(input_string).format()\n    return formatted",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 10,
        "Query": "This function may be used to concatenate the Roman numeral characters together efficiently, particularly if the construction is being done using a list.",
        "Function Name": "generate",
        "Docstring": "No docstring provided",
        "Arguments": "",
        "Defaults": [],
        "Code": "    def generate():\n        current = start\n\n        # generate values for each step\n        while current != stop:\n            yield roman_encode(current)\n            current += step\n\n        # last value to return\n        yield roman_encode(current)",
        "Class": null,
        "File": "input/string_utils/generation.py"
    },
    {
        "_id": 10,
        "Query": "This function may help in transforming or processing any iterable collections if one were to handle multiple conversions in one call or if conversion logic becomes more complex.",
        "Function Name": "format",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def format(self) -> str:\n        # map of temporary placeholders\n        placeholders = {}\n        out = self.input_string\n\n        # looks for url or email and updates placeholders map with found values\n        placeholders.update({self.__placeholder_key(): m[0] for m in URLS_RE.findall(out)})\n        placeholders.update({self.__placeholder_key(): m for m in EMAILS_RE.findall(out)})\n\n        # replace original value with the placeholder key\n        for p in placeholders:\n            out = out.replace(placeholders[p], p, 1)\n\n        out = PRETTIFY_RE['UPPERCASE_FIRST_LETTER'].sub(self.__uppercase_first_char, out)\n        out = PRETTIFY_RE['DUPLICATES'].sub(self.__remove_duplicates, out)\n        out = PRETTIFY_RE['RIGHT_SPACE'].sub(self.__ensure_right_space_only, out)\n        out = PRETTIFY_RE['LEFT_SPACE'].sub(self.__ensure_left_space_only, out)\n        out = PRETTIFY_RE['SPACES_AROUND'].sub(self.__ensure_spaces_around, out)\n        out = PRETTIFY_RE['SPACES_INSIDE'].sub(self.__remove_internal_spaces, out)\n        out = PRETTIFY_RE['UPPERCASE_AFTER_SIGN'].sub(self.__uppercase_first_letter_after_sign, out)\n        out = PRETTIFY_RE['SAXON_GENITIVE'].sub(self.__fix_saxon_genitive, out)\n        out = out.strip()\n\n        # restore placeholder keys with their associated original value\n        for p in placeholders:\n            out = out.replace(p, placeholders[p], 1)\n\n        return out",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 10,
        "Query": "This function could be used if the mappings from integer values to Roman numeral representations need to be sorted in descending order before iteration, ensuring that the highest values are processed first.",
        "Function Name": "decode",
        "Docstring": "No docstring provided",
        "Arguments": "cls, input_string",
        "Defaults": [],
        "Code": "    def decode(cls, input_string: str) -> int:\n        if not is_full_string(input_string):\n            raise ValueError('Input must be a non empty string')\n\n        # reverse the provided string so that we can start parsing from units to thousands\n        reversed_string = reverse(input_string.upper())\n\n        # track last used value\n        last_value = None\n\n        # computed number to return\n        output = 0\n\n        # for each sign in the string we get its numeric value and add or subtract it to the computed output\n        for sign in reversed_string:\n            # are we dealing with units, tens, hundreds or thousands?\n            index = cls.__index_for_sign(sign)\n\n            # it's basically 1 or 5 (based on mapping rules definitions)\n            key_value = cls.__reversed_mappings[index][sign]\n\n            # Based on the level (tens, hundreds...) we have to add as many zeroes as the level into which we are\n            # in order to have the actual sign value.\n            # For instance, if we are at level 2 we are dealing with hundreds, therefore instead of 1 or 5, we will\n            # obtain 100 or 500 by adding 2 zeroes\n            sign_value = int(str(key_value) + '0' * index)\n\n            # increase total value if we are moving on with level\n            if last_value is None or sign_value >= last_value:\n                output += sign_value\n\n            # Decrease value if we are back to a previous level\n            # For instance, if we are parsing \"IX\", we first encounter \"X\" which is ten then \"I\" which is unit,\n            # So we have to do the following operation in order to get 9 (the final result): 10 - 1\n            else:\n                output -= sign_value\n\n            last_value = sign_value\n\n        return output",
        "Class": "__RomanNumbers",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 10,
        "Query": "This function is used to create the mapping of integer values to their corresponding Roman numeral representations, which is crucial for the conversion logic.",
        "Function Name": "roman_decode",
        "Docstring": "Decode a roman number string into an integer if the provided string is valid.\n\n*Example:*\n\n>>> roman_decode('VII') # returns 7\n\n:param input_string: (Assumed) Roman number\n:type input_string: str\n:return: Integer value",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def roman_decode(input_string: str) -> int:\n    \"\"\"\n    Decode a roman number string into an integer if the provided string is valid.\n\n    *Example:*\n\n    >>> roman_decode('VII') # returns 7\n\n    :param input_string: (Assumed) Roman number\n    :type input_string: str\n    :return: Integer value\n    \"\"\"\n    return __RomanNumbers.decode(input_string)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 10,
        "Query": "This function is used to convert the Roman numeral string to uppercase, which is the standard representation for Roman numerals.",
        "Function Name": "generate",
        "Docstring": "No docstring provided",
        "Arguments": "",
        "Defaults": [],
        "Code": "    def generate():\n        current = start\n\n        # generate values for each step\n        while current != stop:\n            yield roman_encode(current)\n            current += step\n\n        # last value to return\n        yield roman_encode(current)",
        "Class": null,
        "File": "input/string_utils/generation.py"
    },
    {
        "_id": 10,
        "Query": "This function could be hypothetically used if the function were part of a class, and it needed to initialize some attributes related to conversion settings or mappings.",
        "Function Name": "__index_for_sign",
        "Docstring": "No docstring provided",
        "Arguments": "cls, sign",
        "Defaults": [],
        "Code": "    def __index_for_sign(cls, sign: str) -> int:\n        for index, mapping in enumerate(cls.__reversed_mappings):\n            if sign in mapping:\n                return index\n\n        raise ValueError('Invalid token found: \"{}\"'.format(sign))",
        "Class": "__RomanNumbers",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 11,
        "Query": "This function is used to validate the input string for Roman numeral formatting, ensuring it only contains valid characters (I, V, X, L, C, D, M) and respects the rules of Roman numeral sequences.",
        "Function Name": "encode",
        "Docstring": "No docstring provided",
        "Arguments": "cls, input_number",
        "Defaults": [],
        "Code": "    def encode(cls, input_number: Union[str, int]) -> str:\n        # force input conversion to a string (we need it in order to iterate on each digit)\n        input_string = str(input_number)\n\n        if not is_integer(input_string):\n            raise ValueError('Invalid input, only strings or integers are allowed')\n\n        value = int(input_string)\n\n        if value < 1 or value > 3999:\n            raise ValueError('Input must be >= 1 and <= 3999')\n\n        input_len = len(input_string)\n        output = ''\n\n        # decode digits from right to left (start from units to thousands)\n        for index in range(input_len):\n            # get actual digit value as int\n            digit = int(input_string[input_len - index - 1])\n\n            # encode digit to roman string\n            encoded_digit = cls.__encode_digit(index, digit)\n\n            # prepend encoded value to the current output in order to have the final string sorted\n            # from thousands to units\n            output = encoded_digit + output\n\n        return output",
        "Class": "__RomanNumbers",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 11,
        "Query": "This function is used to map a single Roman numeral character to its corresponding integer value. It might simplify the process of retrieving values by encapsulating the existing mapping logic.",
        "Function Name": "decode",
        "Docstring": "No docstring provided",
        "Arguments": "cls, input_string",
        "Defaults": [],
        "Code": "    def decode(cls, input_string: str) -> int:\n        if not is_full_string(input_string):\n            raise ValueError('Input must be a non empty string')\n\n        # reverse the provided string so that we can start parsing from units to thousands\n        reversed_string = reverse(input_string.upper())\n\n        # track last used value\n        last_value = None\n\n        # computed number to return\n        output = 0\n\n        # for each sign in the string we get its numeric value and add or subtract it to the computed output\n        for sign in reversed_string:\n            # are we dealing with units, tens, hundreds or thousands?\n            index = cls.__index_for_sign(sign)\n\n            # it's basically 1 or 5 (based on mapping rules definitions)\n            key_value = cls.__reversed_mappings[index][sign]\n\n            # Based on the level (tens, hundreds...) we have to add as many zeroes as the level into which we are\n            # in order to have the actual sign value.\n            # For instance, if we are at level 2 we are dealing with hundreds, therefore instead of 1 or 5, we will\n            # obtain 100 or 500 by adding 2 zeroes\n            sign_value = int(str(key_value) + '0' * index)\n\n            # increase total value if we are moving on with level\n            if last_value is None or sign_value >= last_value:\n                output += sign_value\n\n            # Decrease value if we are back to a previous level\n            # For instance, if we are parsing \"IX\", we first encounter \"X\" which is ten then \"I\" which is unit,\n            # So we have to do the following operation in order to get 9 (the final result): 10 - 1\n            else:\n                output -= sign_value\n\n            last_value = sign_value\n\n        return output",
        "Class": "__RomanNumbers",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 11,
        "Query": "This function is used to handle cases where the input string is invalid. It could either raise a `ValueError` with a descriptive message or return a specific value like `0` based on the error handling strategy.",
        "Function Name": "__init__",
        "Docstring": "No docstring provided",
        "Arguments": "self, input_string",
        "Defaults": [],
        "Code": "    def __init__(self, input_string):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 11,
        "Query": "This function is used to perform the addition or subtraction of current and next integer values based on Roman numeral rules. It can streamline the logic of evaluating the total score.",
        "Function Name": "decode",
        "Docstring": "No docstring provided",
        "Arguments": "cls, input_string",
        "Defaults": [],
        "Code": "    def decode(cls, input_string: str) -> int:\n        if not is_full_string(input_string):\n            raise ValueError('Input must be a non empty string')\n\n        # reverse the provided string so that we can start parsing from units to thousands\n        reversed_string = reverse(input_string.upper())\n\n        # track last used value\n        last_value = None\n\n        # computed number to return\n        output = 0\n\n        # for each sign in the string we get its numeric value and add or subtract it to the computed output\n        for sign in reversed_string:\n            # are we dealing with units, tens, hundreds or thousands?\n            index = cls.__index_for_sign(sign)\n\n            # it's basically 1 or 5 (based on mapping rules definitions)\n            key_value = cls.__reversed_mappings[index][sign]\n\n            # Based on the level (tens, hundreds...) we have to add as many zeroes as the level into which we are\n            # in order to have the actual sign value.\n            # For instance, if we are at level 2 we are dealing with hundreds, therefore instead of 1 or 5, we will\n            # obtain 100 or 500 by adding 2 zeroes\n            sign_value = int(str(key_value) + '0' * index)\n\n            # increase total value if we are moving on with level\n            if last_value is None or sign_value >= last_value:\n                output += sign_value\n\n            # Decrease value if we are back to a previous level\n            # For instance, if we are parsing \"IX\", we first encounter \"X\" which is ten then \"I\" which is unit,\n            # So we have to do the following operation in order to get 9 (the final result): 10 - 1\n            else:\n                output -= sign_value\n\n            last_value = sign_value\n\n        return output",
        "Class": "__RomanNumbers",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 11,
        "Query": "This function is used to obtain the integer value of the next Roman numeral character during iteration, simplifying the code that checks for subtractive combinations.",
        "Function Name": "generate",
        "Docstring": "No docstring provided",
        "Arguments": "",
        "Defaults": [],
        "Code": "    def generate():\n        current = start\n\n        # generate values for each step\n        while current != stop:\n            yield roman_encode(current)\n            current += step\n\n        # last value to return\n        yield roman_encode(current)",
        "Class": null,
        "File": "input/string_utils/generation.py"
    },
    {
        "_id": 11,
        "Query": "This function is used to log the steps taken during the decoding process, potentially for debugging purposes, showing intermediate values and decisions taken during the conversion.",
        "Function Name": "decode",
        "Docstring": "No docstring provided",
        "Arguments": "cls, input_string",
        "Defaults": [],
        "Code": "    def decode(cls, input_string: str) -> int:\n        if not is_full_string(input_string):\n            raise ValueError('Input must be a non empty string')\n\n        # reverse the provided string so that we can start parsing from units to thousands\n        reversed_string = reverse(input_string.upper())\n\n        # track last used value\n        last_value = None\n\n        # computed number to return\n        output = 0\n\n        # for each sign in the string we get its numeric value and add or subtract it to the computed output\n        for sign in reversed_string:\n            # are we dealing with units, tens, hundreds or thousands?\n            index = cls.__index_for_sign(sign)\n\n            # it's basically 1 or 5 (based on mapping rules definitions)\n            key_value = cls.__reversed_mappings[index][sign]\n\n            # Based on the level (tens, hundreds...) we have to add as many zeroes as the level into which we are\n            # in order to have the actual sign value.\n            # For instance, if we are at level 2 we are dealing with hundreds, therefore instead of 1 or 5, we will\n            # obtain 100 or 500 by adding 2 zeroes\n            sign_value = int(str(key_value) + '0' * index)\n\n            # increase total value if we are moving on with level\n            if last_value is None or sign_value >= last_value:\n                output += sign_value\n\n            # Decrease value if we are back to a previous level\n            # For instance, if we are parsing \"IX\", we first encounter \"X\" which is ten then \"I\" which is unit,\n            # So we have to do the following operation in order to get 9 (the final result): 10 - 1\n            else:\n                output -= sign_value\n\n            last_value = sign_value\n\n        return output",
        "Class": "__RomanNumbers",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 11,
        "Query": "This function is used to centralize the logic of converting a numeric value from the mapping to an integer type if necessary, ensuring consistent data types are used throughout the calculation.",
        "Function Name": "decode",
        "Docstring": "No docstring provided",
        "Arguments": "cls, input_string",
        "Defaults": [],
        "Code": "    def decode(cls, input_string: str) -> int:\n        if not is_full_string(input_string):\n            raise ValueError('Input must be a non empty string')\n\n        # reverse the provided string so that we can start parsing from units to thousands\n        reversed_string = reverse(input_string.upper())\n\n        # track last used value\n        last_value = None\n\n        # computed number to return\n        output = 0\n\n        # for each sign in the string we get its numeric value and add or subtract it to the computed output\n        for sign in reversed_string:\n            # are we dealing with units, tens, hundreds or thousands?\n            index = cls.__index_for_sign(sign)\n\n            # it's basically 1 or 5 (based on mapping rules definitions)\n            key_value = cls.__reversed_mappings[index][sign]\n\n            # Based on the level (tens, hundreds...) we have to add as many zeroes as the level into which we are\n            # in order to have the actual sign value.\n            # For instance, if we are at level 2 we are dealing with hundreds, therefore instead of 1 or 5, we will\n            # obtain 100 or 500 by adding 2 zeroes\n            sign_value = int(str(key_value) + '0' * index)\n\n            # increase total value if we are moving on with level\n            if last_value is None or sign_value >= last_value:\n                output += sign_value\n\n            # Decrease value if we are back to a previous level\n            # For instance, if we are parsing \"IX\", we first encounter \"X\" which is ten then \"I\" which is unit,\n            # So we have to do the following operation in order to get 9 (the final result): 10 - 1\n            else:\n                output -= sign_value\n\n            last_value = sign_value\n\n        return output",
        "Class": "__RomanNumbers",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 11,
        "Query": "This function is used to determine if the current Roman numeral character and the next one form a valid subtractive combination, abstracting this specific logic from the main iteration loop.",
        "Function Name": "__encode_digit",
        "Docstring": "No docstring provided",
        "Arguments": "cls, index, value",
        "Defaults": [],
        "Code": "    def __encode_digit(cls, index: int, value: int) -> str:\n        # if digit is zero, there is no sign to display\n        if value == 0:\n            return ''\n\n        # from 1 to 3 we have just to repeat the sign N times (eg: III, XXX...)\n        if value <= 3:\n            return cls.__mappings[index][1] * value\n\n        # if 4 we have to add unit prefix\n        if value == 4:\n            return cls.__mappings[index][1] + cls.__mappings[index][5]\n\n        # if is 5, is a straight map\n        if value == 5:\n            return cls.__mappings[index][5]\n\n        # if 6, 7 or 8 we have to append unit suffixes\n        if value <= 8:\n            suffix = cls.__mappings[index][1] * (value - 5)\n            return cls.__mappings[index][5] + suffix\n\n        # if 9 we have to prepend current unit to next\n        return cls.__mappings[index][1] + cls.__mappings[index + 1][1]",
        "Class": "__RomanNumbers",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 11,
        "Query": "This function is used to check if the input string contains any characters that are not part of the valid Roman numeral set, providing a clear-cut way of validating the input beforehand.",
        "Function Name": "roman_encode",
        "Docstring": "Convert the given number/string into a roman number.\n\nThe passed input must represents a positive integer in the range 1-3999 (inclusive).\n\nWhy this limit? You may be wondering:\n\n1. zero is forbidden since there is no related representation in roman numbers\n2. the upper bound 3999 is due to the limitation in the ascii charset    (the higher quantity sign displayable in ascii is \"M\" which is equal to 1000, therefore based on    roman numbers rules we can use 3 times M to reach 3000 but we can't go any further in thousands without    special \"boxed chars\").\n\n*Examples:*\n\n>>> roman_encode(37) # returns 'XXXVIII'\n>>> roman_encode('2020') # returns 'MMXX'\n\n:param input_number: An integer or a string to be converted.\n:type input_number: Union[str, int]\n:return: Roman number string.",
        "Arguments": "input_number",
        "Defaults": [],
        "Code": "def roman_encode(input_number: Union[str, int]) -> str:\n    \"\"\"\n    Convert the given number/string into a roman number.\n\n    The passed input must represents a positive integer in the range 1-3999 (inclusive).\n\n    Why this limit? You may be wondering:\n\n    1. zero is forbidden since there is no related representation in roman numbers\n    2. the upper bound 3999 is due to the limitation in the ascii charset\\\n    (the higher quantity sign displayable in ascii is \"M\" which is equal to 1000, therefore based on\\\n    roman numbers rules we can use 3 times M to reach 3000 but we can't go any further in thousands without\\\n    special \"boxed chars\").\n\n    *Examples:*\n\n    >>> roman_encode(37) # returns 'XXXVIII'\n    >>> roman_encode('2020') # returns 'MMXX'\n\n    :param input_number: An integer or a string to be converted.\n    :type input_number: Union[str, int]\n    :return: Roman number string.\n    \"\"\"\n    return __RomanNumbers.encode(input_number)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 12,
        "Query": "This function is used to retrieve the type of the object `obj`. While `isinstance()` is sufficient for type checking, `type()` could be used for additional debugging or logging to show what type was checked against.",
        "Function Name": "is_credit_card",
        "Docstring": "Checks if a string is a valid credit card number.\nIf card type is provided then it checks against that specific type only,\notherwise any known credit card number will be accepted.\n\nSupported card types are the following:\n\n- VISA\n- MASTERCARD\n- AMERICAN_EXPRESS\n- DINERS_CLUB\n- DISCOVER\n- JCB\n\n:param input_string: String to check.\n:type input_string: str\n:param card_type: Card type. Default to None (any card).\n:type card_type: str\n\n:return: True if credit card, false otherwise.",
        "Arguments": "input_string, card_type",
        "Defaults": [
            "None"
        ],
        "Code": "def is_credit_card(input_string: Any, card_type: str = None) -> bool:\n    \"\"\"\n    Checks if a string is a valid credit card number.\n    If card type is provided then it checks against that specific type only,\n    otherwise any known credit card number will be accepted.\n\n    Supported card types are the following:\n\n    - VISA\n    - MASTERCARD\n    - AMERICAN_EXPRESS\n    - DINERS_CLUB\n    - DISCOVER\n    - JCB\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param card_type: Card type. Default to None (any card).\n    :type card_type: str\n\n    :return: True if credit card, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    if card_type:\n        if card_type not in CREDIT_CARDS:\n            raise KeyError(\n                'Invalid card type \"{}\". Valid types are: {}'.format(card_type, ', '.join(CREDIT_CARDS.keys()))\n            )\n        return CREDIT_CARDS[card_type].match(input_string) is not None\n\n    for c in CREDIT_CARDS:\n        if CREDIT_CARDS[c].match(input_string) is not None:\n            return True\n\n    return False",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 12,
        "Query": "This function is used to convert an object into a string representation. While not strictly necessary for the primary functionality of `is_string`, it could be used for logging or debugging purposes to show the string value of `obj` when it's not a string.",
        "Function Name": "__init__",
        "Docstring": "No docstring provided",
        "Arguments": "self, input_string",
        "Defaults": [],
        "Code": "    def __init__(self, input_string):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 12,
        "Query": "This imaginary function could be used to log the result of the type check, helping with debugging. It could log whether the input was a string or not, enhancing the traceability.",
        "Function Name": "__init__",
        "Docstring": "No docstring provided",
        "Arguments": "self, input_string",
        "Defaults": [],
        "Code": "    def __init__(self, input_string):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 12,
        "Query": "This function could be used within the function (or in a surrounding context) to assert that the type check is functioning as expected, though this is more commonly used in test cases rather than directly in the function.",
        "Function Name": "is_json",
        "Docstring": "Check if a string is a valid json.\n\n*Examples:*\n\n>>> is_json('{\"name\": \"Peter\"}') # returns true\n>>> is_json('[1, 2, 3]') # returns true\n>>> is_json('{nope}') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if json, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_json(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid json.\n\n    *Examples:*\n\n    >>> is_json('{\"name\": \"Peter\"}') # returns true\n    >>> is_json('[1, 2, 3]') # returns true\n    >>> is_json('{nope}') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if json, false otherwise\n    \"\"\"\n    if is_full_string(input_string) and JSON_WRAPPER_RE.match(input_string) is not None:\n        try:\n            return isinstance(json.loads(input_string), (dict, list))\n        except (TypeError, ValueError, OverflowError):\n            pass\n\n    return False",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 12,
        "Query": "This slightly modified call to `isinstance` could be used to check if `obj` is either a string or a bytes object, allowing for more nuanced type handling or error messages.",
        "Function Name": "__init__",
        "Docstring": "No docstring provided",
        "Arguments": "self, input_string",
        "Defaults": [],
        "Code": "    def __init__(self, input_string):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 12,
        "Query": "This function is used to get the official string representation of an object. This could be helpful for debugging messages or for returning an informative message about the type of the object if extended error handling were needed.\n\nThese functions may provide additional functionality, logging, debugging, or error handling to assist with the core purpose of the `is_string` function.",
        "Function Name": "__init__",
        "Docstring": "No docstring provided",
        "Arguments": "self, input_string",
        "Defaults": [],
        "Code": "    def __init__(self, input_string):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 13,
        "Query": "This function is used to check if `input_string` is of a specific type, ensuring that it is a valid string before performing further checks.",
        "Function Name": "__init__",
        "Docstring": "No docstring provided",
        "Arguments": "self, input_string",
        "Defaults": [],
        "Code": "    def __init__(self, input_string):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 13,
        "Query": "This function is used to remove any leading and trailing whitespace characters from the string, which helps to determine if the string contains any non-space characters.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 13,
        "Query": "This function is used to determine the length of the string, which can assist in checking if the string is empty or not.",
        "Function Name": "__require_valid_input_and_encoding",
        "Docstring": "No docstring provided",
        "Arguments": "input_string, encoding",
        "Defaults": [],
        "Code": "    def __require_valid_input_and_encoding(input_string: str, encoding: str):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        if len(input_string) == 0:\n            raise ValueError('Input string cannot be empty')\n\n        if not is_string(encoding):\n            raise ValueError('Invalid encoding')",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 13,
        "Query": "This function may be used to explicitly evaluate the truthiness of the final result, ensuring that the function consistently returns a boolean value (`True` or `False`).",
        "Function Name": "booleanize",
        "Docstring": "Turns a string into a boolean based on its content (CASE INSENSITIVE).\n\nA positive boolean (True) is returned if the string value is one of the following:\n\n- \"true\"\n- \"1\"\n- \"yes\"\n- \"y\"\n\nOtherwise False is returned.\n\n*Examples:*\n\n>>> booleanize('true') # returns True\n>>> booleanize('YES') # returns True\n>>> booleanize('nope') # returns False\n\n:param input_string: String to convert\n:type input_string: str\n:return: True if the string contains a boolean-like positive value, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def booleanize(input_string: str) -> bool:\n    \"\"\"\n    Turns a string into a boolean based on its content (CASE INSENSITIVE).\n\n    A positive boolean (True) is returned if the string value is one of the following:\n\n    - \"true\"\n    - \"1\"\n    - \"yes\"\n    - \"y\"\n\n    Otherwise False is returned.\n\n    *Examples:*\n\n    >>> booleanize('true') # returns True\n    >>> booleanize('YES') # returns True\n    >>> booleanize('nope') # returns False\n\n    :param input_string: String to convert\n    :type input_string: str\n    :return: True if the string contains a boolean-like positive value, false otherwise\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return input_string.lower() in ('true', '1', 'yes', 'y')",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 13,
        "Query": "This function could be employed if checking for at least one non-space character across a collection of strings or multiple conditions regarding the input.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 13,
        "Query": "This function may be used to explicitly convert `input_string` to a string type, ensuring that the function handles inputs that are not strings gracefully.",
        "Function Name": "__init__",
        "Docstring": "No docstring provided",
        "Arguments": "self, input_string",
        "Defaults": [],
        "Code": "    def __init__(self, input_string):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 13,
        "Query": "This method may be used to determine if the entire string consists solely of whitespace characters, providing a more straightforward check for strings that meet this condition.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 14,
        "Query": "This function is used to check if the entire input string matches the regex pattern for valid number representations, ensuring that no extraneous characters exist in the input.",
        "Function Name": "is_integer",
        "Docstring": "Checks whether the given string represents an integer or not.\n\nAn integer may be signed or unsigned or use a \"scientific notation\".\n\n*Examples:*\n\n>>> is_integer('42') # returns true\n>>> is_integer('42.0') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' not in input_string",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 14,
        "Query": "This function may be used to remove any non-numeric characters (like thousands separators or currency symbols) that could interfere with number validation before further checks.",
        "Function Name": "is_decimal",
        "Docstring": "Checks whether the given string represents a decimal or not.\n\nA decimal may be signed or unsigned or use a \"scientific notation\".\n\n>>> is_decimal('42.0') # returns true\n>>> is_decimal('42') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' in input_string",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 14,
        "Query": "This function can be used to quickly check if the input string represents a whole number (unsigned integer) before converting to a float, as it provides a fast boolean check for digit-only strings.",
        "Function Name": "is_integer",
        "Docstring": "Checks whether the given string represents an integer or not.\n\nAn integer may be signed or unsigned or use a \"scientific notation\".\n\n*Examples:*\n\n>>> is_integer('42') # returns true\n>>> is_integer('42.0') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' not in input_string",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 14,
        "Query": "This function can be used to determine the presence of characters like '+' or '-' to help differentiate between signed and unsigned numbers during validation.",
        "Function Name": "is_decimal",
        "Docstring": "Checks whether the given string represents a decimal or not.\n\nA decimal may be signed or unsigned or use a \"scientific notation\".\n\n>>> is_decimal('42.0') # returns true\n>>> is_decimal('42') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' in input_string",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 14,
        "Query": "This function may be employed to ascertain if the cleaned string is empty after stripping whitespace.",
        "Function Name": "__remove_internal_spaces",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __remove_internal_spaces(self, regex_match):\n        return regex_match.group(1).strip()",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 14,
        "Query": "This function can be utilized to check for the number of decimal points in the string, as a valid number should only have one decimal point.",
        "Function Name": "is_decimal",
        "Docstring": "Checks whether the given string represents a decimal or not.\n\nA decimal may be signed or unsigned or use a \"scientific notation\".\n\n>>> is_decimal('42.0') # returns true\n>>> is_decimal('42') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' in input_string",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 14,
        "Query": "This function might be needed to check for occurrences of spaces or delimiters that can indicate invalid number formats.",
        "Function Name": "is_decimal",
        "Docstring": "Checks whether the given string represents a decimal or not.\n\nA decimal may be signed or unsigned or use a \"scientific notation\".\n\n>>> is_decimal('42.0') # returns true\n>>> is_decimal('42') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' in input_string",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 14,
        "Query": "This function is used to attempt converting valid number strings into a float, leveraging the implicit validation that occurs during the conversion process to handle valid floats and integers.",
        "Function Name": "is_integer",
        "Docstring": "Checks whether the given string represents an integer or not.\n\nAn integer may be signed or unsigned or use a \"scientific notation\".\n\n*Examples:*\n\n>>> is_integer('42') # returns true\n>>> is_integer('42.0') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' not in input_string",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 15,
        "Query": "This function is used to replace unwanted characters (like spaces or invalid characters) in the `input_string` before validation to ensure that the subsequent checks are performed on a clean string.",
        "Function Name": "__remove_internal_spaces",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __remove_internal_spaces(self, regex_match):\n        return regex_match.group(1).strip()",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 15,
        "Query": "This function may be used to check whether the content of the string contains only alphanumeric characters, which can help in determining if the string is a valid representation of an integer without special symbols or whitespace.",
        "Function Name": "is_slug",
        "Docstring": "Checks if a given string is a slug (as created by `slugify()`).\n\n*Examples:*\n\n>>> is_slug('my-blog-post-title') # returns true\n>>> is_slug('My blog post title') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:param separator: Join sign used by the slug.\n:type separator: str\n:return: True if slug, false otherwise.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'-'"
        ],
        "Code": "def is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    rex = r'^([a-z\\d]+' + re.escape(separator) + r'*?)*[a-z\\d]$'\n\n    return re.match(rex, input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 15,
        "Query": "This function is used to remove any possible decimal points or unwanted characters before performing a check to see if the string can be interpreted as an integer.",
        "Function Name": "is_decimal",
        "Docstring": "Checks whether the given string represents a decimal or not.\n\nA decimal may be signed or unsigned or use a \"scientific notation\".\n\n>>> is_decimal('42.0') # returns true\n>>> is_decimal('42') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' in input_string",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 15,
        "Query": "This function might be used to check the number of decimal points or exponent characters ('e' or 'E') in the string to validate against the rules of integer representation (ensuring that there is at most one sign and no decimals).",
        "Function Name": "is_decimal",
        "Docstring": "Checks whether the given string represents a decimal or not.\n\nA decimal may be signed or unsigned or use a \"scientific notation\".\n\n>>> is_decimal('42.0') # returns true\n>>> is_decimal('42') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' in input_string",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 15,
        "Query": "This function could be used to locate the position of the decimal point or any exponent in the string, which aids in parsing to confirm it follows integer rules.",
        "Function Name": "is_decimal",
        "Docstring": "Checks whether the given string represents a decimal or not.\n\nA decimal may be signed or unsigned or use a \"scientific notation\".\n\n>>> is_decimal('42.0') # returns true\n>>> is_decimal('42') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' in input_string",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 15,
        "Query": "This function might be used in conjunction with a lambda function to filter out non-digit characters after handling signs, simplifying the check for valid digits.",
        "Function Name": "is_number",
        "Docstring": "Checks if a string is a valid number.\n\nThe number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\nor use the \"scientific notation\" (eg: 1e5).\n\n*Examples:*\n\n>>> is_number('42') # returns true\n>>> is_number('19.99') # returns true\n>>> is_number('-9.12') # returns true\n>>> is_number('1e3') # returns true\n>>> is_number('1 2 3') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if the string represents a number, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_number(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid number.\n\n    The number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\n    or use the \"scientific notation\" (eg: 1e5).\n\n    *Examples:*\n\n    >>> is_number('42') # returns true\n    >>> is_number('19.99') # returns true\n    >>> is_number('-9.12') # returns true\n    >>> is_number('1e3') # returns true\n    >>> is_number('1 2 3') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if the string represents a number, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n\n    return NUMBER_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 15,
        "Query": "This function could be used to assess whether any of the characters in the string invalidate its status as an integer (for example, checking for non-numeric characters).",
        "Function Name": "__require_valid_input_and_encoding",
        "Docstring": "No docstring provided",
        "Arguments": "input_string, encoding",
        "Defaults": [],
        "Code": "    def __require_valid_input_and_encoding(input_string: str, encoding: str):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        if len(input_string) == 0:\n            raise ValueError('Input string cannot be empty')\n\n        if not is_string(encoding):\n            raise ValueError('Invalid encoding')",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 15,
        "Query": "This function can be utilized to ensure that all characters of the processed string meet the criteria of being valid digits after any cleaning or filtering of the input string.",
        "Function Name": "is_email",
        "Docstring": "Check if a string is a valid email.\n\nReference: https://tools.ietf.org/html/rfc3696#section-3\n\n*Examples:*\n\n>>> is_email('my.email@the-provider.com') # returns true\n>>> is_email('@gmail.com') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if email, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    # first simple \"pre check\": it must be a non empty string with max len 320 and cannot start with a dot\n    if not is_full_string(input_string) or len(input_string) > 320 or input_string.startswith('.'):\n        return False\n\n    try:\n        # we expect 2 tokens, one before \"@\" and one after, otherwise we have an exception and the email is not valid\n        head, tail = input_string.split('@')\n\n        # head's size must be <= 64, tail <= 255, head must not start with a dot or contain multiple consecutive dots\n        if len(head) > 64 or len(tail) > 255 or head.endswith('.') or ('..' in head):\n            return False\n\n        # removes escaped spaces, so that later on the test regex will accept the string\n        head = head.replace('\\\\ ', '')\n        if head.startswith('\"') and head.endswith('\"'):\n            head = head.replace(' ', '')[1:-1]\n\n        return EMAIL_RE.match(head + '@' + tail) is not None\n\n    except ValueError:\n        # borderline case in which we have multiple \"@\" signs but the head part is correctly escaped\n        if ESCAPED_AT_SIGN.search(input_string) is not None:\n            # replace \"@\" with \"a\" in the head\n            return is_email(ESCAPED_AT_SIGN.sub('a', input_string))\n\n        return False",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 15,
        "Query": "Beyond initial checks, this function might also be used after filtering the string to ensure that it contains valid digits to confirm there's at least one digit present.\n\nThese functions would help facilitate the validation of the `input_string` as a valid integer representation under various conditions outlined for the `is_integer` function.",
        "Function Name": "is_number",
        "Docstring": "Checks if a string is a valid number.\n\nThe number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\nor use the \"scientific notation\" (eg: 1e5).\n\n*Examples:*\n\n>>> is_number('42') # returns true\n>>> is_number('19.99') # returns true\n>>> is_number('-9.12') # returns true\n>>> is_number('1e3') # returns true\n>>> is_number('1 2 3') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if the string represents a number, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_number(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid number.\n\n    The number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\n    or use the \"scientific notation\" (eg: 1e5).\n\n    *Examples:*\n\n    >>> is_number('42') # returns true\n    >>> is_number('19.99') # returns true\n    >>> is_number('-9.12') # returns true\n    >>> is_number('1e3') # returns true\n    >>> is_number('1 2 3') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if the string represents a number, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n\n    return NUMBER_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 16,
        "Query": "This function is used to check if the entire input string matches a defined regular expression pattern for a decimal number, ensuring no extraneous characters are present outside the expected format.",
        "Function Name": "is_integer",
        "Docstring": "Checks whether the given string represents an integer or not.\n\nAn integer may be signed or unsigned or use a \"scientific notation\".\n\n*Examples:*\n\n>>> is_integer('42') # returns true\n>>> is_integer('42.0') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' not in input_string",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 16,
        "Query": "This function is used to remove any leading or trailing whitespace from the input string before checking if it represents a decimal number, which helps avoid false negatives due to additional spaces.",
        "Function Name": "is_integer",
        "Docstring": "Checks whether the given string represents an integer or not.\n\nAn integer may be signed or unsigned or use a \"scientific notation\".\n\n*Examples:*\n\n>>> is_integer('42') # returns true\n>>> is_integer('42.0') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' not in input_string",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 16,
        "Query": "This function is used to attempt converting the input string to a float. If the conversion succeeds, it confirms that the string can be interpreted as a decimal number; if it raises a ValueError, it indicates the string is invalid.",
        "Function Name": "is_integer",
        "Docstring": "Checks whether the given string represents an integer or not.\n\nAn integer may be signed or unsigned or use a \"scientific notation\".\n\n*Examples:*\n\n>>> is_integer('42') # returns true\n>>> is_integer('42.0') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' not in input_string",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 16,
        "Query": "Although not directly used for decimal checking, this function could be called to check if the string only contains numbers, which could be part of pre-validation before concluding the input does not represent a decimal.",
        "Function Name": "is_integer",
        "Docstring": "Checks whether the given string represents an integer or not.\n\nAn integer may be signed or unsigned or use a \"scientific notation\".\n\n*Examples:*\n\n>>> is_integer('42') # returns true\n>>> is_integer('42.0') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' not in input_string",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 16,
        "Query": "This function may be used if there are considerations for handling scientific notation with case insensitivity (e.g., converting 'E' to 'e' before further processing) to ensure consistent detection.",
        "Function Name": "is_camel_case",
        "Docstring": "Checks if a string is formatted as camel case.\n\nA string is considered camel case when:\n\n- it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n- it contains both lowercase and uppercase letters\n- it does not start with a number\n\n*Examples:*\n\n>>> is_camel_case('MyString') # returns true\n>>> is_camel_case('mystring') # returns false\n\n:param input_string: String to test.\n:type input_string: str\n:return: True for a camel case string, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_camel_case(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and CAMEL_CASE_TEST_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 16,
        "Query": "This function could be used to check for the presence of a decimal point or an exponent character in the input string to help quickly determine if further checks for decimal representation are necessary.",
        "Function Name": "is_integer",
        "Docstring": "Checks whether the given string represents an integer or not.\n\nAn integer may be signed or unsigned or use a \"scientific notation\".\n\n*Examples:*\n\n>>> is_integer('42') # returns true\n>>> is_integer('42.0') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' not in input_string",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 16,
        "Query": "Recognizing this built-in exception when using `float` conversion can help the function to clearly handle invalid inputs gracefully rather than crashing.",
        "Function Name": "is_number",
        "Docstring": "Checks if a string is a valid number.\n\nThe number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\nor use the \"scientific notation\" (eg: 1e5).\n\n*Examples:*\n\n>>> is_number('42') # returns true\n>>> is_number('19.99') # returns true\n>>> is_number('-9.12') # returns true\n>>> is_number('1e3') # returns true\n>>> is_number('1 2 3') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if the string represents a number, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_number(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid number.\n\n    The number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\n    or use the \"scientific notation\" (eg: 1e5).\n\n    *Examples:*\n\n    >>> is_number('42') # returns true\n    >>> is_number('19.99') # returns true\n    >>> is_number('-9.12') # returns true\n    >>> is_number('1e3') # returns true\n    >>> is_number('1 2 3') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if the string represents a number, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n\n    return NUMBER_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 17,
        "Query": "This function is used to parse the `input_string` into its components (scheme, netloc, path, etc.) to validate the structure of the URL.",
        "Function Name": "is_ip_v6",
        "Docstring": "Checks if a string is a valid ip v6.\n\n*Examples:*\n\n>>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n>>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if a v6 ip, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and IP_V6_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 17,
        "Query": "This function might be used to reconstruct the URL from its parsed components if a canonical form of the URL is needed for further validation or output.",
        "Function Name": "is_isbn_10",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n\n                return product % 11 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 17,
        "Query": "This function could be utilized as an alternative to `urlparse`, specifically focusing on splitting the URL into its components while ignoring the query and fragment parts, which might simplify certain validations.",
        "Function Name": "is_ip_v4",
        "Docstring": "Checks if a string is a valid ip v4.\n\n*Examples:*\n\n>>> is_ip_v4('255.200.100.75') # returns true\n>>> is_ip_v4('nope') # returns false (not an ip)\n>>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if an ip v4, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string) or SHALLOW_IP_V4_RE.match(input_string) is None:\n        return False\n\n    # checks that each entry in the ip is in the valid range (0 to 255)\n    for token in input_string.split('.'):\n        if not (0 <= int(token) <= 255):\n            return False\n\n    return True",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 17,
        "Query": "This function (not standard, but could be implemented) would check if the scheme of the URL is a valid scheme, potentially encapsulating the logic for checking against `allowed_schemes`.",
        "Function Name": "is_uuid",
        "Docstring": "Check if a string is a valid UUID.\n\n*Example:*\n\n>>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n:param input_string: String to check.\n:type input_string: str\n:param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n:type allow_hex: bool\n:return: True if UUID, false otherwise",
        "Arguments": "input_string, allow_hex",
        "Defaults": [
            "False"
        ],
        "Code": "def is_uuid(input_string: Any, allow_hex: bool = False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    # string casting is used to allow UUID itself as input data type\n    s = str(input_string)\n\n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n\n    return UUID_RE.match(s) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 17,
        "Query": "This function (also potentially custom) would specifically verify that a valid network location (netloc) is present in the parsed URL, ensuring the overall URL integrity.",
        "Function Name": "is_ip_v6",
        "Docstring": "Checks if a string is a valid ip v6.\n\n*Examples:*\n\n>>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n>>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if a v6 ip, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and IP_V6_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 17,
        "Query": "This method might be called to eliminate any leading or trailing whitespace from the `input_string` before further processing.",
        "Function Name": "__remove_internal_spaces",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __remove_internal_spaces(self, regex_match):\n        return regex_match.group(1).strip()",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 17,
        "Query": "This function from the `re` module could be used to apply a regex pattern to the `input_string` to validate the overall format of the URL before parsing.",
        "Function Name": "is_ip_v6",
        "Docstring": "Checks if a string is a valid ip v6.\n\n*Examples:*\n\n>>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n>>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if a v6 ip, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and IP_V6_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 17,
        "Query": "This built-in function might be used to check the length of `allowed_schemes` when verifying if there are any allowed schemes provided.",
        "Function Name": "is_email",
        "Docstring": "Check if a string is a valid email.\n\nReference: https://tools.ietf.org/html/rfc3696#section-3\n\n*Examples:*\n\n>>> is_email('my.email@the-provider.com') # returns true\n>>> is_email('@gmail.com') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if email, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    # first simple \"pre check\": it must be a non empty string with max len 320 and cannot start with a dot\n    if not is_full_string(input_string) or len(input_string) > 320 or input_string.startswith('.'):\n        return False\n\n    try:\n        # we expect 2 tokens, one before \"@\" and one after, otherwise we have an exception and the email is not valid\n        head, tail = input_string.split('@')\n\n        # head's size must be <= 64, tail <= 255, head must not start with a dot or contain multiple consecutive dots\n        if len(head) > 64 or len(tail) > 255 or head.endswith('.') or ('..' in head):\n            return False\n\n        # removes escaped spaces, so that later on the test regex will accept the string\n        head = head.replace('\\\\ ', '')\n        if head.startswith('\"') and head.endswith('\"'):\n            head = head.replace(' ', '')[1:-1]\n\n        return EMAIL_RE.match(head + '@' + tail) is not None\n\n    except ValueError:\n        # borderline case in which we have multiple \"@\" signs but the head part is correctly escaped\n        if ESCAPED_AT_SIGN.search(input_string) is not None:\n            # replace \"@\" with \"a\" in the head\n            return is_email(ESCAPED_AT_SIGN.sub('a', input_string))\n\n        return False",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 17,
        "Query": "This built-in function could be used to evaluate if any scheme from `allowed_schemes` matches the parsed scheme of the URL, which can simplify the condition checks.",
        "Function Name": "is_uuid",
        "Docstring": "Check if a string is a valid UUID.\n\n*Example:*\n\n>>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n:param input_string: String to check.\n:type input_string: str\n:param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n:type allow_hex: bool\n:return: True if UUID, false otherwise",
        "Arguments": "input_string, allow_hex",
        "Defaults": [
            "False"
        ],
        "Code": "def is_uuid(input_string: Any, allow_hex: bool = False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    # string casting is used to allow UUID itself as input data type\n    s = str(input_string)\n\n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n\n    return UUID_RE.match(s) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 17,
        "Query": "This built-in function might be used to convert the result of any operations or checks back to a string format when preparing output or during comparisons. \n\nThese additional functions and methods can help enhance the validity and robustness of the `is_url` function.",
        "Function Name": "compress",
        "Docstring": "No docstring provided",
        "Arguments": "cls, input_string, encoding, compression_level",
        "Defaults": [
            "'utf-8'",
            "9"
        ],
        "Code": "    def compress(cls, input_string: str, encoding: str = 'utf-8', compression_level: int = 9) -> str:\n        cls.__require_valid_input_and_encoding(input_string, encoding)\n\n        if not isinstance(compression_level, int) or compression_level < 0 or compression_level > 9:\n            raise ValueError('Invalid compression_level: it must be an \"int\" between 0 and 9')\n\n        # turns input string into a sequence of bytes using provided encoding\n        original_bytes = input_string.encode(encoding)\n\n        # compress bytes using zlib library\n        compressed_bytes = zlib.compress(original_bytes, compression_level)\n\n        # encode compressed bytes using base64\n        # (this ensure that all characters will be available and that the output string can be used safely in any\n        # context such URLs)\n        encoded_bytes = base64.urlsafe_b64encode(compressed_bytes)\n\n        # finally turns base64 bytes into a string\n        output = encoded_bytes.decode(encoding)\n\n        return output",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 18,
        "Query": "This function is used to remove any leading or trailing whitespace from the input string before performing email validation, ensuring that extraneous spaces do not affect the validity check.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 18,
        "Query": "This function is used to convert the input string to lowercase to standardize the email address, as email comparisons are typically case-insensitive.",
        "Function Name": "is_camel_case",
        "Docstring": "Checks if a string is formatted as camel case.\n\nA string is considered camel case when:\n\n- it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n- it contains both lowercase and uppercase letters\n- it does not start with a number\n\n*Examples:*\n\n>>> is_camel_case('MyString') # returns true\n>>> is_camel_case('mystring') # returns false\n\n:param input_string: String to test.\n:type input_string: str\n:return: True for a camel case string, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_camel_case(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and CAMEL_CASE_TEST_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 18,
        "Query": "This function from the `re` module may be used to search for specific patterns within the email string, such as validating that there are no consecutive special characters (like \"..\") in the local part or domain.",
        "Function Name": "is_slug",
        "Docstring": "Checks if a given string is a slug (as created by `slugify()`).\n\n*Examples:*\n\n>>> is_slug('my-blog-post-title') # returns true\n>>> is_slug('My blog post title') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:param separator: Join sign used by the slug.\n:type separator: str\n:return: True if slug, false otherwise.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'-'"
        ],
        "Code": "def is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    rex = r'^([a-z\\d]+' + re.escape(separator) + r'*?)*[a-z\\d]$'\n\n    return re.match(rex, input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 18,
        "Query": "This function from the `re` module could be used to clean or format the email string before validation, by removing any unwanted characters that are not allowed in valid email addresses.",
        "Function Name": "format",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def format(self) -> str:\n        # map of temporary placeholders\n        placeholders = {}\n        out = self.input_string\n\n        # looks for url or email and updates placeholders map with found values\n        placeholders.update({self.__placeholder_key(): m[0] for m in URLS_RE.findall(out)})\n        placeholders.update({self.__placeholder_key(): m for m in EMAILS_RE.findall(out)})\n\n        # replace original value with the placeholder key\n        for p in placeholders:\n            out = out.replace(placeholders[p], p, 1)\n\n        out = PRETTIFY_RE['UPPERCASE_FIRST_LETTER'].sub(self.__uppercase_first_char, out)\n        out = PRETTIFY_RE['DUPLICATES'].sub(self.__remove_duplicates, out)\n        out = PRETTIFY_RE['RIGHT_SPACE'].sub(self.__ensure_right_space_only, out)\n        out = PRETTIFY_RE['LEFT_SPACE'].sub(self.__ensure_left_space_only, out)\n        out = PRETTIFY_RE['SPACES_AROUND'].sub(self.__ensure_spaces_around, out)\n        out = PRETTIFY_RE['SPACES_INSIDE'].sub(self.__remove_internal_spaces, out)\n        out = PRETTIFY_RE['UPPERCASE_AFTER_SIGN'].sub(self.__uppercase_first_letter_after_sign, out)\n        out = PRETTIFY_RE['SAXON_GENITIVE'].sub(self.__fix_saxon_genitive, out)\n        out = out.strip()\n\n        # restore placeholder keys with their associated original value\n        for p in placeholders:\n            out = out.replace(p, placeholders[p], 1)\n\n        return out",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 18,
        "Query": "This function could be used to ensure that the \"@\" symbol exists and to obtain its index position for further validation of the local part and domain part.",
        "Function Name": "is_ip_v4",
        "Docstring": "Checks if a string is a valid ip v4.\n\n*Examples:*\n\n>>> is_ip_v4('255.200.100.75') # returns true\n>>> is_ip_v4('nope') # returns false (not an ip)\n>>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if an ip v4, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string) or SHALLOW_IP_V4_RE.match(input_string) is None:\n        return False\n\n    # checks that each entry in the ip is in the valid range (0 to 255)\n    for token in input_string.split('.'):\n        if not (0 <= int(token) <= 255):\n            return False\n\n    return True",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 18,
        "Query": "This hypothetical function (not a standard string method but conceptually implied) could be used to check if certain required characters (like \".\") are present in the respective parts of the email, complementing the use of `str.count`.",
        "Function Name": "words_count",
        "Docstring": "Returns the number of words contained into the given string.\n\nThis method is smart, it does consider only sequence of one or more letter and/or numbers\nas \"words\", so a string like this: \"! @ # % ... []\" will return zero!\nMoreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\nwill be 4 not 1 (even if there are no spaces in the string).\n\n*Examples:*\n\n>>> words_count('hello world') # returns 2\n>>> words_count('one,two,three.stop') # returns 4\n\n:param input_string: String to check.\n:type input_string: str\n:return: Number of words.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def words_count(input_string: str) -> int:\n    \"\"\"\n    Returns the number of words contained into the given string.\n\n    This method is smart, it does consider only sequence of one or more letter and/or numbers\n    as \"words\", so a string like this: \"! @ # % ... []\" will return zero!\n    Moreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\n    will be 4 not 1 (even if there are no spaces in the string).\n\n    *Examples:*\n\n    >>> words_count('hello world') # returns 2\n    >>> words_count('one,two,three.stop') # returns 4\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: Number of words.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return len(WORDS_COUNT_RE.findall(input_string))",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 18,
        "Query": "This function might be used to check if the domain part of the email ends with a valid top-level domain (TLD), ensuring that the email address conforms to known TLD patterns.",
        "Function Name": "is_url",
        "Docstring": "Check if a string is a valid url.\n\n*Examples:*\n\n>>> is_url('http://www.mysite.com') # returns true\n>>> is_url('https://mysite.com') # returns true\n>>> is_url('.mysite.com') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n:type allowed_schemes: Optional[List[str]]\n:return: True if url, false otherwise",
        "Arguments": "input_string, allowed_schemes",
        "Defaults": [
            "None"
        ],
        "Code": "def is_url(input_string: Any, allowed_schemes: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    valid = URL_RE.match(input_string) is not None\n\n    if allowed_schemes:\n        return valid and any([input_string.startswith(s) for s in allowed_schemes])\n\n    return valid",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 18,
        "Query": "This function could be used to ensure that the local part doesn\u2019t start with a special character, providing an additional layer of validation for proper email formatting.",
        "Function Name": "is_snake_case",
        "Docstring": "Checks if a string is formatted as \"snake case\".\n\nA string is considered snake case when:\n\n- it's composed only by lowercase/uppercase letters and digits\n- it contains at least one underscore (or provided separator)\n- it does not start with a number\n\n*Examples:*\n\n>>> is_snake_case('foo_bar_baz') # returns true\n>>> is_snake_case('foo') # returns false\n\n:param input_string: String to test.\n:type input_string: str\n:param separator: String to use as separator.\n:type separator: str\n:return: True for a snake case string, false otherwise.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'_'"
        ],
        "Code": "def is_snake_case(input_string: Any, separator: str = '_') -> bool:\n    \"\"\"\n    Checks if a string is formatted as \"snake case\".\n\n    A string is considered snake case when:\n\n    - it's composed only by lowercase/uppercase letters and digits\n    - it contains at least one underscore (or provided separator)\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_snake_case('foo_bar_baz') # returns true\n    >>> is_snake_case('foo') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :param separator: String to use as separator.\n    :type separator: str\n    :return: True for a snake case string, false otherwise.\n    \"\"\"\n    if is_full_string(input_string):\n        re_map = {\n            '_': SNAKE_CASE_TEST_RE,\n            '-': SNAKE_CASE_TEST_DASH_RE\n        }\n        re_template = r'([a-z]+\\d*{sign}[a-z\\d{sign}]*|{sign}+[a-z\\d]+[a-z\\d{sign}]*)'\n        r = re_map.get(\n            separator,\n            re.compile(re_template.format(sign=re.escape(separator)), re.IGNORECASE)\n        )\n\n        return r.match(input_string) is not None\n\n    return False",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 18,
        "Query": "This built-in function can be used to determine if any characters in the email string match a specific condition (like checking for invalid characters) across the local and domain parts.",
        "Function Name": "is_isbn_10",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n\n                return product % 11 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 18,
        "Query": "This built-in function can be used to ensure that all parts of the email address (such as each character in local and domain part) adhere to certain validity criteria, thus providing a comprehensive check for valid formatting.",
        "Function Name": "is_isbn",
        "Docstring": "Checks if the given string represents a valid ISBN (International Standard Book Number).\nBy default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\nfunction with `normalize=False` only digit-only strings will pass the validation.\n\n*Examples:*\n\n>>> is_isbn('9780312498580') # returns true\n>>> is_isbn('1506715214') # returns true\n\n:param input_string: String to check.\n:param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n:return: True if valid ISBN (10 or 13), false otherwise.",
        "Arguments": "input_string, normalize",
        "Defaults": [
            "True"
        ],
        "Code": "def is_isbn(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn('9780312498580') # returns true\n    >>> is_isbn('1506715214') # returns true\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN (10 or 13), false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_13() or checker.is_isbn_10()",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 19,
        "Query": "This function is used to verify that the length of the credit card number conforms to the expected standard for different card types (e.g., VISA typically has 16 digits, while AMERICAN_EXPRESS typically has 15 digits).",
        "Function Name": "is_uuid",
        "Docstring": "Check if a string is a valid UUID.\n\n*Example:*\n\n>>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n:param input_string: String to check.\n:type input_string: str\n:param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n:type allow_hex: bool\n:return: True if UUID, false otherwise",
        "Arguments": "input_string, allow_hex",
        "Defaults": [
            "False"
        ],
        "Code": "def is_uuid(input_string: Any, allow_hex: bool = False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    # string casting is used to allow UUID itself as input data type\n    s = str(input_string)\n\n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n\n    return UUID_RE.match(s) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 19,
        "Query": "This function is used to ensure that the credit card number starts with the appropriate digits for the specified card type (e.g., VISA starts with '4', MASTERCARD starts with '51', '52', '53', '54', or '55').",
        "Function Name": "is_decimal",
        "Docstring": "Checks whether the given string represents a decimal or not.\n\nA decimal may be signed or unsigned or use a \"scientific notation\".\n\n>>> is_decimal('42.0') # returns true\n>>> is_decimal('42') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' in input_string",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 19,
        "Query": "This function is used to confirm that the `input_string` contains only numeric characters, thereby ensuring that it doesn't contain any letters or special characters.",
        "Function Name": "words_count",
        "Docstring": "Returns the number of words contained into the given string.\n\nThis method is smart, it does consider only sequence of one or more letter and/or numbers\nas \"words\", so a string like this: \"! @ # % ... []\" will return zero!\nMoreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\nwill be 4 not 1 (even if there are no spaces in the string).\n\n*Examples:*\n\n>>> words_count('hello world') # returns 2\n>>> words_count('one,two,three.stop') # returns 4\n\n:param input_string: String to check.\n:type input_string: str\n:return: Number of words.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def words_count(input_string: str) -> int:\n    \"\"\"\n    Returns the number of words contained into the given string.\n\n    This method is smart, it does consider only sequence of one or more letter and/or numbers\n    as \"words\", so a string like this: \"! @ # % ... []\" will return zero!\n    Moreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\n    will be 4 not 1 (even if there are no spaces in the string).\n\n    *Examples:*\n\n    >>> words_count('hello world') # returns 2\n    >>> words_count('one,two,three.stop') # returns 4\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: Number of words.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return len(WORDS_COUNT_RE.findall(input_string))",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 19,
        "Query": "This function is used to normalize the credit card number (for example, removing spaces or hyphens) before performing further validation checks.",
        "Function Name": "is_isbn",
        "Docstring": "Checks if the given string represents a valid ISBN (International Standard Book Number).\nBy default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\nfunction with `normalize=False` only digit-only strings will pass the validation.\n\n*Examples:*\n\n>>> is_isbn('9780312498580') # returns true\n>>> is_isbn('1506715214') # returns true\n\n:param input_string: String to check.\n:param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n:return: True if valid ISBN (10 or 13), false otherwise.",
        "Arguments": "input_string, normalize",
        "Defaults": [
            "True"
        ],
        "Code": "def is_isbn(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn('9780312498580') # returns true\n    >>> is_isbn('1506715214') # returns true\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN (10 or 13), false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_13() or checker.is_isbn_10()",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 19,
        "Query": "This function is used to implement the Luhn checksum algorithm to verify that the credit card number passes this checksum criteria, ensuring the number is valid based on its digits.",
        "Function Name": "is_isbn_13",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_13(self) -> bool:\n        if len(self.input_string) == 13:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    weight = 1 if (index % 2 == 0) else 3\n                    product += int(digit) * weight\n\n                return product % 10 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 19,
        "Query": "This function is used to automatically determine the card type of the `input_string` based on its prefix and length if the `card_type` parameter is not provided.",
        "Function Name": "__init__",
        "Docstring": "No docstring provided",
        "Arguments": "self, input_string",
        "Defaults": [],
        "Code": "    def __init__(self, input_string):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 19,
        "Query": "This function is used to check the `input_string` against regular expression patterns designed to validate the general structure of different credit card types in more detail.",
        "Function Name": "is_json",
        "Docstring": "Check if a string is a valid json.\n\n*Examples:*\n\n>>> is_json('{\"name\": \"Peter\"}') # returns true\n>>> is_json('[1, 2, 3]') # returns true\n>>> is_json('{nope}') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if json, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_json(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid json.\n\n    *Examples:*\n\n    >>> is_json('{\"name\": \"Peter\"}') # returns true\n    >>> is_json('[1, 2, 3]') # returns true\n    >>> is_json('{nope}') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if json, false otherwise\n    \"\"\"\n    if is_full_string(input_string) and JSON_WRAPPER_RE.match(input_string) is not None:\n        try:\n            return isinstance(json.loads(input_string), (dict, list))\n        except (TypeError, ValueError, OverflowError):\n            pass\n\n    return False",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 19,
        "Query": "This function is used to perform preliminary validations on the input string (e.g., checking for null or empty values) before proceeding with the credit card checks.",
        "Function Name": "__require_valid_input_and_encoding",
        "Docstring": "No docstring provided",
        "Arguments": "input_string, encoding",
        "Defaults": [],
        "Code": "    def __require_valid_input_and_encoding(input_string: str, encoding: str):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        if len(input_string) == 0:\n            raise ValueError('Input string cannot be empty')\n\n        if not is_string(encoding):\n            raise ValueError('Invalid encoding')",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 19,
        "Query": "This function is used to log or record the result of the credit card validation process for auditing or debugging purposes, allowing for better tracking of validation attempts and results.",
        "Function Name": "is_uuid",
        "Docstring": "Check if a string is a valid UUID.\n\n*Example:*\n\n>>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n:param input_string: String to check.\n:type input_string: str\n:param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n:type allow_hex: bool\n:return: True if UUID, false otherwise",
        "Arguments": "input_string, allow_hex",
        "Defaults": [
            "False"
        ],
        "Code": "def is_uuid(input_string: Any, allow_hex: bool = False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    # string casting is used to allow UUID itself as input data type\n    s = str(input_string)\n\n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n\n    return UUID_RE.match(s) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 20,
        "Query": "This function is used to check if the input string is empty, returning `True` if it is and `False` otherwise.",
        "Function Name": "is_full_string",
        "Docstring": "Check if a string is not empty (it must contains at least one non space character).\n\n*Examples:*\n\n>>> is_full_string(None) # returns false\n>>> is_full_string('') # returns false\n>>> is_full_string(' ') # returns false\n>>> is_full_string('hello') # returns true\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if not empty, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_full_string(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is not empty (it must contains at least one non space character).\n\n    *Examples:*\n\n    >>> is_full_string(None) # returns false\n    >>> is_full_string('') # returns false\n    >>> is_full_string(' ') # returns false\n    >>> is_full_string('hello') # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if not empty, false otherwise.\n    \"\"\"\n    return is_string(input_string) and input_string.strip() != ''",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 20,
        "Query": "This function is used to determine if the first character of the string is a letter, ensuring that it does not start with a number.",
        "Function Name": "is_pangram",
        "Docstring": "Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n*Examples:*\n\n>>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n>>> is_pangram('hello world') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if the string is a pangram, False otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_pangram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n    *Examples:*\n\n    >>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n    >>> is_pangram('hello world') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if the string is a pangram, False otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    return set(SPACES_RE.sub('', input_string)).issuperset(set(string.ascii_lowercase))",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 20,
        "Query": "This function is used to check if each individual character in the string is a digit, helping to ensure that the string is composed solely of letters and optionally numbers.",
        "Function Name": "random_string",
        "Docstring": "Returns a string of the specified size containing random characters (uppercase/lowercase ascii letters and digits).\n\n*Example:*\n\n>>> random_string(9) # possible output: \"cx3QQbzYg\"\n\n:param size: Desired string size\n:type size: int\n:return: Random string",
        "Arguments": "size",
        "Defaults": [],
        "Code": "def random_string(size: int) -> str:\n    \"\"\"\n    Returns a string of the specified size containing random characters (uppercase/lowercase ascii letters and digits).\n\n    *Example:*\n\n    >>> random_string(9) # possible output: \"cx3QQbzYg\"\n\n    :param size: Desired string size\n    :type size: int\n    :return: Random string\n    \"\"\"\n    if not isinstance(size, int) or size < 1:\n        raise ValueError('size must be >= 1')\n\n    chars = string.ascii_letters + string.digits\n    buffer = [random.choice(chars) for _ in range(size)]\n    out = ''.join(buffer)\n\n    return out",
        "Class": null,
        "File": "input/string_utils/generation.py"
    },
    {
        "_id": 20,
        "Query": "This function is used to check if any character in the string is a lowercase letter, helping to determine if at least one lowercase letter is present.",
        "Function Name": "is_pangram",
        "Docstring": "Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n*Examples:*\n\n>>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n>>> is_pangram('hello world') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if the string is a pangram, False otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_pangram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n    *Examples:*\n\n    >>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n    >>> is_pangram('hello world') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if the string is a pangram, False otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    return set(SPACES_RE.sub('', input_string)).issuperset(set(string.ascii_lowercase))",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 20,
        "Query": "This function is used to check if any character in the string is an uppercase letter, helping to determine if at least one uppercase letter is present.",
        "Function Name": "__uppercase_first_char",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __uppercase_first_char(self, regex_match):\n        return regex_match.group(0).upper()",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 20,
        "Query": "This function could be used to determine if a character is either a letter or a digit, aiding the composition check of the string.",
        "Function Name": "random_string",
        "Docstring": "Returns a string of the specified size containing random characters (uppercase/lowercase ascii letters and digits).\n\n*Example:*\n\n>>> random_string(9) # possible output: \"cx3QQbzYg\"\n\n:param size: Desired string size\n:type size: int\n:return: Random string",
        "Arguments": "size",
        "Defaults": [],
        "Code": "def random_string(size: int) -> str:\n    \"\"\"\n    Returns a string of the specified size containing random characters (uppercase/lowercase ascii letters and digits).\n\n    *Example:*\n\n    >>> random_string(9) # possible output: \"cx3QQbzYg\"\n\n    :param size: Desired string size\n    :type size: int\n    :return: Random string\n    \"\"\"\n    if not isinstance(size, int) or size < 1:\n        raise ValueError('size must be >= 1')\n\n    chars = string.ascii_letters + string.digits\n    buffer = [random.choice(chars) for _ in range(size)]\n    out = ''.join(buffer)\n\n    return out",
        "Class": null,
        "File": "input/string_utils/generation.py"
    },
    {
        "_id": 20,
        "Query": "This function may determine if a string contains both lowercase and uppercase letters, simplifying the evaluation of whether the string is camel case.",
        "Function Name": "snake_case_to_camel",
        "Docstring": "Convert a snake case string into a camel case one.\n(The original string is returned if is not a valid snake case string)\n\n*Example:*\n\n>>> snake_case_to_camel('the_snake_is_green') # returns 'TheSnakeIsGreen'\n\n:param input_string: String to convert.\n:type input_string: str\n:param upper_case_first: True to turn the first letter into uppercase (default).\n:type upper_case_first: bool\n:param separator: Sign to use as separator (default to \"_\").\n:type separator: str\n:return: Converted string",
        "Arguments": "input_string, upper_case_first, separator",
        "Defaults": [
            "True",
            "'_'"
        ],
        "Code": "def snake_case_to_camel(input_string: str, upper_case_first: bool = True, separator: str = '_') -> str:\n    \"\"\"\n    Convert a snake case string into a camel case one.\n    (The original string is returned if is not a valid snake case string)\n\n    *Example:*\n\n    >>> snake_case_to_camel('the_snake_is_green') # returns 'TheSnakeIsGreen'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param upper_case_first: True to turn the first letter into uppercase (default).\n    :type upper_case_first: bool\n    :param separator: Sign to use as separator (default to \"_\").\n    :type separator: str\n    :return: Converted string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_snake_case(input_string, separator):\n        return input_string\n\n    tokens = [s.title() for s in input_string.split(separator) if is_full_string(s)]\n\n    if not upper_case_first:\n        tokens[0] = tokens[0].lower()\n\n    out = ''.join(tokens)\n\n    return out",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 20,
        "Query": "This function could specifically assess whether the first character of the string is valid (i.e., a letter) and could be used before other checks to streamline the process.\n\nThese functions would help modularize the logic of the `is_camel_case` function and enhance code readability and maintainability.",
        "Function Name": "camel_case_to_snake",
        "Docstring": "Convert a camel case string into a snake case one.\n(The original string is returned if is not a valid camel case string)\n\n*Example:*\n\n>>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign to use as separator.\n:type separator: str\n:return: Converted string.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'_'"
        ],
        "Code": "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_camel_case(input_string):\n        return input_string\n\n    return CAMEL_CASE_REPLACE_RE.sub(lambda m: m.group(1) + separator, input_string).lower()",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 21,
        "Query": "This function is used to remove any leading or trailing whitespace from `input_string` before performing checks, ensuring that unnecessary spaces do not affect the validation of the snake case format.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 21,
        "Query": "This function is used to confirm that every character in the `input_string` conforms to the allowed character set (lowercase letters, uppercase letters, digits, and the `separator`), providing a more efficient way to validate character composition across the entire string.",
        "Function Name": "random_string",
        "Docstring": "Returns a string of the specified size containing random characters (uppercase/lowercase ascii letters and digits).\n\n*Example:*\n\n>>> random_string(9) # possible output: \"cx3QQbzYg\"\n\n:param size: Desired string size\n:type size: int\n:return: Random string",
        "Arguments": "size",
        "Defaults": [],
        "Code": "def random_string(size: int) -> str:\n    \"\"\"\n    Returns a string of the specified size containing random characters (uppercase/lowercase ascii letters and digits).\n\n    *Example:*\n\n    >>> random_string(9) # possible output: \"cx3QQbzYg\"\n\n    :param size: Desired string size\n    :type size: int\n    :return: Random string\n    \"\"\"\n    if not isinstance(size, int) or size < 1:\n        raise ValueError('size must be >= 1')\n\n    chars = string.ascii_letters + string.digits\n    buffer = [random.choice(chars) for _ in range(size)]\n    out = ''.join(buffer)\n\n    return out",
        "Class": null,
        "File": "input/string_utils/generation.py"
    },
    {
        "_id": 21,
        "Query": "This function is used to check if there are any numeric characters in the `input_string`, which would violate the rule that the string cannot start with a number, allowing for succinct validation logic.",
        "Function Name": "is_number",
        "Docstring": "Checks if a string is a valid number.\n\nThe number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\nor use the \"scientific notation\" (eg: 1e5).\n\n*Examples:*\n\n>>> is_number('42') # returns true\n>>> is_number('19.99') # returns true\n>>> is_number('-9.12') # returns true\n>>> is_number('1e3') # returns true\n>>> is_number('1 2 3') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if the string represents a number, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_number(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid number.\n\n    The number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\n    or use the \"scientific notation\" (eg: 1e5).\n\n    *Examples:*\n\n    >>> is_number('42') # returns true\n    >>> is_number('19.99') # returns true\n    >>> is_number('-9.12') # returns true\n    >>> is_number('1e3') # returns true\n    >>> is_number('1 2 3') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if the string represents a number, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n\n    return NUMBER_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 21,
        "Query": "This function is used to locate the position of the first occurrence of the specified `separator` in the string, which helps to confirm that the separator is present and assists in further validations if needed.",
        "Function Name": "is_slug",
        "Docstring": "Checks if a given string is a slug (as created by `slugify()`).\n\n*Examples:*\n\n>>> is_slug('my-blog-post-title') # returns true\n>>> is_slug('My blog post title') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:param separator: Join sign used by the slug.\n:type separator: str\n:return: True if slug, false otherwise.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'-'"
        ],
        "Code": "def is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    rex = r'^([a-z\\d]+' + re.escape(separator) + r'*?)*[a-z\\d]$'\n\n    return re.match(rex, input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 21,
        "Query": "These functions can be used to check if there are any uppercase and lowercase letters respectively in the `input_string`, ensuring that the format adheres strictly to snake case standards.",
        "Function Name": "is_camel_case",
        "Docstring": "Checks if a string is formatted as camel case.\n\nA string is considered camel case when:\n\n- it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n- it contains both lowercase and uppercase letters\n- it does not start with a number\n\n*Examples:*\n\n>>> is_camel_case('MyString') # returns true\n>>> is_camel_case('mystring') # returns false\n\n:param input_string: String to test.\n:type input_string: str\n:return: True for a camel case string, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_camel_case(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and CAMEL_CASE_TEST_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 21,
        "Query": "This function may be used to reconstruct or normalize the input as needed if any sanitization or modification of the string is required, such as replacing invalid characters with valid ones.",
        "Function Name": "__init__",
        "Docstring": "No docstring provided",
        "Arguments": "self, input_string",
        "Defaults": [],
        "Code": "    def __init__(self, input_string):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 21,
        "Query": "This function from the `re` module can be used to validate the entire string against a regular expression pattern that defines valid snake case structure more robustly.",
        "Function Name": "is_url",
        "Docstring": "Check if a string is a valid url.\n\n*Examples:*\n\n>>> is_url('http://www.mysite.com') # returns true\n>>> is_url('https://mysite.com') # returns true\n>>> is_url('.mysite.com') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n:type allowed_schemes: Optional[List[str]]\n:return: True if url, false otherwise",
        "Arguments": "input_string, allowed_schemes",
        "Defaults": [
            "None"
        ],
        "Code": "def is_url(input_string: Any, allowed_schemes: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    valid = URL_RE.match(input_string) is not None\n\n    if allowed_schemes:\n        return valid and any([input_string.startswith(s) for s in allowed_schemes])\n\n    return valid",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 21,
        "Query": "Checking the length of `input_string` to ensure it is greater than zero, confirming that an empty string does not qualify as snake case.",
        "Function Name": "__init__",
        "Docstring": "No docstring provided",
        "Arguments": "self, input_string",
        "Defaults": [],
        "Code": "    def __init__(self, input_string):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 21,
        "Query": "This function could be utilized if the `separator` needs to be normalized (e.g., replacing all instances of one separator type with another) as part of the validation process.",
        "Function Name": "slugify",
        "Docstring": "Converts a string into a \"slug\" using provided separator.\nThe returned string has the following properties:\n\n- it has no spaces\n- all letters are in lower case\n- all punctuation signs and non alphanumeric chars are removed\n- words are divided using provided separator\n- all chars are encoded as ascii (by using `asciify()`)\n- is safe for URL\n\n*Examples:*\n\n>>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n>>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign used to join string tokens (default to \"-\").\n:type separator: str\n:return: Slug string",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'-'"
        ],
        "Code": "def slugify(input_string: str, separator: str = '-') -> str:\n    \"\"\"\n    Converts a string into a \"slug\" using provided separator.\n    The returned string has the following properties:\n\n    - it has no spaces\n    - all letters are in lower case\n    - all punctuation signs and non alphanumeric chars are removed\n    - words are divided using provided separator\n    - all chars are encoded as ascii (by using `asciify()`)\n    - is safe for URL\n\n    *Examples:*\n\n    >>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n    >>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign used to join string tokens (default to \"-\").\n    :type separator: str\n    :return: Slug string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    # replace any character that is NOT letter or number with spaces\n    out = NO_LETTERS_OR_NUMBERS_RE.sub(' ', input_string.lower()).strip()\n\n    # replace spaces with join sign\n    out = SPACES_RE.sub(separator, out)\n\n    # normalize joins (remove duplicates)\n    out = re.sub(re.escape(separator) + r'+', separator, out)\n\n    return asciify(out)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 21,
        "Query": "These functions can be used to convert characters and verify that the string uses the correct casing consistent with snake case, ensuring compliance with the expected output of the validation logic.",
        "Function Name": "camel_case_to_snake",
        "Docstring": "Convert a camel case string into a snake case one.\n(The original string is returned if is not a valid camel case string)\n\n*Example:*\n\n>>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign to use as separator.\n:type separator: str\n:return: Converted string.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'_'"
        ],
        "Code": "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_camel_case(input_string):\n        return input_string\n\n    return CAMEL_CASE_REPLACE_RE.sub(lambda m: m.group(1) + separator, input_string).lower()",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 21,
        "Query": "This function could be used to determine the position of the first separator in the string, assisting in complex validations related to the snake case format.\n\nEach of these functions helps to reinforce the validation logic by ensuring the `input_string` conforms to the rules of being a valid snake case string.",
        "Function Name": "snake_case_to_camel",
        "Docstring": "Convert a snake case string into a camel case one.\n(The original string is returned if is not a valid snake case string)\n\n*Example:*\n\n>>> snake_case_to_camel('the_snake_is_green') # returns 'TheSnakeIsGreen'\n\n:param input_string: String to convert.\n:type input_string: str\n:param upper_case_first: True to turn the first letter into uppercase (default).\n:type upper_case_first: bool\n:param separator: Sign to use as separator (default to \"_\").\n:type separator: str\n:return: Converted string",
        "Arguments": "input_string, upper_case_first, separator",
        "Defaults": [
            "True",
            "'_'"
        ],
        "Code": "def snake_case_to_camel(input_string: str, upper_case_first: bool = True, separator: str = '_') -> str:\n    \"\"\"\n    Convert a snake case string into a camel case one.\n    (The original string is returned if is not a valid snake case string)\n\n    *Example:*\n\n    >>> snake_case_to_camel('the_snake_is_green') # returns 'TheSnakeIsGreen'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param upper_case_first: True to turn the first letter into uppercase (default).\n    :type upper_case_first: bool\n    :param separator: Sign to use as separator (default to \"_\").\n    :type separator: str\n    :return: Converted string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_snake_case(input_string, separator):\n        return input_string\n\n    tokens = [s.title() for s in input_string.split(separator) if is_full_string(s)]\n\n    if not upper_case_first:\n        tokens[0] = tokens[0].lower()\n\n    out = ''.join(tokens)\n\n    return out",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 22,
        "Query": "This function is used to parse a JSON-encoded string into a Python object. It is critical for checking if the `input_string` is valid JSON and will raise a `JSONDecodeError` if the string is not in a proper format.",
        "Function Name": "__require_valid_input_and_encoding",
        "Docstring": "No docstring provided",
        "Arguments": "input_string, encoding",
        "Defaults": [],
        "Code": "    def __require_valid_input_and_encoding(input_string: str, encoding: str):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        if len(input_string) == 0:\n            raise ValueError('Input string cannot be empty')\n\n        if not is_string(encoding):\n            raise ValueError('Invalid encoding')",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 22,
        "Query": "While this is not a function to be called, it's worth mentioning that it is an exception class that `json.loads` raises if the parsing fails. The target function will use this exception to differentiate valid and invalid JSON strings within the `except` block.",
        "Function Name": "__init__",
        "Docstring": "No docstring provided",
        "Arguments": "self, input_string",
        "Defaults": [],
        "Code": "    def __init__(self, input_string):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 22,
        "Query": "This function is used to remove any leading or trailing whitespace from the `input_string`. It could be beneficial to call this function before attempting to parse the string to ensure that whitespace does not cause a valid JSON structure to fail.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 22,
        "Query": "If debugging or logging capabilities are added, this function can be used to log error messages when the input string is not valid JSON. This function helps in tracking issues with the input and is useful for debugging.",
        "Function Name": "__init__",
        "Docstring": "No docstring provided",
        "Arguments": "self, input_string",
        "Defaults": [],
        "Code": "    def __init__(self, input_string):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 22,
        "Query": "This function could be used to check if `input_string` is of type `str` before trying to parse it. Adding this check ensures that the validation process is only attempted on string inputs, potentially avoiding unnecessary exceptions.",
        "Function Name": "__init__",
        "Docstring": "No docstring provided",
        "Arguments": "self, input_string",
        "Defaults": [],
        "Code": "    def __init__(self, input_string):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 22,
        "Query": "This function can be called to determine the type of `input_string`. If additional type handling or validation is implemented, it could be used to validate the input type before proceeding with parsing.\n\nThese functions would enhance robustness and provide useful checks in the `is_json` function's implementation.",
        "Function Name": "__require_valid_input_and_encoding",
        "Docstring": "No docstring provided",
        "Arguments": "input_string, encoding",
        "Defaults": [],
        "Code": "    def __require_valid_input_and_encoding(input_string: str, encoding: str):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        if len(input_string) == 0:\n            raise ValueError('Input string cannot be empty')\n\n        if not is_string(encoding):\n            raise ValueError('Invalid encoding')",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 23,
        "Query": "This function is used to compile a regular expression pattern for UUID format validation, which can enhance performance by allowing the pattern to be reused multiple times during matching.",
        "Function Name": "__remove_duplicates",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __remove_duplicates(self, regex_match):\n        return regex_match.group(1)[0]",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 23,
        "Query": "This function is used to check if a substring (in case the UUID has been split for validation) consists only of numeric digits, ensuring that the string adheres to hexadecimal standards.",
        "Function Name": "uuid",
        "Docstring": "Generated an UUID string (using `uuid.uuid4()`).\n\n*Examples:*\n\n>>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n>>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n:param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n:return: uuid string.",
        "Arguments": "as_hex",
        "Defaults": [
            "False"
        ],
        "Code": "def uuid(as_hex: bool = False) -> str:\n    \"\"\"\n    Generated an UUID string (using `uuid.uuid4()`).\n\n    *Examples:*\n\n    >>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n    >>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n    :param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n    :return: uuid string.\n    \"\"\"\n    uid = uuid4()\n\n    if as_hex:\n        return uid.hex\n\n    return str(uid)",
        "Class": null,
        "File": "input/string_utils/generation.py"
    },
    {
        "_id": 23,
        "Query": "This function is used to convert the input string to lowercase before validating its hexadecimal representation, as hexadecimal digits are case-insensitive.",
        "Function Name": "is_camel_case",
        "Docstring": "Checks if a string is formatted as camel case.\n\nA string is considered camel case when:\n\n- it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n- it contains both lowercase and uppercase letters\n- it does not start with a number\n\n*Examples:*\n\n>>> is_camel_case('MyString') # returns true\n>>> is_camel_case('mystring') # returns false\n\n:param input_string: String to test.\n:type input_string: str\n:return: True for a camel case string, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_camel_case(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and CAMEL_CASE_TEST_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 23,
        "Query": "This function could be used to manipulate the string, such as replacing non-hexadecimal or unwanted characters, if needed prior to validation for the hex format.",
        "Function Name": "format",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def format(self) -> str:\n        # map of temporary placeholders\n        placeholders = {}\n        out = self.input_string\n\n        # looks for url or email and updates placeholders map with found values\n        placeholders.update({self.__placeholder_key(): m[0] for m in URLS_RE.findall(out)})\n        placeholders.update({self.__placeholder_key(): m for m in EMAILS_RE.findall(out)})\n\n        # replace original value with the placeholder key\n        for p in placeholders:\n            out = out.replace(placeholders[p], p, 1)\n\n        out = PRETTIFY_RE['UPPERCASE_FIRST_LETTER'].sub(self.__uppercase_first_char, out)\n        out = PRETTIFY_RE['DUPLICATES'].sub(self.__remove_duplicates, out)\n        out = PRETTIFY_RE['RIGHT_SPACE'].sub(self.__ensure_right_space_only, out)\n        out = PRETTIFY_RE['LEFT_SPACE'].sub(self.__ensure_left_space_only, out)\n        out = PRETTIFY_RE['SPACES_AROUND'].sub(self.__ensure_spaces_around, out)\n        out = PRETTIFY_RE['SPACES_INSIDE'].sub(self.__remove_internal_spaces, out)\n        out = PRETTIFY_RE['UPPERCASE_AFTER_SIGN'].sub(self.__uppercase_first_letter_after_sign, out)\n        out = PRETTIFY_RE['SAXON_GENITIVE'].sub(self.__fix_saxon_genitive, out)\n        out = out.strip()\n\n        # restore placeholder keys with their associated original value\n        for p in placeholders:\n            out = out.replace(p, placeholders[p], 1)\n\n        return out",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 23,
        "Query": "This function could be used to check if any portion of the string contains invalid characters during the hex representation validation.",
        "Function Name": "__require_valid_input_and_encoding",
        "Docstring": "No docstring provided",
        "Arguments": "input_string, encoding",
        "Defaults": [],
        "Code": "    def __require_valid_input_and_encoding(input_string: str, encoding: str):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        if len(input_string) == 0:\n            raise ValueError('Input string cannot be empty')\n\n        if not is_string(encoding):\n            raise ValueError('Invalid encoding')",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 23,
        "Query": "This function could be used to leverage Python's built-in UUID class for validation, as it can raise exceptions for invalid UUID formats that can be caught and managed.",
        "Function Name": "uuid",
        "Docstring": "Generated an UUID string (using `uuid.uuid4()`).\n\n*Examples:*\n\n>>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n>>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n:param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n:return: uuid string.",
        "Arguments": "as_hex",
        "Defaults": [
            "False"
        ],
        "Code": "def uuid(as_hex: bool = False) -> str:\n    \"\"\"\n    Generated an UUID string (using `uuid.uuid4()`).\n\n    *Examples:*\n\n    >>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n    >>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n    :param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n    :return: uuid string.\n    \"\"\"\n    uid = uuid4()\n\n    if as_hex:\n        return uid.hex\n\n    return str(uid)",
        "Class": null,
        "File": "input/string_utils/generation.py"
    },
    {
        "_id": 23,
        "Query": "This function is used to verify the length of input strings against predefined values, ensuring compliance with standards for UUIDs and hex representations.",
        "Function Name": "uuid",
        "Docstring": "Generated an UUID string (using `uuid.uuid4()`).\n\n*Examples:*\n\n>>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n>>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n:param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n:return: uuid string.",
        "Arguments": "as_hex",
        "Defaults": [
            "False"
        ],
        "Code": "def uuid(as_hex: bool = False) -> str:\n    \"\"\"\n    Generated an UUID string (using `uuid.uuid4()`).\n\n    *Examples:*\n\n    >>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n    >>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n    :param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n    :return: uuid string.\n    \"\"\"\n    uid = uuid4()\n\n    if as_hex:\n        return uid.hex\n\n    return str(uid)",
        "Class": null,
        "File": "input/string_utils/generation.py"
    },
    {
        "_id": 23,
        "Query": "This function could be used to remove any leading or trailing whitespace from the `input_string` before performing the UUID validity check, ensuring that extraneous spaces do not result in an invalid check.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 23,
        "Query": "This function is used to iterate through each character in the string to validate that every character in the hex representation is a valid hexadecimal digit.",
        "Function Name": "uuid",
        "Docstring": "Generated an UUID string (using `uuid.uuid4()`).\n\n*Examples:*\n\n>>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n>>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n:param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n:return: uuid string.",
        "Arguments": "as_hex",
        "Defaults": [
            "False"
        ],
        "Code": "def uuid(as_hex: bool = False) -> str:\n    \"\"\"\n    Generated an UUID string (using `uuid.uuid4()`).\n\n    *Examples:*\n\n    >>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n    >>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n    :param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n    :return: uuid string.\n    \"\"\"\n    uid = uuid4()\n\n    if as_hex:\n        return uid.hex\n\n    return str(uid)",
        "Class": null,
        "File": "input/string_utils/generation.py"
    },
    {
        "_id": 24,
        "Query": "This function is used to divide the input string into a list of segments using the period (.) as a delimiter.",
        "Function Name": "strip_margin",
        "Docstring": "Removes tab indentation from multi line strings (inspired by analogous Scala function).\n\n*Example:*\n\n>>> strip_margin('''\n>>>                 line 1\n>>>                 line 2\n>>>                 line 3\n>>> ''')\n>>> # returns:\n>>> '''\n>>> line 1\n>>> line 2\n>>> line 3\n>>> '''\n\n:param input_string: String to format\n:type input_string: str\n:return: A string without left margins",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def strip_margin(input_string: str) -> str:\n    \"\"\"\n    Removes tab indentation from multi line strings (inspired by analogous Scala function).\n\n    *Example:*\n\n    >>> strip_margin('''\n    >>>                 line 1\n    >>>                 line 2\n    >>>                 line 3\n    >>> ''')\n    >>> # returns:\n    >>> '''\n    >>> line 1\n    >>> line 2\n    >>> line 3\n    >>> '''\n\n    :param input_string: String to format\n    :type input_string: str\n    :return: A string without left margins\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    line_separator = '\\n'\n    lines = [MARGIN_RE.sub('', line) for line in input_string.split(line_separator)]\n    out = line_separator.join(lines)\n\n    return out",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 24,
        "Query": "This function is used to determine the number of segments in the list to ensure it equals four.",
        "Function Name": "secure_random_hex",
        "Docstring": "Generates a random string using secure low level random generator (os.urandom).\n\n**Bear in mind**: due to hex conversion, the returned string will have a size that is exactly    the double of the given `byte_count`.\n\n*Example:*\n\n>>> secure_random_hex(9) # possible output: 'aac4cf1d1d87bd5036'\n\n:param byte_count: Number of random bytes to generate\n:type byte_count: int\n:return: Hexadecimal string representation of generated random bytes",
        "Arguments": "byte_count",
        "Defaults": [],
        "Code": "def secure_random_hex(byte_count: int) -> str:\n    \"\"\"\n    Generates a random string using secure low level random generator (os.urandom).\n\n    **Bear in mind**: due to hex conversion, the returned string will have a size that is exactly\\\n    the double of the given `byte_count`.\n\n    *Example:*\n\n    >>> secure_random_hex(9) # possible output: 'aac4cf1d1d87bd5036'\n\n    :param byte_count: Number of random bytes to generate\n    :type byte_count: int\n    :return: Hexadecimal string representation of generated random bytes\n    \"\"\"\n    if not isinstance(byte_count, int) or byte_count < 1:\n        raise ValueError('byte_count must be >= 1')\n\n    random_bytes = os.urandom(byte_count)\n    hex_bytes = binascii.hexlify(random_bytes)\n    hex_string = hex_bytes.decode()\n\n    return hex_string",
        "Class": null,
        "File": "input/string_utils/generation.py"
    },
    {
        "_id": 24,
        "Query": "This function is used to verify that each segment consists only of digits, ensuring it is a numeric string.",
        "Function Name": "is_number",
        "Docstring": "Checks if a string is a valid number.\n\nThe number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\nor use the \"scientific notation\" (eg: 1e5).\n\n*Examples:*\n\n>>> is_number('42') # returns true\n>>> is_number('19.99') # returns true\n>>> is_number('-9.12') # returns true\n>>> is_number('1e3') # returns true\n>>> is_number('1 2 3') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if the string represents a number, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_number(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid number.\n\n    The number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\n    or use the \"scientific notation\" (eg: 1e5).\n\n    *Examples:*\n\n    >>> is_number('42') # returns true\n    >>> is_number('19.99') # returns true\n    >>> is_number('-9.12') # returns true\n    >>> is_number('1e3') # returns true\n    >>> is_number('1 2 3') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if the string represents a number, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n\n    return NUMBER_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 24,
        "Query": "This function is used to convert each valid numeric string segment into an integer for further range checking.",
        "Function Name": "is_number",
        "Docstring": "Checks if a string is a valid number.\n\nThe number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\nor use the \"scientific notation\" (eg: 1e5).\n\n*Examples:*\n\n>>> is_number('42') # returns true\n>>> is_number('19.99') # returns true\n>>> is_number('-9.12') # returns true\n>>> is_number('1e3') # returns true\n>>> is_number('1 2 3') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if the string represents a number, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_number(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid number.\n\n    The number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\n    or use the \"scientific notation\" (eg: 1e5).\n\n    *Examples:*\n\n    >>> is_number('42') # returns true\n    >>> is_number('19.99') # returns true\n    >>> is_number('-9.12') # returns true\n    >>> is_number('1e3') # returns true\n    >>> is_number('1 2 3') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if the string represents a number, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n\n    return NUMBER_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 24,
        "Query": "This function is used to define the valid range for each segment (0 to 255) to check if the integer values fall within this range.",
        "Function Name": "validate",
        "Docstring": "No docstring provided",
        "Arguments": "arg_value, arg_name, allow_negative",
        "Defaults": [
            "False"
        ],
        "Code": "    def validate(arg_value, arg_name, allow_negative=False):\n        msg = '\"{}\" must be an integer in the range 1-3999'.format(arg_name)\n\n        if not isinstance(arg_value, int):\n            raise ValueError(msg)\n\n        if allow_negative:\n            arg_value = abs(arg_value)\n\n        if arg_value < 1 or arg_value > 3999:\n            raise ValueError(msg)",
        "Class": null,
        "File": "input/string_utils/generation.py"
    },
    {
        "_id": 24,
        "Query": "This function may be used to remove any leading or trailing whitespace characters from the `input_string`, ensuring that the IP address is properly formatted before further validation.",
        "Function Name": "is_ip_v6",
        "Docstring": "Checks if a string is a valid ip v6.\n\n*Examples:*\n\n>>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n>>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if a v6 ip, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and IP_V6_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 24,
        "Query": "This function could be utilized to apply conversion from string segments to integers across the list of segments in a succinct way.",
        "Function Name": "roman_decode",
        "Docstring": "Decode a roman number string into an integer if the provided string is valid.\n\n*Example:*\n\n>>> roman_decode('VII') # returns 7\n\n:param input_string: (Assumed) Roman number\n:type input_string: str\n:return: Integer value",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def roman_decode(input_string: str) -> int:\n    \"\"\"\n    Decode a roman number string into an integer if the provided string is valid.\n\n    *Example:*\n\n    >>> roman_decode('VII') # returns 7\n\n    :param input_string: (Assumed) Roman number\n    :type input_string: str\n    :return: Integer value\n    \"\"\"\n    return __RomanNumbers.decode(input_string)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 24,
        "Query": "This function may be employed to check if all segments pass the validation criteria (numeric check and range check), returning a boolean result in a more readable manner.",
        "Function Name": "is_number",
        "Docstring": "Checks if a string is a valid number.\n\nThe number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\nor use the \"scientific notation\" (eg: 1e5).\n\n*Examples:*\n\n>>> is_number('42') # returns true\n>>> is_number('19.99') # returns true\n>>> is_number('-9.12') # returns true\n>>> is_number('1e3') # returns true\n>>> is_number('1 2 3') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if the string represents a number, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_number(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid number.\n\n    The number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\n    or use the \"scientific notation\" (eg: 1e5).\n\n    *Examples:*\n\n    >>> is_number('42') # returns true\n    >>> is_number('19.99') # returns true\n    >>> is_number('-9.12') # returns true\n    >>> is_number('1e3') # returns true\n    >>> is_number('1 2 3') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if the string represents a number, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n\n    return NUMBER_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 24,
        "Query": "This function could be used to determine if any of the segments fail the validation checks, this might help to succinctly establish if the function should return `False`.",
        "Function Name": "is_email",
        "Docstring": "Check if a string is a valid email.\n\nReference: https://tools.ietf.org/html/rfc3696#section-3\n\n*Examples:*\n\n>>> is_email('my.email@the-provider.com') # returns true\n>>> is_email('@gmail.com') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if email, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    # first simple \"pre check\": it must be a non empty string with max len 320 and cannot start with a dot\n    if not is_full_string(input_string) or len(input_string) > 320 or input_string.startswith('.'):\n        return False\n\n    try:\n        # we expect 2 tokens, one before \"@\" and one after, otherwise we have an exception and the email is not valid\n        head, tail = input_string.split('@')\n\n        # head's size must be <= 64, tail <= 255, head must not start with a dot or contain multiple consecutive dots\n        if len(head) > 64 or len(tail) > 255 or head.endswith('.') or ('..' in head):\n            return False\n\n        # removes escaped spaces, so that later on the test regex will accept the string\n        head = head.replace('\\\\ ', '')\n        if head.startswith('\"') and head.endswith('\"'):\n            head = head.replace(' ', '')[1:-1]\n\n        return EMAIL_RE.match(head + '@' + tail) is not None\n\n    except ValueError:\n        # borderline case in which we have multiple \"@\" signs but the head part is correctly escaped\n        if ESCAPED_AT_SIGN.search(input_string) is not None:\n            # replace \"@\" with \"a\" in the head\n            return is_email(ESCAPED_AT_SIGN.sub('a', input_string))\n\n        return False",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 24,
        "Query": "This function may be used to ensure that any input passed as other types can be converted to string format before proceeding with validations, facilitating input flexibility.",
        "Function Name": "is_isbn",
        "Docstring": "Checks if the given string represents a valid ISBN (International Standard Book Number).\nBy default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\nfunction with `normalize=False` only digit-only strings will pass the validation.\n\n*Examples:*\n\n>>> is_isbn('9780312498580') # returns true\n>>> is_isbn('1506715214') # returns true\n\n:param input_string: String to check.\n:param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n:return: True if valid ISBN (10 or 13), false otherwise.",
        "Arguments": "input_string, normalize",
        "Defaults": [
            "True"
        ],
        "Code": "def is_isbn(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn('9780312498580') # returns true\n    >>> is_isbn('1506715214') # returns true\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN (10 or 13), false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_13() or checker.is_isbn_10()",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 25,
        "Query": "This function is used to divide the input string into segments using the colon (`:`) delimiter, allowing for the individual evaluation of each portion of the IPv6 address.",
        "Function Name": "is_ip_v4",
        "Docstring": "Checks if a string is a valid ip v4.\n\n*Examples:*\n\n>>> is_ip_v4('255.200.100.75') # returns true\n>>> is_ip_v4('nope') # returns false (not an ip)\n>>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if an ip v4, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string) or SHALLOW_IP_V4_RE.match(input_string) is None:\n        return False\n\n    # checks that each entry in the ip is in the valid range (0 to 255)\n    for token in input_string.split('.'):\n        if not (0 <= int(token) <= 255):\n            return False\n\n    return True",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 25,
        "Query": "This function is used to determine the number of segments produced after splitting the string, ensuring that there are exactly eight segments for a valid IPv6 address.",
        "Function Name": "is_ip_v4",
        "Docstring": "Checks if a string is a valid ip v4.\n\n*Examples:*\n\n>>> is_ip_v4('255.200.100.75') # returns true\n>>> is_ip_v4('nope') # returns false (not an ip)\n>>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if an ip v4, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string) or SHALLOW_IP_V4_RE.match(input_string) is None:\n        return False\n\n    # checks that each entry in the ip is in the valid range (0 to 255)\n    for token in input_string.split('.'):\n        if not (0 <= int(token) <= 255):\n            return False\n\n    return True",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 25,
        "Query": "This function may be used to efficiently check that all segments meet the validation criteria (i.e., being valid hexadecimal characters and having the correct length) in a single expression.",
        "Function Name": "is_ip_v4",
        "Docstring": "Checks if a string is a valid ip v4.\n\n*Examples:*\n\n>>> is_ip_v4('255.200.100.75') # returns true\n>>> is_ip_v4('nope') # returns false (not an ip)\n>>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if an ip v4, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string) or SHALLOW_IP_V4_RE.match(input_string) is None:\n        return False\n\n    # checks that each entry in the ip is in the valid range (0 to 255)\n    for token in input_string.split('.'):\n        if not (0 <= int(token) <= 255):\n            return False\n\n    return True",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 25,
        "Query": "This function is used to check if characters in each segment are alphanumeric, which aids in validating whether segments contain valid hexadecimal characters.",
        "Function Name": "is_uuid",
        "Docstring": "Check if a string is a valid UUID.\n\n*Example:*\n\n>>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n:param input_string: String to check.\n:type input_string: str\n:param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n:type allow_hex: bool\n:return: True if UUID, false otherwise",
        "Arguments": "input_string, allow_hex",
        "Defaults": [
            "False"
        ],
        "Code": "def is_uuid(input_string: Any, allow_hex: bool = False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    # string casting is used to allow UUID itself as input data type\n    s = str(input_string)\n\n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n\n    return UUID_RE.match(s) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 25,
        "Query": "This function may be used to determine if any segment contains invalid characters (e.g., non-hexadecimal characters), immediately allowing the function to return `False` if such characters are found.",
        "Function Name": "is_uuid",
        "Docstring": "Check if a string is a valid UUID.\n\n*Example:*\n\n>>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n:param input_string: String to check.\n:type input_string: str\n:param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n:type allow_hex: bool\n:return: True if UUID, false otherwise",
        "Arguments": "input_string, allow_hex",
        "Defaults": [
            "False"
        ],
        "Code": "def is_uuid(input_string: Any, allow_hex: bool = False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    # string casting is used to allow UUID itself as input data type\n    s = str(input_string)\n\n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n\n    return UUID_RE.match(s) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 25,
        "Query": "This function may be used to check if a segment consists solely of digits, which is part of the validation for hexadecimal characters.",
        "Function Name": "is_uuid",
        "Docstring": "Check if a string is a valid UUID.\n\n*Example:*\n\n>>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n:param input_string: String to check.\n:type input_string: str\n:param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n:type allow_hex: bool\n:return: True if UUID, false otherwise",
        "Arguments": "input_string, allow_hex",
        "Defaults": [
            "False"
        ],
        "Code": "def is_uuid(input_string: Any, allow_hex: bool = False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    # string casting is used to allow UUID itself as input data type\n    s = str(input_string)\n\n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n\n    return UUID_RE.match(s) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 25,
        "Query": "This function could be used to normalize the segment to lowercase, ensuring that case variations in hexadecimal characters (e.g., 'A' vs. 'a') do not affect valid checks.",
        "Function Name": "slugify",
        "Docstring": "Converts a string into a \"slug\" using provided separator.\nThe returned string has the following properties:\n\n- it has no spaces\n- all letters are in lower case\n- all punctuation signs and non alphanumeric chars are removed\n- words are divided using provided separator\n- all chars are encoded as ascii (by using `asciify()`)\n- is safe for URL\n\n*Examples:*\n\n>>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n>>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign used to join string tokens (default to \"-\").\n:type separator: str\n:return: Slug string",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'-'"
        ],
        "Code": "def slugify(input_string: str, separator: str = '-') -> str:\n    \"\"\"\n    Converts a string into a \"slug\" using provided separator.\n    The returned string has the following properties:\n\n    - it has no spaces\n    - all letters are in lower case\n    - all punctuation signs and non alphanumeric chars are removed\n    - words are divided using provided separator\n    - all chars are encoded as ascii (by using `asciify()`)\n    - is safe for URL\n\n    *Examples:*\n\n    >>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n    >>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign used to join string tokens (default to \"-\").\n    :type separator: str\n    :return: Slug string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    # replace any character that is NOT letter or number with spaces\n    out = NO_LETTERS_OR_NUMBERS_RE.sub(' ', input_string.lower()).strip()\n\n    # replace spaces with join sign\n    out = SPACES_RE.sub(separator, out)\n\n    # normalize joins (remove duplicates)\n    out = re.sub(re.escape(separator) + r'+', separator, out)\n\n    return asciify(out)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 25,
        "Query": "This function may be used to remove any leading or trailing whitespace from the input string before processing it, ensuring that extra spaces do not interfere with validation.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 25,
        "Query": "This function could be used to utilize regular expressions for validating the entire string against a specific IPv6 pattern, simplifying the validation process by capturing both structural and character conditions in one go.",
        "Function Name": "is_url",
        "Docstring": "Check if a string is a valid url.\n\n*Examples:*\n\n>>> is_url('http://www.mysite.com') # returns true\n>>> is_url('https://mysite.com') # returns true\n>>> is_url('.mysite.com') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n:type allowed_schemes: Optional[List[str]]\n:return: True if url, false otherwise",
        "Arguments": "input_string, allowed_schemes",
        "Defaults": [
            "None"
        ],
        "Code": "def is_url(input_string: Any, allowed_schemes: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    valid = URL_RE.match(input_string) is not None\n\n    if allowed_schemes:\n        return valid and any([input_string.startswith(s) for s in allowed_schemes])\n\n    return valid",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 25,
        "Query": "These functions might be employed to check if certain segments start or end with valid characters when dealing with shorthand notation or related edge cases for IPv6.\n\nThese functions would work together in the `is_ip_v6` implementation to ensure thorough validation of a given input string as a valid IPv6 address.",
        "Function Name": "is_ip",
        "Docstring": "Checks if a string is a valid ip (either v4 or v6).\n\n*Examples:*\n\n>>> is_ip('255.200.100.75') # returns true\n>>> is_ip('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n>>> is_ip('1.2.3') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if an ip, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_ip(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip (either v4 or v6).\n\n    *Examples:*\n\n    >>> is_ip('255.200.100.75') # returns true\n    >>> is_ip('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip('1.2.3') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip, false otherwise.\n    \"\"\"\n    return is_ip_v6(input_string) or is_ip_v4(input_string)",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 26,
        "Query": "This function is used to compile the regular expressions for IPv4 and IPv6 patterns, allowing for improved performance when the same pattern is used multiple times within the `is_ip` function.",
        "Function Name": "is_ip_v4",
        "Docstring": "Checks if a string is a valid ip v4.\n\n*Examples:*\n\n>>> is_ip_v4('255.200.100.75') # returns true\n>>> is_ip_v4('nope') # returns false (not an ip)\n>>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if an ip v4, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string) or SHALLOW_IP_V4_RE.match(input_string) is None:\n        return False\n\n    # checks that each entry in the ip is in the valid range (0 to 255)\n    for token in input_string.split('.'):\n        if not (0 <= int(token) <= 255):\n            return False\n\n    return True",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 26,
        "Query": "This function is used to check if a segment of an IPv4 address is composed only of digits, ensuring that individual parts of the IP address can be validated against numeric constraints.",
        "Function Name": "is_ip_v4",
        "Docstring": "Checks if a string is a valid ip v4.\n\n*Examples:*\n\n>>> is_ip_v4('255.200.100.75') # returns true\n>>> is_ip_v4('nope') # returns false (not an ip)\n>>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if an ip v4, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string) or SHALLOW_IP_V4_RE.match(input_string) is None:\n        return False\n\n    # checks that each entry in the ip is in the valid range (0 to 255)\n    for token in input_string.split('.'):\n        if not (0 <= int(token) <= 255):\n            return False\n\n    return True",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 26,
        "Query": "This function is used to normalize an input string for IPv6 addresses, ensuring that hexadecimal letters are treated consistently (e.g., converting 'A' to 'a').",
        "Function Name": "is_uuid",
        "Docstring": "Check if a string is a valid UUID.\n\n*Example:*\n\n>>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n:param input_string: String to check.\n:type input_string: str\n:param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n:type allow_hex: bool\n:return: True if UUID, false otherwise",
        "Arguments": "input_string, allow_hex",
        "Defaults": [
            "False"
        ],
        "Code": "def is_uuid(input_string: Any, allow_hex: bool = False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    # string casting is used to allow UUID itself as input data type\n    s = str(input_string)\n\n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n\n    return UUID_RE.match(s) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 26,
        "Query": "This function might be utilized to compare the numeric value of segments of an IPv4 address against the maximum value of 255 to ensure they are within the valid range.",
        "Function Name": "is_ip_v4",
        "Docstring": "Checks if a string is a valid ip v4.\n\n*Examples:*\n\n>>> is_ip_v4('255.200.100.75') # returns true\n>>> is_ip_v4('nope') # returns false (not an ip)\n>>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if an ip v4, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string) or SHALLOW_IP_V4_RE.match(input_string) is None:\n        return False\n\n    # checks that each entry in the ip is in the valid range (0 to 255)\n    for token in input_string.split('.'):\n        if not (0 <= int(token) <= 255):\n            return False\n\n    return True",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 26,
        "Query": "This function is already mentioned, but it could be used again to verify that each segment of the IPv6 address follows the requirement of being in valid hexadecimal format (1 to 4 characters).",
        "Function Name": "is_ip_v6",
        "Docstring": "Checks if a string is a valid ip v6.\n\n*Examples:*\n\n>>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n>>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if a v6 ip, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and IP_V6_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 26,
        "Query": "This function might be used to check if any segment of a processed IP string fails to meet specific criteria, such as exceeding the maximum length or being an invalid number.",
        "Function Name": "is_email",
        "Docstring": "Check if a string is a valid email.\n\nReference: https://tools.ietf.org/html/rfc3696#section-3\n\n*Examples:*\n\n>>> is_email('my.email@the-provider.com') # returns true\n>>> is_email('@gmail.com') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if email, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    # first simple \"pre check\": it must be a non empty string with max len 320 and cannot start with a dot\n    if not is_full_string(input_string) or len(input_string) > 320 or input_string.startswith('.'):\n        return False\n\n    try:\n        # we expect 2 tokens, one before \"@\" and one after, otherwise we have an exception and the email is not valid\n        head, tail = input_string.split('@')\n\n        # head's size must be <= 64, tail <= 255, head must not start with a dot or contain multiple consecutive dots\n        if len(head) > 64 or len(tail) > 255 or head.endswith('.') or ('..' in head):\n            return False\n\n        # removes escaped spaces, so that later on the test regex will accept the string\n        head = head.replace('\\\\ ', '')\n        if head.startswith('\"') and head.endswith('\"'):\n            head = head.replace(' ', '')[1:-1]\n\n        return EMAIL_RE.match(head + '@' + tail) is not None\n\n    except ValueError:\n        # borderline case in which we have multiple \"@\" signs but the head part is correctly escaped\n        if ESCAPED_AT_SIGN.search(input_string) is not None:\n            # replace \"@\" with \"a\" in the head\n            return is_email(ESCAPED_AT_SIGN.sub('a', input_string))\n\n        return False",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 26,
        "Query": "This function is already mentioned, but it could also be used in the context of validating IPv6 addresses to split the input into segments for additional validation checks.",
        "Function Name": "is_ip_v6",
        "Docstring": "Checks if a string is a valid ip v6.\n\n*Examples:*\n\n>>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n>>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if a v6 ip, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and IP_V6_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 26,
        "Query": "This function could be used to apply the `int` conversion to each segment of an IPv4 address to validate that all parts are within the valid range of 0-255.",
        "Function Name": "is_ip_v4",
        "Docstring": "Checks if a string is a valid ip v4.\n\n*Examples:*\n\n>>> is_ip_v4('255.200.100.75') # returns true\n>>> is_ip_v4('nope') # returns false (not an ip)\n>>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if an ip v4, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string) or SHALLOW_IP_V4_RE.match(input_string) is None:\n        return False\n\n    # checks that each entry in the ip is in the valid range (0 to 255)\n    for token in input_string.split('.'):\n        if not (0 <= int(token) <= 255):\n            return False\n\n    return True",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 26,
        "Query": "This function could be utilized to filter out any invalid segments when processing the IPv4 address segments before further validation.",
        "Function Name": "is_ip_v4",
        "Docstring": "Checks if a string is a valid ip v4.\n\n*Examples:*\n\n>>> is_ip_v4('255.200.100.75') # returns true\n>>> is_ip_v4('nope') # returns false (not an ip)\n>>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if an ip v4, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string) or SHALLOW_IP_V4_RE.match(input_string) is None:\n        return False\n\n    # checks that each entry in the ip is in the valid range (0 to 255)\n    for token in input_string.split('.'):\n        if not (0 <= int(token) <= 255):\n            return False\n\n    return True",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 26,
        "Query": "This function might be employed to count the occurrences of dots (for IPv4) or colons (for IPv6) in the input string, confirming that the correct number of segments is present before applying more detailed validations.",
        "Function Name": "is_ip_v4",
        "Docstring": "Checks if a string is a valid ip v4.\n\n*Examples:*\n\n>>> is_ip_v4('255.200.100.75') # returns true\n>>> is_ip_v4('nope') # returns false (not an ip)\n>>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if an ip v4, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string) or SHALLOW_IP_V4_RE.match(input_string) is None:\n        return False\n\n    # checks that each entry in the ip is in the valid range (0 to 255)\n    for token in input_string.split('.'):\n        if not (0 <= int(token) <= 255):\n            return False\n\n    return True",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 26,
        "Query": "This could be used if patterns are meant to be found in non-exact matches or in cases where other formats may mistakenly appear as a valid IP under certain circumstances before confirming the full match.\n\nThese functions may be integrated into the `is_ip` function to enhance the parsing, validation, and checking processes for both IPv4 and IPv6 addresses.",
        "Function Name": "is_ip_v6",
        "Docstring": "Checks if a string is a valid ip v6.\n\n*Examples:*\n\n>>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n>>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if a v6 ip, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and IP_V6_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 27,
        "Query": "This function is used to check whether a character is a whitespace or not, which may be helpful when filtering out spaces from the string.",
        "Function Name": "is_full_string",
        "Docstring": "Check if a string is not empty (it must contains at least one non space character).\n\n*Examples:*\n\n>>> is_full_string(None) # returns false\n>>> is_full_string('') # returns false\n>>> is_full_string(' ') # returns false\n>>> is_full_string('hello') # returns true\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if not empty, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_full_string(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is not empty (it must contains at least one non space character).\n\n    *Examples:*\n\n    >>> is_full_string(None) # returns false\n    >>> is_full_string('') # returns false\n    >>> is_full_string(' ') # returns false\n    >>> is_full_string('hello') # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if not empty, false otherwise.\n    \"\"\"\n    return is_string(input_string) and input_string.strip() != ''",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 27,
        "Query": "This function is used to preprocess the input string based on the flags for ignoring spaces and case, returning the resultant formatted string ready for palindrome checking.",
        "Function Name": "strip_margin",
        "Docstring": "Removes tab indentation from multi line strings (inspired by analogous Scala function).\n\n*Example:*\n\n>>> strip_margin('''\n>>>                 line 1\n>>>                 line 2\n>>>                 line 3\n>>> ''')\n>>> # returns:\n>>> '''\n>>> line 1\n>>> line 2\n>>> line 3\n>>> '''\n\n:param input_string: String to format\n:type input_string: str\n:return: A string without left margins",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def strip_margin(input_string: str) -> str:\n    \"\"\"\n    Removes tab indentation from multi line strings (inspired by analogous Scala function).\n\n    *Example:*\n\n    >>> strip_margin('''\n    >>>                 line 1\n    >>>                 line 2\n    >>>                 line 3\n    >>> ''')\n    >>> # returns:\n    >>> '''\n    >>> line 1\n    >>> line 2\n    >>> line 3\n    >>> '''\n\n    :param input_string: String to format\n    :type input_string: str\n    :return: A string without left margins\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    line_separator = '\\n'\n    lines = [MARGIN_RE.sub('', line) for line in input_string.split(line_separator)]\n    out = line_separator.join(lines)\n\n    return out",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 27,
        "Query": "This function is used to reverse a given string, which can simplify the palindrome check by allowing for a separate function handling the string reversal logic.",
        "Function Name": "reverse",
        "Docstring": "Returns the string with its chars reversed.\n\n*Example:*\n\n>>> reverse('hello') # returns 'olleh'\n\n:param input_string: String to revert.\n:type input_string: str\n:return: Reversed string.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def reverse(input_string: str) -> str:\n    \"\"\"\n    Returns the string with its chars reversed.\n\n    *Example:*\n\n    >>> reverse('hello') # returns 'olleh'\n\n    :param input_string: String to revert.\n    :type input_string: str\n    :return: Reversed string.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return input_string[::-1]",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 27,
        "Query": "This function is used to determine if the input string is empty, which can directly impact the palindrome check, since an empty string is often considered a palindrome.",
        "Function Name": "__require_valid_input_and_encoding",
        "Docstring": "No docstring provided",
        "Arguments": "input_string, encoding",
        "Defaults": [],
        "Code": "    def __require_valid_input_and_encoding(input_string: str, encoding: str):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        if len(input_string) == 0:\n            raise ValueError('Input string cannot be empty')\n\n        if not is_string(encoding):\n            raise ValueError('Invalid encoding')",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 27,
        "Query": "This function is used to convert any given string to lowercase, providing a dedicated method for this transformation, especially if more complex case rules need to be implemented in the future.",
        "Function Name": "camel_case_to_snake",
        "Docstring": "Convert a camel case string into a snake case one.\n(The original string is returned if is not a valid camel case string)\n\n*Example:*\n\n>>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign to use as separator.\n:type separator: str\n:return: Converted string.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'_'"
        ],
        "Code": "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_camel_case(input_string):\n        return input_string\n\n    return CAMEL_CASE_REPLACE_RE.sub(lambda m: m.group(1) + separator, input_string).lower()",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 27,
        "Query": "This function is used to compare the original string with its reversed version, determining if they are equivalent, thus facilitating the palindrome check specifically.",
        "Function Name": "reverse",
        "Docstring": "Returns the string with its chars reversed.\n\n*Example:*\n\n>>> reverse('hello') # returns 'olleh'\n\n:param input_string: String to revert.\n:type input_string: str\n:return: Reversed string.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def reverse(input_string: str) -> str:\n    \"\"\"\n    Returns the string with its chars reversed.\n\n    *Example:*\n\n    >>> reverse('hello') # returns 'olleh'\n\n    :param input_string: String to revert.\n    :type input_string: str\n    :return: Reversed string.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return input_string[::-1]",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 27,
        "Query": "This function is used to execute the combined operations of removing spaces and converting cases in a single operation, thereby streamlining the preprocessing step for easier management of multiple string formats.",
        "Function Name": "strip_margin",
        "Docstring": "Removes tab indentation from multi line strings (inspired by analogous Scala function).\n\n*Example:*\n\n>>> strip_margin('''\n>>>                 line 1\n>>>                 line 2\n>>>                 line 3\n>>> ''')\n>>> # returns:\n>>> '''\n>>> line 1\n>>> line 2\n>>> line 3\n>>> '''\n\n:param input_string: String to format\n:type input_string: str\n:return: A string without left margins",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def strip_margin(input_string: str) -> str:\n    \"\"\"\n    Removes tab indentation from multi line strings (inspired by analogous Scala function).\n\n    *Example:*\n\n    >>> strip_margin('''\n    >>>                 line 1\n    >>>                 line 2\n    >>>                 line 3\n    >>> ''')\n    >>> # returns:\n    >>> '''\n    >>> line 1\n    >>> line 2\n    >>> line 3\n    >>> '''\n\n    :param input_string: String to format\n    :type input_string: str\n    :return: A string without left margins\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    line_separator = '\\n'\n    lines = [MARGIN_RE.sub('', line) for line in input_string.split(line_separator)]\n    out = line_separator.join(lines)\n\n    return out",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 28,
        "Query": "This function is used to convert all characters in the `input_string` to lowercase, ensuring that the pangram check is case-insensitive.",
        "Function Name": "camel_case_to_snake",
        "Docstring": "Convert a camel case string into a snake case one.\n(The original string is returned if is not a valid camel case string)\n\n*Example:*\n\n>>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign to use as separator.\n:type separator: str\n:return: Converted string.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'_'"
        ],
        "Code": "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_camel_case(input_string):\n        return input_string\n\n    return CAMEL_CASE_REPLACE_RE.sub(lambda m: m.group(1) + separator, input_string).lower()",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 28,
        "Query": "This function is used to create a new set of characters from the `input_string`, allowing for efficient tracking of which letters from the alphabet are present in the string.",
        "Function Name": "random_string",
        "Docstring": "Returns a string of the specified size containing random characters (uppercase/lowercase ascii letters and digits).\n\n*Example:*\n\n>>> random_string(9) # possible output: \"cx3QQbzYg\"\n\n:param size: Desired string size\n:type size: int\n:return: Random string",
        "Arguments": "size",
        "Defaults": [],
        "Code": "def random_string(size: int) -> str:\n    \"\"\"\n    Returns a string of the specified size containing random characters (uppercase/lowercase ascii letters and digits).\n\n    *Example:*\n\n    >>> random_string(9) # possible output: \"cx3QQbzYg\"\n\n    :param size: Desired string size\n    :type size: int\n    :return: Random string\n    \"\"\"\n    if not isinstance(size, int) or size < 1:\n        raise ValueError('size must be >= 1')\n\n    chars = string.ascii_letters + string.digits\n    buffer = [random.choice(chars) for _ in range(size)]\n    out = ''.join(buffer)\n\n    return out",
        "Class": null,
        "File": "input/string_utils/generation.py"
    },
    {
        "_id": 28,
        "Query": "This function is also employed to create a set of all the letters in the English alphabet (from 'a' to 'z') which is used for comparison purposes.",
        "Function Name": "is_isogram",
        "Docstring": "Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n*Examples:*\n\n>>> is_isogram('dermatoglyphics') # returns true\n>>> is_isogram('hello') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if isogram, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_isogram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n    *Examples:*\n\n    >>> is_isogram('dermatoglyphics') # returns true\n    >>> is_isogram('hello') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if isogram, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and len(set(input_string)) == len(input_string)",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 28,
        "Query": "This function is used to check if the set of characters derived from `input_string` is a subset of the set containing all letters of the English alphabet, thereby determining if the `input_string` is a pangram.",
        "Function Name": "is_isogram",
        "Docstring": "Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n*Examples:*\n\n>>> is_isogram('dermatoglyphics') # returns true\n>>> is_isogram('hello') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if isogram, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_isogram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n    *Examples:*\n\n    >>> is_isogram('dermatoglyphics') # returns true\n    >>> is_isogram('hello') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if isogram, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and len(set(input_string)) == len(input_string)",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 28,
        "Query": "This function could be used to filter the characters in the `input_string`, ensuring only alphabetical characters are considered when checking for pangrams, thus ignoring digits, punctuation, and spaces.",
        "Function Name": "slugify",
        "Docstring": "Converts a string into a \"slug\" using provided separator.\nThe returned string has the following properties:\n\n- it has no spaces\n- all letters are in lower case\n- all punctuation signs and non alphanumeric chars are removed\n- words are divided using provided separator\n- all chars are encoded as ascii (by using `asciify()`)\n- is safe for URL\n\n*Examples:*\n\n>>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n>>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign used to join string tokens (default to \"-\").\n:type separator: str\n:return: Slug string",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'-'"
        ],
        "Code": "def slugify(input_string: str, separator: str = '-') -> str:\n    \"\"\"\n    Converts a string into a \"slug\" using provided separator.\n    The returned string has the following properties:\n\n    - it has no spaces\n    - all letters are in lower case\n    - all punctuation signs and non alphanumeric chars are removed\n    - words are divided using provided separator\n    - all chars are encoded as ascii (by using `asciify()`)\n    - is safe for URL\n\n    *Examples:*\n\n    >>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n    >>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign used to join string tokens (default to \"-\").\n    :type separator: str\n    :return: Slug string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    # replace any character that is NOT letter or number with spaces\n    out = NO_LETTERS_OR_NUMBERS_RE.sub(' ', input_string.lower()).strip()\n\n    # replace spaces with join sign\n    out = SPACES_RE.sub(separator, out)\n\n    # normalize joins (remove duplicates)\n    out = re.sub(re.escape(separator) + r'+', separator, out)\n\n    return asciify(out)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 28,
        "Query": "This function could potentially be used for a more explicit membership check, confirming if every alphabet letter is present in the set derived from `input_string`, thus providing an alternative implementation for determining if the string is a pangram.",
        "Function Name": "is_isogram",
        "Docstring": "Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n*Examples:*\n\n>>> is_isogram('dermatoglyphics') # returns true\n>>> is_isogram('hello') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if isogram, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_isogram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n    *Examples:*\n\n    >>> is_isogram('dermatoglyphics') # returns true\n    >>> is_isogram('hello') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if isogram, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and len(set(input_string)) == len(input_string)",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 29,
        "Query": "This function is used to convert the input string to lowercase, ensuring that the isogram check is case-insensitive.",
        "Function Name": "camel_case_to_snake",
        "Docstring": "Convert a camel case string into a snake case one.\n(The original string is returned if is not a valid camel case string)\n\n*Example:*\n\n>>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign to use as separator.\n:type separator: str\n:return: Converted string.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'_'"
        ],
        "Code": "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_camel_case(input_string):\n        return input_string\n\n    return CAMEL_CASE_REPLACE_RE.sub(lambda m: m.group(1) + separator, input_string).lower()",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 29,
        "Query": "This function is used to create a new empty set which will store the characters seen so far in the input string.",
        "Function Name": "is_pangram",
        "Docstring": "Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n*Examples:*\n\n>>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n>>> is_pangram('hello world') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if the string is a pangram, False otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_pangram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n    *Examples:*\n\n    >>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n    >>> is_pangram('hello world') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if the string is a pangram, False otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    return set(SPACES_RE.sub('', input_string)).issuperset(set(string.ascii_lowercase))",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 29,
        "Query": "This method is used to add a character to the set of seen characters when it is determined that the character is not a duplicate.",
        "Function Name": "__remove_duplicates",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __remove_duplicates(self, regex_match):\n        return regex_match.group(1)[0]",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 29,
        "Query": "This operator is used to check if a character is already present in the set of seen characters during the iteration.",
        "Function Name": "__remove_duplicates",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __remove_duplicates(self, regex_match):\n        return regex_match.group(1)[0]",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 29,
        "Query": "This function might be used to check if the characters in the input string are alphabetic, allowing the function to potentially ignore non-alphabetic characters when checking for isograms.",
        "Function Name": "is_pangram",
        "Docstring": "Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n*Examples:*\n\n>>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n>>> is_pangram('hello world') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if the string is a pangram, False otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_pangram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n    *Examples:*\n\n    >>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n    >>> is_pangram('hello world') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if the string is a pangram, False otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    return set(SPACES_RE.sub('', input_string)).issuperset(set(string.ascii_lowercase))",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 29,
        "Query": "This function could be used to check if the length of the input string is greater than the number of unique characters, which would immediately indicate that the string cannot be an isogram.",
        "Function Name": "is_pangram",
        "Docstring": "Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n*Examples:*\n\n>>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n>>> is_pangram('hello world') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if the string is a pangram, False otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_pangram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n    *Examples:*\n\n    >>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n    >>> is_pangram('hello world') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if the string is a pangram, False otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    return set(SPACES_RE.sub('', input_string)).issuperset(set(string.ascii_lowercase))",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 29,
        "Query": "This method could be considered (though not explicitly an existing function in Python) to iterate over the characters of the string, emphasizing the need for a loop structure.",
        "Function Name": "uuid",
        "Docstring": "Generated an UUID string (using `uuid.uuid4()`).\n\n*Examples:*\n\n>>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n>>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n:param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n:return: uuid string.",
        "Arguments": "as_hex",
        "Defaults": [
            "False"
        ],
        "Code": "def uuid(as_hex: bool = False) -> str:\n    \"\"\"\n    Generated an UUID string (using `uuid.uuid4()`).\n\n    *Examples:*\n\n    >>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n    >>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n    :param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n    :return: uuid string.\n    \"\"\"\n    uid = uuid4()\n\n    if as_hex:\n        return uid.hex\n\n    return str(uid)",
        "Class": null,
        "File": "input/string_utils/generation.py"
    },
    {
        "_id": 29,
        "Query": "This function could be called to remove any leading or trailing whitespace from the input string before performing the isogram check, ensuring that the check only considers the actual characters intended.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 30,
        "Query": "This function is used to convert the `input_string` to lowercase, ensuring it adheres to the slug requirement of having all lowercase characters.",
        "Function Name": "camel_case_to_snake",
        "Docstring": "Convert a camel case string into a snake case one.\n(The original string is returned if is not a valid camel case string)\n\n*Example:*\n\n>>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign to use as separator.\n:type separator: str\n:return: Converted string.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'_'"
        ],
        "Code": "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_camel_case(input_string):\n        return input_string\n\n    return CAMEL_CASE_REPLACE_RE.sub(lambda m: m.group(1) + separator, input_string).lower()",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 30,
        "Query": "This function is used to break down the `input_string` into individual words based on spaces or other delimiters, allowing the function to check whether the separator is appropriately placed between these words.",
        "Function Name": "__ensure_spaces_around",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_spaces_around(self, regex_match):\n        return ' ' + regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 30,
        "Query": "This function might be used in the function to reconstruct the string back into a slug format by joining the split components using the specified `separator`.",
        "Function Name": "slugify",
        "Docstring": "Converts a string into a \"slug\" using provided separator.\nThe returned string has the following properties:\n\n- it has no spaces\n- all letters are in lower case\n- all punctuation signs and non alphanumeric chars are removed\n- words are divided using provided separator\n- all chars are encoded as ascii (by using `asciify()`)\n- is safe for URL\n\n*Examples:*\n\n>>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n>>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign used to join string tokens (default to \"-\").\n:type separator: str\n:return: Slug string",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'-'"
        ],
        "Code": "def slugify(input_string: str, separator: str = '-') -> str:\n    \"\"\"\n    Converts a string into a \"slug\" using provided separator.\n    The returned string has the following properties:\n\n    - it has no spaces\n    - all letters are in lower case\n    - all punctuation signs and non alphanumeric chars are removed\n    - words are divided using provided separator\n    - all chars are encoded as ascii (by using `asciify()`)\n    - is safe for URL\n\n    *Examples:*\n\n    >>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n    >>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign used to join string tokens (default to \"-\").\n    :type separator: str\n    :return: Slug string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    # replace any character that is NOT letter or number with spaces\n    out = NO_LETTERS_OR_NUMBERS_RE.sub(' ', input_string.lower()).strip()\n\n    # replace spaces with join sign\n    out = SPACES_RE.sub(separator, out)\n\n    # normalize joins (remove duplicates)\n    out = re.sub(re.escape(separator) + r'+', separator, out)\n\n    return asciify(out)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 30,
        "Query": "This function could be used to check the position of the `separator` within the `input_string`, determining if it's present and positioned correctly.",
        "Function Name": "__require_valid_input_and_encoding",
        "Docstring": "No docstring provided",
        "Arguments": "input_string, encoding",
        "Defaults": [],
        "Code": "    def __require_valid_input_and_encoding(input_string: str, encoding: str):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        if len(input_string) == 0:\n            raise ValueError('Input string cannot be empty')\n\n        if not is_string(encoding):\n            raise ValueError('Invalid encoding')",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 30,
        "Query": "This function may be used to check if each individual segment of the `input_string` (after splitting) is alphanumeric, confirming that the string does not contain any disallowed characters.",
        "Function Name": "words_count",
        "Docstring": "Returns the number of words contained into the given string.\n\nThis method is smart, it does consider only sequence of one or more letter and/or numbers\nas \"words\", so a string like this: \"! @ # % ... []\" will return zero!\nMoreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\nwill be 4 not 1 (even if there are no spaces in the string).\n\n*Examples:*\n\n>>> words_count('hello world') # returns 2\n>>> words_count('one,two,three.stop') # returns 4\n\n:param input_string: String to check.\n:type input_string: str\n:return: Number of words.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def words_count(input_string: str) -> int:\n    \"\"\"\n    Returns the number of words contained into the given string.\n\n    This method is smart, it does consider only sequence of one or more letter and/or numbers\n    as \"words\", so a string like this: \"! @ # % ... []\" will return zero!\n    Moreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\n    will be 4 not 1 (even if there are no spaces in the string).\n\n    *Examples:*\n\n    >>> words_count('hello world') # returns 2\n    >>> words_count('one,two,three.stop') # returns 4\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: Number of words.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return len(WORDS_COUNT_RE.findall(input_string))",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 30,
        "Query": "If the checks are more complex, a regular expression might be employed to validate the entire `input_string` against a pattern that represents valid slug formats (e.g., only allowing lowercase letters, digits, and the specified separator).",
        "Function Name": "is_snake_case",
        "Docstring": "Checks if a string is formatted as \"snake case\".\n\nA string is considered snake case when:\n\n- it's composed only by lowercase/uppercase letters and digits\n- it contains at least one underscore (or provided separator)\n- it does not start with a number\n\n*Examples:*\n\n>>> is_snake_case('foo_bar_baz') # returns true\n>>> is_snake_case('foo') # returns false\n\n:param input_string: String to test.\n:type input_string: str\n:param separator: String to use as separator.\n:type separator: str\n:return: True for a snake case string, false otherwise.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'_'"
        ],
        "Code": "def is_snake_case(input_string: Any, separator: str = '_') -> bool:\n    \"\"\"\n    Checks if a string is formatted as \"snake case\".\n\n    A string is considered snake case when:\n\n    - it's composed only by lowercase/uppercase letters and digits\n    - it contains at least one underscore (or provided separator)\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_snake_case('foo_bar_baz') # returns true\n    >>> is_snake_case('foo') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :param separator: String to use as separator.\n    :type separator: str\n    :return: True for a snake case string, false otherwise.\n    \"\"\"\n    if is_full_string(input_string):\n        re_map = {\n            '_': SNAKE_CASE_TEST_RE,\n            '-': SNAKE_CASE_TEST_DASH_RE\n        }\n        re_template = r'([a-z]+\\d*{sign}[a-z\\d{sign}]*|{sign}+[a-z\\d]+[a-z\\d{sign}]*)'\n        r = re_map.get(\n            separator,\n            re.compile(re_template.format(sign=re.escape(separator)), re.IGNORECASE)\n        )\n\n        return r.match(input_string) is not None\n\n    return False",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 30,
        "Query": "This function may also be used to check if the `input_string` starts with the specified `separator`, which could indicate an invalid slug format.",
        "Function Name": "is_snake_case",
        "Docstring": "Checks if a string is formatted as \"snake case\".\n\nA string is considered snake case when:\n\n- it's composed only by lowercase/uppercase letters and digits\n- it contains at least one underscore (or provided separator)\n- it does not start with a number\n\n*Examples:*\n\n>>> is_snake_case('foo_bar_baz') # returns true\n>>> is_snake_case('foo') # returns false\n\n:param input_string: String to test.\n:type input_string: str\n:param separator: String to use as separator.\n:type separator: str\n:return: True for a snake case string, false otherwise.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'_'"
        ],
        "Code": "def is_snake_case(input_string: Any, separator: str = '_') -> bool:\n    \"\"\"\n    Checks if a string is formatted as \"snake case\".\n\n    A string is considered snake case when:\n\n    - it's composed only by lowercase/uppercase letters and digits\n    - it contains at least one underscore (or provided separator)\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_snake_case('foo_bar_baz') # returns true\n    >>> is_snake_case('foo') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :param separator: String to use as separator.\n    :type separator: str\n    :return: True for a snake case string, false otherwise.\n    \"\"\"\n    if is_full_string(input_string):\n        re_map = {\n            '_': SNAKE_CASE_TEST_RE,\n            '-': SNAKE_CASE_TEST_DASH_RE\n        }\n        re_template = r'([a-z]+\\d*{sign}[a-z\\d{sign}]*|{sign}+[a-z\\d]+[a-z\\d{sign}]*)'\n        r = re_map.get(\n            separator,\n            re.compile(re_template.format(sign=re.escape(separator)), re.IGNORECASE)\n        )\n\n        return r.match(input_string) is not None\n\n    return False",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 30,
        "Query": "Similar to `startswith`, this function might be used to check if the `input_string` ends with the specified `separator`, implying an improperly formatted slug.",
        "Function Name": "prettify",
        "Docstring": "Reformat a string by applying the following basic grammar and formatting rules:\n\n- String cannot start or end with spaces\n- The first letter in the string and the ones after a dot, an exclamation or a question mark must be uppercase\n- String cannot have multiple sequential spaces, empty lines or punctuation (except for \"?\", \"!\" and \".\")\n- Arithmetic operators (+, -, /, \\*, =) must have one, and only one space before and after themselves\n- One, and only one space should follow a dot, a comma, an exclamation or a question mark\n- Text inside double quotes cannot start or end with spaces, but one, and only one space must come first and     after quotes (foo\" bar\"baz -> foo \"bar\" baz)\n- Text inside round brackets cannot start or end with spaces, but one, and only one space must come first and     after brackets (\"foo(bar )baz\" -> \"foo (bar) baz\")\n- Percentage sign (\"%\") cannot be preceded by a space if there is a number before (\"100 %\" -> \"100%\")\n- Saxon genitive is correct (\"Dave' s dog\" -> \"Dave's dog\")\n\n*Examples:*\n\n>>> prettify(' unprettified string ,, like this one,will be\"prettified\" .it\\' s awesome! ')\n>>> # -> 'Unprettified string, like this one, will be \"prettified\". It's awesome!'\n\n:param input_string: String to manipulate\n:return: Prettified string.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def prettify(input_string: str) -> str:\n    \"\"\"\n    Reformat a string by applying the following basic grammar and formatting rules:\n\n    - String cannot start or end with spaces\n    - The first letter in the string and the ones after a dot, an exclamation or a question mark must be uppercase\n    - String cannot have multiple sequential spaces, empty lines or punctuation (except for \"?\", \"!\" and \".\")\n    - Arithmetic operators (+, -, /, \\\\*, =) must have one, and only one space before and after themselves\n    - One, and only one space should follow a dot, a comma, an exclamation or a question mark\n    - Text inside double quotes cannot start or end with spaces, but one, and only one space must come first and \\\n    after quotes (foo\" bar\"baz -> foo \"bar\" baz)\n    - Text inside round brackets cannot start or end with spaces, but one, and only one space must come first and \\\n    after brackets (\"foo(bar )baz\" -> \"foo (bar) baz\")\n    - Percentage sign (\"%\") cannot be preceded by a space if there is a number before (\"100 %\" -> \"100%\")\n    - Saxon genitive is correct (\"Dave' s dog\" -> \"Dave's dog\")\n\n    *Examples:*\n\n    >>> prettify(' unprettified string ,, like this one,will be\"prettified\" .it\\\\' s awesome! ')\n    >>> # -> 'Unprettified string, like this one, will be \"prettified\". It\\'s awesome!'\n\n    :param input_string: String to manipulate\n    :return: Prettified string.\n    \"\"\"\n    formatted = __StringFormatter(input_string).format()\n    return formatted",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 30,
        "Query": "This function could be utilized to ensure all spaces are consistently replaced with the `separator`, preparing the string for validation as a valid slug format.\n\nBy using these potential functions, the `is_slug` function can more effectively validate whether the provided `input_string` meets the criteria for being a slug.",
        "Function Name": "slugify",
        "Docstring": "Converts a string into a \"slug\" using provided separator.\nThe returned string has the following properties:\n\n- it has no spaces\n- all letters are in lower case\n- all punctuation signs and non alphanumeric chars are removed\n- words are divided using provided separator\n- all chars are encoded as ascii (by using `asciify()`)\n- is safe for URL\n\n*Examples:*\n\n>>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n>>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign used to join string tokens (default to \"-\").\n:type separator: str\n:return: Slug string",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'-'"
        ],
        "Code": "def slugify(input_string: str, separator: str = '-') -> str:\n    \"\"\"\n    Converts a string into a \"slug\" using provided separator.\n    The returned string has the following properties:\n\n    - it has no spaces\n    - all letters are in lower case\n    - all punctuation signs and non alphanumeric chars are removed\n    - words are divided using provided separator\n    - all chars are encoded as ascii (by using `asciify()`)\n    - is safe for URL\n\n    *Examples:*\n\n    >>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n    >>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign used to join string tokens (default to \"-\").\n    :type separator: str\n    :return: Slug string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    # replace any character that is NOT letter or number with spaces\n    out = NO_LETTERS_OR_NUMBERS_RE.sub(' ', input_string.lower()).strip()\n\n    # replace spaces with join sign\n    out = SPACES_RE.sub(separator, out)\n\n    # normalize joins (remove duplicates)\n    out = re.sub(re.escape(separator) + r'+', separator, out)\n\n    return asciify(out)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 31,
        "Query": "This function is used to compile a regular expression pattern into a regex object, which can optimize the search operations when the regex pattern is used multiple times.",
        "Function Name": "__remove_duplicates",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __remove_duplicates(self, regex_match):\n        return regex_match.group(1)[0]",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 31,
        "Query": "This function is used to find all occurrences of the HTML/XML tags in the input string, potentially useful for counting or logging how many tags were found.",
        "Function Name": "words_count",
        "Docstring": "Returns the number of words contained into the given string.\n\nThis method is smart, it does consider only sequence of one or more letter and/or numbers\nas \"words\", so a string like this: \"! @ # % ... []\" will return zero!\nMoreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\nwill be 4 not 1 (even if there are no spaces in the string).\n\n*Examples:*\n\n>>> words_count('hello world') # returns 2\n>>> words_count('one,two,three.stop') # returns 4\n\n:param input_string: String to check.\n:type input_string: str\n:return: Number of words.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def words_count(input_string: str) -> int:\n    \"\"\"\n    Returns the number of words contained into the given string.\n\n    This method is smart, it does consider only sequence of one or more letter and/or numbers\n    as \"words\", so a string like this: \"! @ # % ... []\" will return zero!\n    Moreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\n    will be 4 not 1 (even if there are no spaces in the string).\n\n    *Examples:*\n\n    >>> words_count('hello world') # returns 2\n    >>> words_count('one,two,three.stop') # returns 4\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: Number of words.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return len(WORDS_COUNT_RE.findall(input_string))",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 31,
        "Query": "This function may be used to remove any leading or trailing whitespace from the `input_string` before performing the tag check, ensuring that extra spaces do not affect the result.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 31,
        "Query": "This function could be used to convert the `input_string` to lowercase before searching, allowing for case-insensitive matching of HTML/XML tags.",
        "Function Name": "camel_case_to_snake",
        "Docstring": "Convert a camel case string into a snake case one.\n(The original string is returned if is not a valid camel case string)\n\n*Example:*\n\n>>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign to use as separator.\n:type separator: str\n:return: Converted string.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'_'"
        ],
        "Code": "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_camel_case(input_string):\n        return input_string\n\n    return CAMEL_CASE_REPLACE_RE.sub(lambda m: m.group(1) + separator, input_string).lower()",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 31,
        "Query": "This function could be used to check the length of the list returned by `re.findall` or `re.search`, providing a quick way to determine if any tags were found.",
        "Function Name": "words_count",
        "Docstring": "Returns the number of words contained into the given string.\n\nThis method is smart, it does consider only sequence of one or more letter and/or numbers\nas \"words\", so a string like this: \"! @ # % ... []\" will return zero!\nMoreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\nwill be 4 not 1 (even if there are no spaces in the string).\n\n*Examples:*\n\n>>> words_count('hello world') # returns 2\n>>> words_count('one,two,three.stop') # returns 4\n\n:param input_string: String to check.\n:type input_string: str\n:return: Number of words.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def words_count(input_string: str) -> int:\n    \"\"\"\n    Returns the number of words contained into the given string.\n\n    This method is smart, it does consider only sequence of one or more letter and/or numbers\n    as \"words\", so a string like this: \"! @ # % ... []\" will return zero!\n    Moreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\n    will be 4 not 1 (even if there are no spaces in the string).\n\n    *Examples:*\n\n    >>> words_count('hello world') # returns 2\n    >>> words_count('one,two,three.stop') # returns 4\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: Number of words.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return len(WORDS_COUNT_RE.findall(input_string))",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 31,
        "Query": "If the function is designed to alert when undesirable tags are found, it may call a logging function to log the event for further analysis of potentially malicious content.",
        "Function Name": "strip_html",
        "Docstring": "Remove html code contained into the given string.\n\n*Examples:*\n\n>>> strip_html('test: <a href=\"foo/bar\">click here</a>') # returns 'test: '\n>>> strip_html('test: <a href=\"foo/bar\">click here</a>', keep_tag_content=True) # returns 'test: click here'\n\n:param input_string: String to manipulate.\n:type input_string: str\n:param keep_tag_content: True to preserve tag content, False to remove tag and its content too (default).\n:type keep_tag_content: bool\n:return: String with html removed.",
        "Arguments": "input_string, keep_tag_content",
        "Defaults": [
            "False"
        ],
        "Code": "def strip_html(input_string: str, keep_tag_content: bool = False) -> str:\n    \"\"\"\n    Remove html code contained into the given string.\n\n    *Examples:*\n\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>') # returns 'test: '\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>', keep_tag_content=True) # returns 'test: click here'\n\n    :param input_string: String to manipulate.\n    :type input_string: str\n    :param keep_tag_content: True to preserve tag content, False to remove tag and its content too (default).\n    :type keep_tag_content: bool\n    :return: String with html removed.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    r = HTML_TAG_ONLY_RE if keep_tag_content else HTML_RE\n\n    return r.sub('', input_string)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 31,
        "Query": "If a specific HTML tag needs to be checked for (e.g., checking specifically for script tags), this function could be used to determine if the key tag is present in the input string.",
        "Function Name": "is_credit_card",
        "Docstring": "Checks if a string is a valid credit card number.\nIf card type is provided then it checks against that specific type only,\notherwise any known credit card number will be accepted.\n\nSupported card types are the following:\n\n- VISA\n- MASTERCARD\n- AMERICAN_EXPRESS\n- DINERS_CLUB\n- DISCOVER\n- JCB\n\n:param input_string: String to check.\n:type input_string: str\n:param card_type: Card type. Default to None (any card).\n:type card_type: str\n\n:return: True if credit card, false otherwise.",
        "Arguments": "input_string, card_type",
        "Defaults": [
            "None"
        ],
        "Code": "def is_credit_card(input_string: Any, card_type: str = None) -> bool:\n    \"\"\"\n    Checks if a string is a valid credit card number.\n    If card type is provided then it checks against that specific type only,\n    otherwise any known credit card number will be accepted.\n\n    Supported card types are the following:\n\n    - VISA\n    - MASTERCARD\n    - AMERICAN_EXPRESS\n    - DINERS_CLUB\n    - DISCOVER\n    - JCB\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param card_type: Card type. Default to None (any card).\n    :type card_type: str\n\n    :return: True if credit card, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    if card_type:\n        if card_type not in CREDIT_CARDS:\n            raise KeyError(\n                'Invalid card type \"{}\". Valid types are: {}'.format(card_type, ', '.join(CREDIT_CARDS.keys()))\n            )\n        return CREDIT_CARDS[card_type].match(input_string) is not None\n\n    for c in CREDIT_CARDS:\n        if CREDIT_CARDS[c].match(input_string) is not None:\n            return True\n\n    return False",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 31,
        "Query": "This function could be used to generate a hash of the string for logging or tracking purposes, especially if records of input strings with tags need to be maintained.",
        "Function Name": "strip_html",
        "Docstring": "Remove html code contained into the given string.\n\n*Examples:*\n\n>>> strip_html('test: <a href=\"foo/bar\">click here</a>') # returns 'test: '\n>>> strip_html('test: <a href=\"foo/bar\">click here</a>', keep_tag_content=True) # returns 'test: click here'\n\n:param input_string: String to manipulate.\n:type input_string: str\n:param keep_tag_content: True to preserve tag content, False to remove tag and its content too (default).\n:type keep_tag_content: bool\n:return: String with html removed.",
        "Arguments": "input_string, keep_tag_content",
        "Defaults": [
            "False"
        ],
        "Code": "def strip_html(input_string: str, keep_tag_content: bool = False) -> str:\n    \"\"\"\n    Remove html code contained into the given string.\n\n    *Examples:*\n\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>') # returns 'test: '\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>', keep_tag_content=True) # returns 'test: click here'\n\n    :param input_string: String to manipulate.\n    :type input_string: str\n    :param keep_tag_content: True to preserve tag content, False to remove tag and its content too (default).\n    :type keep_tag_content: bool\n    :return: String with html removed.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    r = HTML_TAG_ONLY_RE if keep_tag_content else HTML_RE\n\n    return r.sub('', input_string)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 31,
        "Query": "If the function is extended to clean the input string by removing undesirable HTML tags, this function would be used for replacing these tags with empty strings or appropriate alternatives.\n\nThese speculative functions enhance the robustness and functionality of the `contains_html` method, including better performance, flexibility, and potential logging features.",
        "Function Name": "strip_html",
        "Docstring": "Remove html code contained into the given string.\n\n*Examples:*\n\n>>> strip_html('test: <a href=\"foo/bar\">click here</a>') # returns 'test: '\n>>> strip_html('test: <a href=\"foo/bar\">click here</a>', keep_tag_content=True) # returns 'test: click here'\n\n:param input_string: String to manipulate.\n:type input_string: str\n:param keep_tag_content: True to preserve tag content, False to remove tag and its content too (default).\n:type keep_tag_content: bool\n:return: String with html removed.",
        "Arguments": "input_string, keep_tag_content",
        "Defaults": [
            "False"
        ],
        "Code": "def strip_html(input_string: str, keep_tag_content: bool = False) -> str:\n    \"\"\"\n    Remove html code contained into the given string.\n\n    *Examples:*\n\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>') # returns 'test: '\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>', keep_tag_content=True) # returns 'test: click here'\n\n    :param input_string: String to manipulate.\n    :type input_string: str\n    :param keep_tag_content: True to preserve tag content, False to remove tag and its content too (default).\n    :type keep_tag_content: bool\n    :return: String with html removed.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    r = HTML_TAG_ONLY_RE if keep_tag_content else HTML_RE\n\n    return r.sub('', input_string)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 32,
        "Query": "This function is used to compile a regular expression pattern for better performance when the same pattern will be used multiple times. It could be called to create a regex object that holds the pattern for identifying valid words.",
        "Function Name": "__remove_duplicates",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __remove_duplicates(self, regex_match):\n        return regex_match.group(1)[0]",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 32,
        "Query": "This function is used to search for a regex pattern within a string. It may be called if the function needs to perform checks or validations on the input string before counting the words.",
        "Function Name": "is_isogram",
        "Docstring": "Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n*Examples:*\n\n>>> is_isogram('dermatoglyphics') # returns true\n>>> is_isogram('hello') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if isogram, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_isogram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n    *Examples:*\n\n    >>> is_isogram('dermatoglyphics') # returns true\n    >>> is_isogram('hello') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if isogram, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and len(set(input_string)) == len(input_string)",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 32,
        "Query": "This function is used to remove any leading or trailing whitespace from the input string. It might be called to ensure that the input string is clean before applying the regex to find words.",
        "Function Name": "__remove_internal_spaces",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __remove_internal_spaces(self, regex_match):\n        return regex_match.group(1).strip()",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 32,
        "Query": "These functions could be used to normalize the case of the input string, converting all characters to lowercase or uppercase before performing the word count, if the function wanted to be case-insensitive.",
        "Function Name": "snake_case_to_camel",
        "Docstring": "Convert a snake case string into a camel case one.\n(The original string is returned if is not a valid snake case string)\n\n*Example:*\n\n>>> snake_case_to_camel('the_snake_is_green') # returns 'TheSnakeIsGreen'\n\n:param input_string: String to convert.\n:type input_string: str\n:param upper_case_first: True to turn the first letter into uppercase (default).\n:type upper_case_first: bool\n:param separator: Sign to use as separator (default to \"_\").\n:type separator: str\n:return: Converted string",
        "Arguments": "input_string, upper_case_first, separator",
        "Defaults": [
            "True",
            "'_'"
        ],
        "Code": "def snake_case_to_camel(input_string: str, upper_case_first: bool = True, separator: str = '_') -> str:\n    \"\"\"\n    Convert a snake case string into a camel case one.\n    (The original string is returned if is not a valid snake case string)\n\n    *Example:*\n\n    >>> snake_case_to_camel('the_snake_is_green') # returns 'TheSnakeIsGreen'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param upper_case_first: True to turn the first letter into uppercase (default).\n    :type upper_case_first: bool\n    :param separator: Sign to use as separator (default to \"_\").\n    :type separator: str\n    :return: Converted string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_snake_case(input_string, separator):\n        return input_string\n\n    tokens = [s.title() for s in input_string.split(separator) if is_full_string(s)]\n\n    if not upper_case_first:\n        tokens[0] = tokens[0].lower()\n\n    out = ''.join(tokens)\n\n    return out",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 32,
        "Query": "This function is already mentioned in the dependencies, but it could potentially be used again to check the length of the list of matches before returning the result.",
        "Function Name": "is_json",
        "Docstring": "Check if a string is a valid json.\n\n*Examples:*\n\n>>> is_json('{\"name\": \"Peter\"}') # returns true\n>>> is_json('[1, 2, 3]') # returns true\n>>> is_json('{nope}') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if json, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_json(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid json.\n\n    *Examples:*\n\n    >>> is_json('{\"name\": \"Peter\"}') # returns true\n    >>> is_json('[1, 2, 3]') # returns true\n    >>> is_json('{nope}') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if json, false otherwise\n    \"\"\"\n    if is_full_string(input_string) and JSON_WRAPPER_RE.match(input_string) is not None:\n        try:\n            return isinstance(json.loads(input_string), (dict, list))\n        except (TypeError, ValueError, OverflowError):\n            pass\n\n    return False",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 32,
        "Query": "This function may be used to explicitly convert the result from `re.findall` (which is already a list) into a list type if it were to perform any operations that require list context or ensure a specific structure.",
        "Function Name": "is_json",
        "Docstring": "Check if a string is a valid json.\n\n*Examples:*\n\n>>> is_json('{\"name\": \"Peter\"}') # returns true\n>>> is_json('[1, 2, 3]') # returns true\n>>> is_json('{nope}') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if json, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_json(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid json.\n\n    *Examples:*\n\n    >>> is_json('{\"name\": \"Peter\"}') # returns true\n    >>> is_json('[1, 2, 3]') # returns true\n    >>> is_json('{nope}') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if json, false otherwise\n    \"\"\"\n    if is_full_string(input_string) and JSON_WRAPPER_RE.match(input_string) is not None:\n        try:\n            return isinstance(json.loads(input_string), (dict, list))\n        except (TypeError, ValueError, OverflowError):\n            pass\n\n    return False",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 32,
        "Query": "This function could be used to clean the input string by removing unwanted characters or patterns that are not considered valid words before processing it further.",
        "Function Name": "is_slug",
        "Docstring": "Checks if a given string is a slug (as created by `slugify()`).\n\n*Examples:*\n\n>>> is_slug('my-blog-post-title') # returns true\n>>> is_slug('My blog post title') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:param separator: Join sign used by the slug.\n:type separator: str\n:return: True if slug, false otherwise.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'-'"
        ],
        "Code": "def is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    rex = r'^([a-z\\d]+' + re.escape(separator) + r'*?)*[a-z\\d]$'\n\n    return re.match(rex, input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 32,
        "Query": "While the core logic aims to find words via regex, this function could potentially be called if the logic includes breaking the input string into segments based on whitespace or certain delimiters for preliminary checks.\n\nThese functions improve the robustness and functionality of the `words_count` function, ensuring it accurately counts words based on the defined criteria.",
        "Function Name": "contains_html",
        "Docstring": "Checks if the given string contains HTML/XML tags.\n\nBy design, this function matches ANY type of tag, so don't expect to use it\nas an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n*Examples:*\n\n>>> contains_html('my string is <strong>bold</strong>') # returns true\n>>> contains_html('my string is not bold') # returns false\n\n:param input_string: Text to check\n:type input_string: str\n:return: True if string contains html, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def contains_html(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string contains HTML/XML tags.\n\n    By design, this function matches ANY type of tag, so don't expect to use it\n    as an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n    *Examples:*\n\n    >>> contains_html('my string is <strong>bold</strong>') # returns true\n    >>> contains_html('my string is not bold') # returns false\n\n    :param input_string: Text to check\n    :type input_string: str\n    :return: True if string contains html, false otherwise.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return HTML_RE.search(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 33,
        "Query": "This function is used to remove any leading or trailing whitespace from the `input_string` before processing it for validation, ensuring that extra spaces do not affect the validation result.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 33,
        "Query": "This function is used to convert the `input_string` to lowercase before validation, in case the ISBN-10 contains an uppercase 'X'. This makes the check consistent, allowing both 'X' and 'x' to be recognized as valid.",
        "Function Name": "is_isbn",
        "Docstring": "Checks if the given string represents a valid ISBN (International Standard Book Number).\nBy default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\nfunction with `normalize=False` only digit-only strings will pass the validation.\n\n*Examples:*\n\n>>> is_isbn('9780312498580') # returns true\n>>> is_isbn('1506715214') # returns true\n\n:param input_string: String to check.\n:param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n:return: True if valid ISBN (10 or 13), false otherwise.",
        "Arguments": "input_string, normalize",
        "Defaults": [
            "True"
        ],
        "Code": "def is_isbn(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn('9780312498580') # returns true\n    >>> is_isbn('1506715214') # returns true\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN (10 or 13), false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_13() or checker.is_isbn_10()",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 33,
        "Query": "This function is used within a loop or a comprehension for converting characters in the `input_string` to integers during the checksum calculation for the purpose of performing calculations.",
        "Function Name": "is_number",
        "Docstring": "Checks if a string is a valid number.\n\nThe number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\nor use the \"scientific notation\" (eg: 1e5).\n\n*Examples:*\n\n>>> is_number('42') # returns true\n>>> is_number('19.99') # returns true\n>>> is_number('-9.12') # returns true\n>>> is_number('1e3') # returns true\n>>> is_number('1 2 3') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if the string represents a number, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_number(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid number.\n\n    The number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\n    or use the \"scientific notation\" (eg: 1e5).\n\n    *Examples:*\n\n    >>> is_number('42') # returns true\n    >>> is_number('19.99') # returns true\n    >>> is_number('-9.12') # returns true\n    >>> is_number('1e3') # returns true\n    >>> is_number('1 2 3') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if the string represents a number, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n\n    return NUMBER_RE.match(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 33,
        "Query": "This function can be used to iterate through the characters in the `input_string` along with their index, making it easier to calculate the checksum by multiplying each digit by its corresponding position index.",
        "Function Name": "is_isbn_13",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_13(self) -> bool:\n        if len(self.input_string) == 13:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    weight = 1 if (index % 2 == 0) else 3\n                    product += int(digit) * weight\n\n                return product % 10 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 33,
        "Query": "This function is used to verify if all of the first 9 characters (after normalization) are digits, providing a concise way to check the validity of multiple conditions in one go.",
        "Function Name": "is_isbn",
        "Docstring": "Checks if the given string represents a valid ISBN (International Standard Book Number).\nBy default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\nfunction with `normalize=False` only digit-only strings will pass the validation.\n\n*Examples:*\n\n>>> is_isbn('9780312498580') # returns true\n>>> is_isbn('1506715214') # returns true\n\n:param input_string: String to check.\n:param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n:return: True if valid ISBN (10 or 13), false otherwise.",
        "Arguments": "input_string, normalize",
        "Defaults": [
            "True"
        ],
        "Code": "def is_isbn(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn('9780312498580') # returns true\n    >>> is_isbn('1506715214') # returns true\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN (10 or 13), false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_13() or checker.is_isbn_10()",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 33,
        "Query": "This function may be called multiple times if there are other types of separators (e.g., spaces or dots) used in addition to hyphens. This would allow greater flexibility in handling various input formats.",
        "Function Name": "is_slug",
        "Docstring": "Checks if a given string is a slug (as created by `slugify()`).\n\n*Examples:*\n\n>>> is_slug('my-blog-post-title') # returns true\n>>> is_slug('My blog post title') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:param separator: Join sign used by the slug.\n:type separator: str\n:return: True if slug, false otherwise.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'-'"
        ],
        "Code": "def is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    rex = r'^([a-z\\d]+' + re.escape(separator) + r'*?)*[a-z\\d]$'\n\n    return re.match(rex, input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 33,
        "Query": "If the implementation requires a more precise comparison for floating-point values (though unlikely in this case), this function could help ensure that the calculated checksum closely matches the expected value.",
        "Function Name": "is_decimal",
        "Docstring": "Checks whether the given string represents a decimal or not.\n\nA decimal may be signed or unsigned or use a \"scientific notation\".\n\n>>> is_decimal('42.0') # returns true\n>>> is_decimal('42') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' in input_string",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 33,
        "Query": "This function could be used to format the output for logging or debugging purposes, providing clear messages or outputs regarding the validity of the ISBN being checked. \n\nThese functions enhance the robustness and flexibility of the `is_isbn_10` function, allowing for various input forms while ensuring accurate validation of ISBN-10 numbers.",
        "Function Name": "is_isbn",
        "Docstring": "Checks if the given string represents a valid ISBN (International Standard Book Number).\nBy default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\nfunction with `normalize=False` only digit-only strings will pass the validation.\n\n*Examples:*\n\n>>> is_isbn('9780312498580') # returns true\n>>> is_isbn('1506715214') # returns true\n\n:param input_string: String to check.\n:param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n:return: True if valid ISBN (10 or 13), false otherwise.",
        "Arguments": "input_string, normalize",
        "Defaults": [
            "True"
        ],
        "Code": "def is_isbn(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn('9780312498580') # returns true\n    >>> is_isbn('1506715214') # returns true\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN (10 or 13), false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_13() or checker.is_isbn_10()",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 34,
        "Query": "This function is used to remove any leading or trailing whitespace from the `input_string`, ensuring that such characters do not affect the validation process.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 34,
        "Query": "This function is used to convert string representations of digits into integer values for the checksum calculation, which requires numerical operations.",
        "Function Name": "roman_decode",
        "Docstring": "Decode a roman number string into an integer if the provided string is valid.\n\n*Example:*\n\n>>> roman_decode('VII') # returns 7\n\n:param input_string: (Assumed) Roman number\n:type input_string: str\n:return: Integer value",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def roman_decode(input_string: str) -> int:\n    \"\"\"\n    Decode a roman number string into an integer if the provided string is valid.\n\n    *Example:*\n\n    >>> roman_decode('VII') # returns 7\n\n    :param input_string: (Assumed) Roman number\n    :type input_string: str\n    :return: Integer value\n    \"\"\"\n    return __RomanNumbers.decode(input_string)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 34,
        "Query": "This function is used in conjunction with the `map` function to provide both the index and the digit during checksum calculation, facilitating the application of the alternating weights (1 and 3).",
        "Function Name": "is_isbn_10",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n\n                return product % 11 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 34,
        "Query": "This function may be used to pair the digits of the string with their corresponding weights (1 and 3) for the checksum calculation, allowing for simultaneous iteration over both sequences.",
        "Function Name": "is_isbn_10",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n\n                return product % 11 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 34,
        "Query": "This function may be used to calculate the checksum modulo 10, which is a necessary step to determine the validity of the ISBN by checking if it results in the expected last digit.",
        "Function Name": "is_isbn_10",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n\n                return product % 11 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 34,
        "Query": "This function might be utilized to format or construct error messages if the input fails validation, especially if the function includes exception handling for invalid input cases.",
        "Function Name": "__init__",
        "Docstring": "No docstring provided",
        "Arguments": "self, input_string",
        "Defaults": [],
        "Code": "    def __init__(self, input_string):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 34,
        "Query": "This function could be used to check if any character in the `input_string` is a non-digit when `normalize` is set to False, ensuring all characters are numeric.",
        "Function Name": "is_isbn_10",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n\n                return product % 11 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 34,
        "Query": "This function could be employed for regex-based replacement to remove hyphens or any other non-digit characters from the `input_string` if more complex normalization is required.",
        "Function Name": "is_isbn_10",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n\n                return product % 11 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 34,
        "Query": "This function may be employed to verify that `input_string` is a string type, ensuring type safety before proceeding with validation logic.",
        "Function Name": "__init__",
        "Docstring": "No docstring provided",
        "Arguments": "self, input_string",
        "Defaults": [],
        "Code": "    def __init__(self, input_string):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 34,
        "Query": "Although already mentioned, this function could be called multiple times to verify that the cleaned string remains at 13 characters at different stages of processing. \n\nBy including these functions, the `is_isbn_13` function can handle edge cases and ensure robust validation of the ISBN-13 standard.",
        "Function Name": "is_isbn",
        "Docstring": "Checks if the given string represents a valid ISBN (International Standard Book Number).\nBy default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\nfunction with `normalize=False` only digit-only strings will pass the validation.\n\n*Examples:*\n\n>>> is_isbn('9780312498580') # returns true\n>>> is_isbn('1506715214') # returns true\n\n:param input_string: String to check.\n:param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n:return: True if valid ISBN (10 or 13), false otherwise.",
        "Arguments": "input_string, normalize",
        "Defaults": [
            "True"
        ],
        "Code": "def is_isbn(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn('9780312498580') # returns true\n    >>> is_isbn('1506715214') # returns true\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN (10 or 13), false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_13() or checker.is_isbn_10()",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 35,
        "Query": "This function is used to remove unwanted whitespace characters from the beginning and end of the input string, ensuring the input is clean before further processing.",
        "Function Name": "__ensure_right_space_only",
        "Docstring": "No docstring provided",
        "Arguments": "self, regex_match",
        "Defaults": [],
        "Code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 35,
        "Query": "This function is used to replace hyphens (\"-\") in the input string with an empty string when `normalize` is set to `True`, standardizing the format of the ISBN for validation.",
        "Function Name": "is_isbn_10",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n\n                return product % 11 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 35,
        "Query": "This function is used to determine the length of the sanitized input string to check if it matches the required lengths of 10 or 13 characters for valid ISBNs.",
        "Function Name": "is_isbn_13",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_13(self) -> bool:\n        if len(self.input_string) == 13:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    weight = 1 if (index % 2 == 0) else 3\n                    product += int(digit) * weight\n\n                return product % 10 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 35,
        "Query": "This function is used to check if all characters in the string are digits, validating that the string only contains numeric characters, which is crucial for both ISBN validation formats.",
        "Function Name": "is_isbn_13",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_13(self) -> bool:\n        if len(self.input_string) == 13:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    weight = 1 if (index % 2 == 0) else 3\n                    product += int(digit) * weight\n\n                return product % 10 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 35,
        "Query": "This function is used to calculate the total of the processed digits for both ISBN-10 and ISBN-13 checksum calculations, which is essential for determining the validity of the ISBN format.",
        "Function Name": "is_isbn_10",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n\n                return product % 11 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 35,
        "Query": "This operation is used to perform the modulus operation to ensure that the checksum aligns with the rules for both ISBN-10 and ISBN-13 validations.",
        "Function Name": "is_isbn_10",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n\n                return product % 11 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 35,
        "Query": "This function is used to output the final result (`True` or `False`), depending on whether the input string passes all the validation checks.",
        "Function Name": "booleanize",
        "Docstring": "Turns a string into a boolean based on its content (CASE INSENSITIVE).\n\nA positive boolean (True) is returned if the string value is one of the following:\n\n- \"true\"\n- \"1\"\n- \"yes\"\n- \"y\"\n\nOtherwise False is returned.\n\n*Examples:*\n\n>>> booleanize('true') # returns True\n>>> booleanize('YES') # returns True\n>>> booleanize('nope') # returns False\n\n:param input_string: String to convert\n:type input_string: str\n:return: True if the string contains a boolean-like positive value, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def booleanize(input_string: str) -> bool:\n    \"\"\"\n    Turns a string into a boolean based on its content (CASE INSENSITIVE).\n\n    A positive boolean (True) is returned if the string value is one of the following:\n\n    - \"true\"\n    - \"1\"\n    - \"yes\"\n    - \"y\"\n\n    Otherwise False is returned.\n\n    *Examples:*\n\n    >>> booleanize('true') # returns True\n    >>> booleanize('YES') # returns True\n    >>> booleanize('nope') # returns False\n\n    :param input_string: String to convert\n    :type input_string: str\n    :return: True if the string contains a boolean-like positive value, false otherwise\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return input_string.lower() in ('true', '1', 'yes', 'y')",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 35,
        "Query": "This function may be called to encapsulate the logic for validating the checksum according to ISBN-10 rules, separating concerns for clarity and maintenance.",
        "Function Name": "is_isbn_10",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n\n                return product % 11 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 35,
        "Query": "This function may be called to encapsulate the logic for validating the checksum according to ISBN-13 rules, ensuring that the validation logic is modular and easier to manage.",
        "Function Name": "is_isbn_13",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_13(self) -> bool:\n        if len(self.input_string) == 13:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    weight = 1 if (index % 2 == 0) else 3\n                    product += int(digit) * weight\n\n                return product % 10 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 35,
        "Query": "This utility function could be used to perform the normalization process, such as removing unwanted characters (like hyphens) and handling any additional input formatting.",
        "Function Name": "is_isbn_10",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n\n                return product % 11 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 35,
        "Query": "This function could be used to log or report any errors encountered during the validation process, helping with debugging or auditing.",
        "Function Name": "contains_html",
        "Docstring": "Checks if the given string contains HTML/XML tags.\n\nBy design, this function matches ANY type of tag, so don't expect to use it\nas an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n*Examples:*\n\n>>> contains_html('my string is <strong>bold</strong>') # returns true\n>>> contains_html('my string is not bold') # returns false\n\n:param input_string: Text to check\n:type input_string: str\n:return: True if string contains html, false otherwise.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def contains_html(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string contains HTML/XML tags.\n\n    By design, this function matches ANY type of tag, so don't expect to use it\n    as an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n    *Examples:*\n\n    >>> contains_html('my string is <strong>bold</strong>') # returns true\n    >>> contains_html('my string is not bold') # returns false\n\n    :param input_string: Text to check\n    :type input_string: str\n    :return: True if string contains html, false otherwise.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return HTML_RE.search(input_string) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 35,
        "Query": "This function may be called to check if the sanitized string is exactly 10 or 13 characters long, improving code readability and modularity.\n\nThese additional functions would help in organizing the code more effectively, making it easier to read, maintain, and test.",
        "Function Name": "is_isbn_10",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n\n                return product % 11 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 36,
        "Query": "This function is used to generate a random UUID (Universally Unique Identifier) based on version 4 of the UUID standard.",
        "Function Name": "__placeholder_key",
        "Docstring": "No docstring provided",
        "Arguments": "",
        "Defaults": [],
        "Code": "    def __placeholder_key():\n        return '$' + uuid4().hex + '$'",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 36,
        "Query": "This function is used to convert the UUID object to its string representation in the default format.",
        "Function Name": "is_uuid",
        "Docstring": "Check if a string is a valid UUID.\n\n*Example:*\n\n>>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n:param input_string: String to check.\n:type input_string: str\n:param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n:type allow_hex: bool\n:return: True if UUID, false otherwise",
        "Arguments": "input_string, allow_hex",
        "Defaults": [
            "False"
        ],
        "Code": "def is_uuid(input_string: Any, allow_hex: bool = False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    # string casting is used to allow UUID itself as input data type\n    s = str(input_string)\n\n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n\n    return UUID_RE.match(s) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 36,
        "Query": "This function may be used to modify the UUID string representation to remove hyphens if the `as_hex` parameter is set to `True`.",
        "Function Name": "__init__",
        "Docstring": "No docstring provided",
        "Arguments": "self, input_string",
        "Defaults": [],
        "Code": "    def __init__(self, input_string):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 36,
        "Query": "This function could be used to convert the generated UUID back into a UUID object, if further manipulation or formatting were necessary.",
        "Function Name": "is_uuid",
        "Docstring": "Check if a string is a valid UUID.\n\n*Example:*\n\n>>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n:param input_string: String to check.\n:type input_string: str\n:param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n:type allow_hex: bool\n:return: True if UUID, false otherwise",
        "Arguments": "input_string, allow_hex",
        "Defaults": [
            "False"
        ],
        "Code": "def is_uuid(input_string: Any, allow_hex: bool = False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    # string casting is used to allow UUID itself as input data type\n    s = str(input_string)\n\n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n\n    return UUID_RE.match(s) is not None",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 36,
        "Query": "This function might be utilized if there was a need to construct the UUID string from its components in a customized manner (e.g., rejoining parts after manipulating them).",
        "Function Name": "shuffle",
        "Docstring": "Return a new string containing same chars of the given one but in a randomized order.\n\n*Example:*\n\n>>> shuffle('hello world') # possible output: 'l wodheorll'\n\n:param input_string: String to shuffle\n:type input_string: str\n:return: Shuffled string",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def shuffle(input_string: str) -> str:\n    \"\"\"\n    Return a new string containing same chars of the given one but in a randomized order.\n\n    *Example:*\n\n    >>> shuffle('hello world') # possible output: 'l wodheorll'\n\n    :param input_string: String to shuffle\n    :type input_string: str\n    :return: Shuffled string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    # turn the string into a list of chars\n    chars = list(input_string)\n\n    # shuffle the list\n    random.shuffle(chars)\n\n    # convert the shuffled list back to string\n    return ''.join(chars)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 36,
        "Query": "This function could be used to create a custom string format, although `str()` is likely sufficient for standard uses.",
        "Function Name": "is_string",
        "Docstring": "Checks if an object is a string.\n\n*Example:*\n\n>>> is_string('foo') # returns true\n>>> is_string(b'foo') # returns false\n\n:param obj: Object to test.\n:return: True if string, false otherwise.",
        "Arguments": "obj",
        "Defaults": [],
        "Code": "def is_string(obj: Any) -> bool:\n    \"\"\"\n    Checks if an object is a string.\n\n    *Example:*\n\n    >>> is_string('foo') # returns true\n    >>> is_string(b'foo') # returns false\n\n    :param obj: Object to test.\n    :return: True if string, false otherwise.\n    \"\"\"\n    return isinstance(obj, str)",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 36,
        "Query": "This function may be used to ensure that the hexadecimal UUID string is in lowercase.",
        "Function Name": "camel_case_to_snake",
        "Docstring": "Convert a camel case string into a snake case one.\n(The original string is returned if is not a valid camel case string)\n\n*Example:*\n\n>>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign to use as separator.\n:type separator: str\n:return: Converted string.",
        "Arguments": "input_string, separator",
        "Defaults": [
            "'_'"
        ],
        "Code": "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_camel_case(input_string):\n        return input_string\n\n    return CAMEL_CASE_REPLACE_RE.sub(lambda m: m.group(1) + separator, input_string).lower()",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 36,
        "Query": "This function might be employed if the implementation requires breaking down the UUID string into its components for any specific manipulation before rejoining the formatted string.\n\nBy considering these potential function calls, we can see that the target function may rely on a combination of UUID generation, string manipulation, and formatting to achieve its goal.",
        "Function Name": "prettify",
        "Docstring": "Reformat a string by applying the following basic grammar and formatting rules:\n\n- String cannot start or end with spaces\n- The first letter in the string and the ones after a dot, an exclamation or a question mark must be uppercase\n- String cannot have multiple sequential spaces, empty lines or punctuation (except for \"?\", \"!\" and \".\")\n- Arithmetic operators (+, -, /, \\*, =) must have one, and only one space before and after themselves\n- One, and only one space should follow a dot, a comma, an exclamation or a question mark\n- Text inside double quotes cannot start or end with spaces, but one, and only one space must come first and     after quotes (foo\" bar\"baz -> foo \"bar\" baz)\n- Text inside round brackets cannot start or end with spaces, but one, and only one space must come first and     after brackets (\"foo(bar )baz\" -> \"foo (bar) baz\")\n- Percentage sign (\"%\") cannot be preceded by a space if there is a number before (\"100 %\" -> \"100%\")\n- Saxon genitive is correct (\"Dave' s dog\" -> \"Dave's dog\")\n\n*Examples:*\n\n>>> prettify(' unprettified string ,, like this one,will be\"prettified\" .it\\' s awesome! ')\n>>> # -> 'Unprettified string, like this one, will be \"prettified\". It's awesome!'\n\n:param input_string: String to manipulate\n:return: Prettified string.",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def prettify(input_string: str) -> str:\n    \"\"\"\n    Reformat a string by applying the following basic grammar and formatting rules:\n\n    - String cannot start or end with spaces\n    - The first letter in the string and the ones after a dot, an exclamation or a question mark must be uppercase\n    - String cannot have multiple sequential spaces, empty lines or punctuation (except for \"?\", \"!\" and \".\")\n    - Arithmetic operators (+, -, /, \\\\*, =) must have one, and only one space before and after themselves\n    - One, and only one space should follow a dot, a comma, an exclamation or a question mark\n    - Text inside double quotes cannot start or end with spaces, but one, and only one space must come first and \\\n    after quotes (foo\" bar\"baz -> foo \"bar\" baz)\n    - Text inside round brackets cannot start or end with spaces, but one, and only one space must come first and \\\n    after brackets (\"foo(bar )baz\" -> \"foo (bar) baz\")\n    - Percentage sign (\"%\") cannot be preceded by a space if there is a number before (\"100 %\" -> \"100%\")\n    - Saxon genitive is correct (\"Dave' s dog\" -> \"Dave's dog\")\n\n    *Examples:*\n\n    >>> prettify(' unprettified string ,, like this one,will be\"prettified\" .it\\\\' s awesome! ')\n    >>> # -> 'Unprettified string, like this one, will be \"prettified\". It\\'s awesome!'\n\n    :param input_string: String to manipulate\n    :return: Prettified string.\n    \"\"\"\n    formatted = __StringFormatter(input_string).format()\n    return formatted",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 37,
        "Query": "This function is used to generate a specified number of random bytes, ensuring that the generated values are suitable for cryptographic use due to its secure nature.",
        "Function Name": "__placeholder_key",
        "Docstring": "No docstring provided",
        "Arguments": "",
        "Defaults": [],
        "Code": "    def __placeholder_key():\n        return '$' + uuid4().hex + '$'",
        "Class": "__StringFormatter",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 37,
        "Query": "This method is used to convert the byte sequence obtained from `os.urandom` into its corresponding hexadecimal string representation, effectively doubling the length of the output string compared to the input byte count.",
        "Function Name": "compress",
        "Docstring": "No docstring provided",
        "Arguments": "cls, input_string, encoding, compression_level",
        "Defaults": [
            "'utf-8'",
            "9"
        ],
        "Code": "    def compress(cls, input_string: str, encoding: str = 'utf-8', compression_level: int = 9) -> str:\n        cls.__require_valid_input_and_encoding(input_string, encoding)\n\n        if not isinstance(compression_level, int) or compression_level < 0 or compression_level > 9:\n            raise ValueError('Invalid compression_level: it must be an \"int\" between 0 and 9')\n\n        # turns input string into a sequence of bytes using provided encoding\n        original_bytes = input_string.encode(encoding)\n\n        # compress bytes using zlib library\n        compressed_bytes = zlib.compress(original_bytes, compression_level)\n\n        # encode compressed bytes using base64\n        # (this ensure that all characters will be available and that the output string can be used safely in any\n        # context such URLs)\n        encoded_bytes = base64.urlsafe_b64encode(compressed_bytes)\n\n        # finally turns base64 bytes into a string\n        output = encoded_bytes.decode(encoding)\n\n        return output",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 37,
        "Query": "This function may be used to verify the length of the resulting hexadecimal string, ensuring it matches the expected length (double the `byte_count`), which is useful for validation or debugging purposes.",
        "Function Name": "is_decimal",
        "Docstring": "Checks whether the given string represents a decimal or not.\n\nA decimal may be signed or unsigned or use a \"scientific notation\".\n\n>>> is_decimal('42.0') # returns true\n>>> is_decimal('42') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' in input_string",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 37,
        "Query": "Although not explicitly needed in the basic implementation, this function can be implicitly involved when converting bytes to a string format, if the implementation requires explicit type conversion for compatibility with other string-manipulating operations or libraries.",
        "Function Name": "is_string",
        "Docstring": "Checks if an object is a string.\n\n*Example:*\n\n>>> is_string('foo') # returns true\n>>> is_string(b'foo') # returns false\n\n:param obj: Object to test.\n:return: True if string, false otherwise.",
        "Arguments": "obj",
        "Defaults": [],
        "Code": "def is_string(obj: Any) -> bool:\n    \"\"\"\n    Checks if an object is a string.\n\n    *Example:*\n\n    >>> is_string('foo') # returns true\n    >>> is_string(b'foo') # returns false\n\n    :param obj: Object to test.\n    :return: True if string, false otherwise.\n    \"\"\"\n    return isinstance(obj, str)",
        "Class": null,
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 37,
        "Query": "While not directly called in the provided function, this could be invoked if the function's design were to support reproducibility (unlikely in a secure random generator like `os.urandom`, but mentioned for completeness).",
        "Function Name": "compress",
        "Docstring": "No docstring provided",
        "Arguments": "cls, input_string, encoding, compression_level",
        "Defaults": [
            "'utf-8'",
            "9"
        ],
        "Code": "    def compress(cls, input_string: str, encoding: str = 'utf-8', compression_level: int = 9) -> str:\n        cls.__require_valid_input_and_encoding(input_string, encoding)\n\n        if not isinstance(compression_level, int) or compression_level < 0 or compression_level > 9:\n            raise ValueError('Invalid compression_level: it must be an \"int\" between 0 and 9')\n\n        # turns input string into a sequence of bytes using provided encoding\n        original_bytes = input_string.encode(encoding)\n\n        # compress bytes using zlib library\n        compressed_bytes = zlib.compress(original_bytes, compression_level)\n\n        # encode compressed bytes using base64\n        # (this ensure that all characters will be available and that the output string can be used safely in any\n        # context such URLs)\n        encoded_bytes = base64.urlsafe_b64encode(compressed_bytes)\n\n        # finally turns base64 bytes into a string\n        output = encoded_bytes.decode(encoding)\n\n        return output",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 37,
        "Query": "This function might be used to log the operation for auditing or debugging purposes, especially in systems where security is critical and all random generation needs to be recorded.",
        "Function Name": "random_string",
        "Docstring": "Returns a string of the specified size containing random characters (uppercase/lowercase ascii letters and digits).\n\n*Example:*\n\n>>> random_string(9) # possible output: \"cx3QQbzYg\"\n\n:param size: Desired string size\n:type size: int\n:return: Random string",
        "Arguments": "size",
        "Defaults": [],
        "Code": "def random_string(size: int) -> str:\n    \"\"\"\n    Returns a string of the specified size containing random characters (uppercase/lowercase ascii letters and digits).\n\n    *Example:*\n\n    >>> random_string(9) # possible output: \"cx3QQbzYg\"\n\n    :param size: Desired string size\n    :type size: int\n    :return: Random string\n    \"\"\"\n    if not isinstance(size, int) or size < 1:\n        raise ValueError('size must be >= 1')\n\n    chars = string.ascii_letters + string.digits\n    buffer = [random.choice(chars) for _ in range(size)]\n    out = ''.join(buffer)\n\n    return out",
        "Class": null,
        "File": "input/string_utils/generation.py"
    },
    {
        "_id": 37,
        "Query": "This could be used if input validation is implemented, ensuring that `byte_count` is a non-negative integer, thereby providing a robust error handling mechanism.",
        "Function Name": "__require_valid_input_and_encoding",
        "Docstring": "No docstring provided",
        "Arguments": "input_string, encoding",
        "Defaults": [],
        "Code": "    def __require_valid_input_and_encoding(input_string: str, encoding: str):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        if len(input_string) == 0:\n            raise ValueError('Input string cannot be empty')\n\n        if not is_string(encoding):\n            raise ValueError('Invalid encoding')",
        "Class": "__StringCompressor",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 38,
        "Query": "This function is used to validate the input parameters, ensuring that `start` is not less than 1 and that `stop` is not greater than 3999, helping to maintain the integrity of the input values before processing.",
        "Function Name": "validate",
        "Docstring": "No docstring provided",
        "Arguments": "arg_value, arg_name, allow_negative",
        "Defaults": [
            "False"
        ],
        "Code": "    def validate(arg_value, arg_name, allow_negative=False):\n        msg = '\"{}\" must be an integer in the range 1-3999'.format(arg_name)\n\n        if not isinstance(arg_value, int):\n            raise ValueError(msg)\n\n        if allow_negative:\n            arg_value = abs(arg_value)\n\n        if arg_value < 1 or arg_value > 3999:\n            raise ValueError(msg)",
        "Class": null,
        "File": "input/string_utils/generation.py"
    },
    {
        "_id": 38,
        "Query": "This function is used to convert an integer value to its corresponding Roman numeral representation, handling the conversion logic that maps integers to their Roman numeral strings.",
        "Function Name": "roman_decode",
        "Docstring": "Decode a roman number string into an integer if the provided string is valid.\n\n*Example:*\n\n>>> roman_decode('VII') # returns 7\n\n:param input_string: (Assumed) Roman number\n:type input_string: str\n:return: Integer value",
        "Arguments": "input_string",
        "Defaults": [],
        "Code": "def roman_decode(input_string: str) -> int:\n    \"\"\"\n    Decode a roman number string into an integer if the provided string is valid.\n\n    *Example:*\n\n    >>> roman_decode('VII') # returns 7\n\n    :param input_string: (Assumed) Roman number\n    :type input_string: str\n    :return: Integer value\n    \"\"\"\n    return __RomanNumbers.decode(input_string)",
        "Class": null,
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 38,
        "Query": "This function is used to compute the next value in the sequence by adding the `step` to the current value, providing a clean separation of concerns regarding the increment logic.",
        "Function Name": "is_isbn_10",
        "Docstring": "No docstring provided",
        "Arguments": "self",
        "Defaults": [],
        "Code": "    def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n\n                return product % 11 == 0\n\n            except ValueError:\n                pass\n\n        return False",
        "Class": "__ISBNChecker",
        "File": "input/string_utils/validation.py"
    },
    {
        "_id": 38,
        "Query": "This function is used to check whether a given number is valid (i.e., within the allowed range for Roman numerals) before performing any conversions or operations on it.",
        "Function Name": "encode",
        "Docstring": "No docstring provided",
        "Arguments": "cls, input_number",
        "Defaults": [],
        "Code": "    def encode(cls, input_number: Union[str, int]) -> str:\n        # force input conversion to a string (we need it in order to iterate on each digit)\n        input_string = str(input_number)\n\n        if not is_integer(input_string):\n            raise ValueError('Invalid input, only strings or integers are allowed')\n\n        value = int(input_string)\n\n        if value < 1 or value > 3999:\n            raise ValueError('Input must be >= 1 and <= 3999')\n\n        input_len = len(input_string)\n        output = ''\n\n        # decode digits from right to left (start from units to thousands)\n        for index in range(input_len):\n            # get actual digit value as int\n            digit = int(input_string[input_len - index - 1])\n\n            # encode digit to roman string\n            encoded_digit = cls.__encode_digit(index, digit)\n\n            # prepend encoded value to the current output in order to have the final string sorted\n            # from thousands to units\n            output = encoded_digit + output\n\n        return output",
        "Class": "__RomanNumbers",
        "File": "input/string_utils/manipulation.py"
    },
    {
        "_id": 38,
        "Query": "This function is used to determine if the current value has not exceeded the stop value, assisting in the control of the loop execution to ensure it stops appropriately.",
        "Function Name": "validate",
        "Docstring": "No docstring provided",
        "Arguments": "arg_value, arg_name, allow_negative",
        "Defaults": [
            "False"
        ],
        "Code": "    def validate(arg_value, arg_name, allow_negative=False):\n        msg = '\"{}\" must be an integer in the range 1-3999'.format(arg_name)\n\n        if not isinstance(arg_value, int):\n            raise ValueError(msg)\n\n        if allow_negative:\n            arg_value = abs(arg_value)\n\n        if arg_value < 1 or arg_value > 3999:\n            raise ValueError(msg)",
        "Class": null,
        "File": "input/string_utils/generation.py"
    },
    {
        "_id": 38,
        "Query": "This function is used to format the output of Roman numerals if any special formatting or representation logic is required before yielding the numeral to the generator.",
        "Function Name": "generate",
        "Docstring": "No docstring provided",
        "Arguments": "",
        "Defaults": [],
        "Code": "    def generate():\n        current = start\n\n        # generate values for each step\n        while current != stop:\n            yield roman_encode(current)\n            current += step\n\n        # last value to return\n        yield roman_encode(current)",
        "Class": null,
        "File": "input/string_utils/generation.py"
    },
    {
        "_id": 38,
        "Query": "This function might be used to log any error messages encountered during the validation process or if any exceptions arise while generating the Roman numerals, aiding in debugging and error tracking. \n\nThese functions would help modularize the implementation of `roman_range` and enhance its readability and maintainability.",
        "Function Name": "generate",
        "Docstring": "No docstring provided",
        "Arguments": "",
        "Defaults": [],
        "Code": "    def generate():\n        current = start\n\n        # generate values for each step\n        while current != stop:\n            yield roman_encode(current)\n            current += step\n\n        # last value to return\n        yield roman_encode(current)",
        "Class": null,
        "File": "input/string_utils/generation.py"
    }
]