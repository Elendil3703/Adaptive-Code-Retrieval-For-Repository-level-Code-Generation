[
    {
        "name": "test_should_return_false_for_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_return_false_for_non_string_objects(self):\n        # noinspection PyTypeChecker\n        self.assertFalse(is_camel_case(None))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_camel_case(False))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_camel_case(0))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_camel_case([]))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_camel_case({'a': 1}))"
    },
    {
        "name": "test_string_cannot_be_empty",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_cannot_be_empty(self):\n        self.assertFalse(is_camel_case(''))\n        self.assertFalse(is_camel_case(' '))"
    },
    {
        "name": "test_string_cannot_be_all_lowercase",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_cannot_be_all_lowercase(self):\n        self.assertFalse(is_camel_case('lowercase'))"
    },
    {
        "name": "test_string_cannot_be_all_uppercase",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_cannot_be_all_uppercase(self):\n        self.assertFalse(is_camel_case('UPPERCASE'))"
    },
    {
        "name": "test_string_cannot_contain_spaces",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_cannot_contain_spaces(self):\n        self.assertFalse(is_camel_case(' CamelCase '))"
    },
    {
        "name": "test_string_cannot_start_with_number",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_cannot_start_with_number(self):\n        self.assertFalse(is_camel_case('1000Times'))"
    },
    {
        "name": "test_string_cannot_contain_invalid_chars",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_cannot_contain_invalid_chars(self):\n        self.assertFalse(is_camel_case('<#NotCamelCaseHere!?>'))"
    },
    {
        "name": "test_should_accept_valid_camel_case_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_accept_valid_camel_case_string(self):\n        self.assertTrue(is_camel_case('Camel'))\n        self.assertTrue(is_camel_case('CamelCase'))\n        self.assertTrue(is_camel_case('camelCase'))\n        self.assertTrue(is_camel_case('CamelCaseTOO'))\n        self.assertTrue(is_camel_case('ACamelCaseIsAlsoAStringLikeThis1'))\n        self.assertTrue(is_camel_case('camelCaseStartingLowerEndingUPPER'))"
    },
    {
        "name": "test_range_raise_exception_if_stop_is_invalid",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_range_raise_exception_if_stop_is_invalid(self):\n        msg = '\"stop\" must be an integer in the range 1-3999'\n\n        with self.assertRaises(ValueError) as raised:\n            roman_range(0)\n\n        self.assertEqual(str(raised.exception), msg)\n\n        with self.assertRaises(ValueError) as raised:\n            # noinspection PyTypeChecker\n            roman_range(9.9)\n\n        self.assertEqual(str(raised.exception), msg)\n\n        with self.assertRaises(ValueError) as raised:\n            roman_range(4000)\n\n        self.assertEqual(str(raised.exception), msg)\n\n        with self.assertRaises(ValueError) as raised:\n            roman_range(-4000)\n\n        self.assertEqual(str(raised.exception), msg)"
    },
    {
        "name": "test_range_returns_expected_generator_for_count_call",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_range_returns_expected_generator_for_count_call(self):\n        generator = roman_range(10)\n\n        self.assertEqual(generator.__next__(), 'I')\n        self.assertEqual(generator.__next__(), 'II')\n        self.assertEqual(generator.__next__(), 'III')\n        self.assertEqual(generator.__next__(), 'IV')\n        self.assertEqual(generator.__next__(), 'V')\n        self.assertEqual(generator.__next__(), 'VI')\n        self.assertEqual(generator.__next__(), 'VII')\n        self.assertEqual(generator.__next__(), 'VIII')\n        self.assertEqual(generator.__next__(), 'IX')\n        self.assertEqual(generator.__next__(), 'X')\n\n        # generator has been consumed, so another call will raise an exception\n        self.assertRaises(StopIteration, generator.__next__)"
    },
    {
        "name": "test_range_returns_expected_generator_for_start_stop_call_forward",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_range_returns_expected_generator_for_start_stop_call_forward(self):\n        generator = roman_range(start=10, stop=18)\n\n        self.assertEqual(generator.__next__(), 'X')\n        self.assertEqual(generator.__next__(), 'XI')\n        self.assertEqual(generator.__next__(), 'XII')\n        self.assertEqual(generator.__next__(), 'XIII')\n        self.assertEqual(generator.__next__(), 'XIV')\n        self.assertEqual(generator.__next__(), 'XV')\n        self.assertEqual(generator.__next__(), 'XVI')\n        self.assertEqual(generator.__next__(), 'XVII')\n        self.assertEqual(generator.__next__(), 'XVIII')\n\n        # generator has been consumed, so another call will raise an exception\n        self.assertRaises(StopIteration, generator.__next__)"
    },
    {
        "name": "test_range_returns_expected_generator_for_start_stop_call_backward",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_range_returns_expected_generator_for_start_stop_call_backward(self):\n        generator = roman_range(start=10, stop=1, step=-1)\n\n        self.assertEqual(generator.__next__(), 'X')\n        self.assertEqual(generator.__next__(), 'IX')\n        self.assertEqual(generator.__next__(), 'VIII')\n        self.assertEqual(generator.__next__(), 'VII')\n        self.assertEqual(generator.__next__(), 'VI')\n        self.assertEqual(generator.__next__(), 'V')\n        self.assertEqual(generator.__next__(), 'IV')\n        self.assertEqual(generator.__next__(), 'III')\n        self.assertEqual(generator.__next__(), 'II')\n        self.assertEqual(generator.__next__(), 'I')\n\n        # generator has been consumed, so another call will raise an exception\n        self.assertRaises(StopIteration, generator.__next__)"
    },
    {
        "name": "test_range_returns_expected_generator_for_start_stop_step_call",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_range_returns_expected_generator_for_start_stop_step_call(self):\n        generator = roman_range(start=10, stop=30, step=5)\n\n        self.assertEqual(generator.__next__(), 'X')\n        self.assertEqual(generator.__next__(), 'XV')\n        self.assertEqual(generator.__next__(), 'XX')\n        self.assertEqual(generator.__next__(), 'XXV')\n        self.assertEqual(generator.__next__(), 'XXX')\n\n        # generator has been consumed, so another call will raise an exception\n        self.assertRaises(StopIteration, generator.__next__)"
    },
    {
        "name": "test_start_param_cannot_be_less_than_1",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_start_param_cannot_be_less_than_1(self):\n        self.assertRaises(ValueError, lambda: roman_range(start=0, stop=10))\n        self.assertRaises(ValueError, lambda: roman_range(start=-1, stop=10))\n        self.assertRaises(ValueError, lambda: roman_range(start=-55, stop=10))"
    },
    {
        "name": "test_stop_param_cannot_be_less_than_1",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_stop_param_cannot_be_less_than_1(self):\n        self.assertRaises(ValueError, lambda: roman_range(start=1, stop=0))\n        self.assertRaises(ValueError, lambda: roman_range(start=1, stop=-99, step=-1))"
    },
    {
        "name": "test_stop_param_cannot_be_greater_than_3999",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_stop_param_cannot_be_greater_than_3999(self):\n        self.assertRaises(ValueError, lambda: roman_range(start=1, stop=4000))\n        self.assertRaises(ValueError, lambda: roman_range(start=1, stop=10000))"
    },
    {
        "name": "test_start_stop_step_config_cannot_exceed_bounds",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_start_stop_step_config_cannot_exceed_bounds(self):\n        # start (3995) + step (10) will exceed stop (3999)\n        self.assertRaises(OverflowError, lambda: roman_range(start=3995, stop=3999, step=10))\n\n        # start (10) + step (200) will exceed stop (100)\n        self.assertRaises(OverflowError, lambda: roman_range(start=10, stop=100, step=200))\n\n        # step should be -1 in order to go from 100 to 1\n        self.assertRaises(OverflowError, lambda: roman_range(start=100, stop=1, step=1))\n\n        # start (10) + step (-6) will exceed stop (5)\n        self.assertRaises(OverflowError, lambda: roman_range(start=10, stop=5, step=-6))"
    },
    {
        "name": "test_cannot_handle_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_cannot_handle_non_string_objects(self):\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            booleanize(None)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"NoneType\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            booleanize(False)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"bool\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            booleanize(0)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"int\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            booleanize([])\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"list\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            booleanize({'a': 1})\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"dict\"')"
    },
    {
        "name": "test_returns_false_for_empty_strings",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_false_for_empty_strings(self):\n        self.assertFalse(booleanize(''))\n        self.assertFalse(booleanize(' '))"
    },
    {
        "name": "test_returns_true_for_positive_strings",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_true_for_positive_strings(self):\n        self.assertTrue(booleanize('true'))\n        self.assertTrue(booleanize('TRUE'))\n        self.assertTrue(booleanize('True'))\n        self.assertTrue(booleanize('1'))\n        self.assertTrue(booleanize('yes'))\n        self.assertTrue(booleanize('YES'))\n        self.assertTrue(booleanize('Yes'))\n        self.assertTrue(booleanize('y'))\n        self.assertTrue(booleanize('Y'))"
    },
    {
        "name": "test_returns_false_for_negative_strings",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_false_for_negative_strings(self):\n        self.assertFalse(booleanize('false'))\n        self.assertFalse(booleanize('FALSE'))\n        self.assertFalse(booleanize('False'))\n        self.assertFalse(booleanize('0'))\n        self.assertFalse(booleanize('banana'))"
    },
    {
        "name": "test_cannot_handle_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_cannot_handle_non_string_objects(self):\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            camel_case_to_snake(None)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"NoneType\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            camel_case_to_snake(False)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"bool\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            camel_case_to_snake(0)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"int\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            camel_case_to_snake([])\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"list\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            camel_case_to_snake({'a': 1})\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"dict\"')"
    },
    {
        "name": "test_returns_same_string_if_all_lowercase",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_same_string_if_all_lowercase(self):\n        s = 'lower'\n        self.assertEqual(camel_case_to_snake(s), s)"
    },
    {
        "name": "test_returns_same_string_if_all_uppercase",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_same_string_if_all_uppercase(self):\n        s = 'UPPERCASE'\n        self.assertEqual(camel_case_to_snake(s), s)"
    },
    {
        "name": "test_returns_lowercase_string_for_single_word",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_lowercase_string_for_single_word(self):\n        s = 'Hello'\n        self.assertEqual(camel_case_to_snake(s), s.lower())"
    },
    {
        "name": "test_returns_words_divided_by_underscores_for_each_camel_word",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_words_divided_by_underscores_for_each_camel_word(self):\n        s = 'CamelCaseStringToTest'\n        self.assertEqual(camel_case_to_snake(s), 'camel_case_string_to_test')"
    },
    {
        "name": "test_returns_words_divided_by_underscores_for_each_camel_word_even_for_articles",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_words_divided_by_underscores_for_each_camel_word_even_for_articles(self):\n        s = 'ThisIsACamelStringTestB'\n        self.assertEqual(camel_case_to_snake(s), 'this_is_a_camel_string_test_b')"
    },
    {
        "name": "test_handles_acronyms_gracefully",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_handles_acronyms_gracefully(self):\n        s = 'SPAAppsAreVeryPopularOnTheWEBToday'\n        self.assertEqual(camel_case_to_snake(s), 'spa_apps_are_very_popular_on_the_web_today')"
    },
    {
        "name": "test_should_return_same_string_if_contains_spaces",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_return_same_string_if_contains_spaces(self):\n        s = 'This Is Not A Camel Case String! butThisOneIs'\n        self.assertEqual(camel_case_to_snake(s), s)"
    },
    {
        "name": "test_should_use_provided_separator",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_use_provided_separator(self):\n        s = 'CamelCaseString'\n        self.assertEqual(camel_case_to_snake(s, '_'), 'camel_case_string')\n        self.assertEqual(camel_case_to_snake(s, '||'), 'camel||case||string')\n        self.assertEqual(camel_case_to_snake(s, ' '), 'camel case string')"
    },
    {
        "name": "test_cannot_handle_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_cannot_handle_non_string_objects(self):\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            slugify(None)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"NoneType\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            slugify(False)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"bool\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            slugify(0)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"int\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            slugify([])\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"list\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            slugify({'a': 1})\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"dict\"')"
    },
    {
        "name": "test_slugify_lowercase_strings",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_slugify_lowercase_strings(self):\n        self.assertEqual(slugify('BANANA'), 'banana')"
    },
    {
        "name": "test_slugify_trim_strings_and_extra_white_spaces",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_slugify_trim_strings_and_extra_white_spaces(self):\n        self.assertEqual(slugify('hello '), 'hello')\n        self.assertEqual(slugify(' hello'), 'hello')\n        self.assertEqual(slugify(' hello '), 'hello')\n        self.assertEqual(slugify(' hello world '), 'hello-world')\n        self.assertEqual(slugify('''\n            \\n\\t\n            hello \\n\\t world\n            \\n\\t\n        '''), 'hello-world')"
    },
    {
        "name": "test_slugify_removes_signs",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_slugify_removes_signs(self):\n        self.assertEqual(slugify('(this is a \"test\")'), 'this-is-a-test')\n        self.assertEqual(slugify('<<wow>> :: [yeah]'), 'wow-yeah')\n        self.assertEqual(slugify('c++'), 'c')\n        self.assertEqual(slugify('?#foo+bar+baz!'), 'foo-bar-baz')"
    },
    {
        "name": "test_slugify_use_given_join_sign",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_slugify_use_given_join_sign(self):\n        self.assertEqual(slugify('Slugify this string please!', '-'), 'slugify-this-string-please')\n        self.assertEqual(slugify('Slugify this string please!', '_'), 'slugify_this_string_please')\n        self.assertEqual(slugify('Slugify this string please!', '.'), 'slugify.this.string.please')"
    },
    {
        "name": "test_slugify_converts_non_ascii_letters",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_slugify_converts_non_ascii_letters(self):\n        self.assertEqual(slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt'), 'monster-magnet')"
    },
    {
        "name": "test_slugify_preserves_numbers",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_slugify_preserves_numbers(self):\n        self.assertEqual(slugify('12 eggs, 1 gallon of milk, 4 bananas'), '12-eggs-1-gallon-of-milk-4-bananas')"
    },
    {
        "name": "test_slugify_removes_dash_duplicates",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_slugify_removes_dash_duplicates(self):\n        self.assertEqual(slugify('-hello world too--much --dashes---here--'), 'hello-world-too-much-dashes-here')"
    },
    {
        "name": "test_non_string_objects_return_false",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_non_string_objects_return_false(self):\n        # noinspection PyTypeChecker\n        self.assertFalse(is_isogram(1))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_isogram(['xx']))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_isogram({}))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_isogram(False))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_isogram((1, 2, 3)))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_isogram(object()))"
    },
    {
        "name": "test_empty_strings_are_not_isograms",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_empty_strings_are_not_isograms(self):\n        self.assertFalse(is_isogram(''))\n        self.assertFalse(is_isogram(' '))\n        self.assertFalse(is_isogram(' \\n \\t '))"
    },
    {
        "name": "test_is_isogram_returns_true_if_isogram",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_is_isogram_returns_true_if_isogram(self):\n        self.assertTrue(is_isogram('dermatoglyphics'))\n        self.assertTrue(is_isogram('abcdefghilmnopqrs'))"
    },
    {
        "name": "test_is_isogram_returns_false_if_not_isogram",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_is_isogram_returns_false_if_not_isogram(self):\n        self.assertFalse(is_isogram('hello'))\n        self.assertFalse(is_isogram('hello world, how are you?'))"
    },
    {
        "name": "test_cannot_handle_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_cannot_handle_non_string_objects(self):\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            snake_case_to_camel(None)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"NoneType\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            snake_case_to_camel(False)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"bool\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            snake_case_to_camel(0)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"int\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            snake_case_to_camel([])\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"list\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            snake_case_to_camel({'a': 1})\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"dict\"')"
    },
    {
        "name": "test_returns_original_string_if_not_snake_case",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_original_string_if_not_snake_case(self):\n        self.assertEqual(snake_case_to_camel(''), '')\n        self.assertEqual(snake_case_to_camel('foo'), 'foo')\n        self.assertEqual(snake_case_to_camel('foo bar baz'), 'foo bar baz')\n        self.assertEqual(snake_case_to_camel('not_snake_!'), 'not_snake_!')\n        self.assertEqual(snake_case_to_camel('(not_snake)'), '(not_snake)')\n        self.assertEqual(snake_case_to_camel('123not_snake'), '123not_snake')"
    },
    {
        "name": "test_returns_camel_case_from_correct_snake_case",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_camel_case_from_correct_snake_case(self):\n        self.assertEqual(snake_case_to_camel('hello_world'), 'HelloWorld')\n        self.assertEqual(snake_case_to_camel('the_snake_is_green'), 'TheSnakeIsGreen')\n        self.assertEqual(snake_case_to_camel('the_number_of_the_beast_is_666'), 'TheNumberOfTheBeastIs666')\n        self.assertEqual(snake_case_to_camel('a_b_c_d'), 'ABCD')\n        self.assertEqual(snake_case_to_camel('_one'), 'One')\n        self.assertEqual(snake_case_to_camel('__one'), 'One')\n        self.assertEqual(snake_case_to_camel('one_'), 'One')\n        self.assertEqual(snake_case_to_camel('_one_'), 'One')"
    },
    {
        "name": "test_should_consider_custom_separator",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_consider_custom_separator(self):\n        s = 'snake-case-using-dashes'\n        self.assertEqual(snake_case_to_camel(s), s)\n        self.assertEqual(snake_case_to_camel(s, separator='-'), 'SnakeCaseUsingDashes')"
    },
    {
        "name": "test_should_not_capitalize_first_letter_if_specified",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_not_capitalize_first_letter_if_specified(self):\n        self.assertEqual(snake_case_to_camel('this_will_starts_lower_case', False), 'thisWillStartsLowerCase')\n        self.assertEqual(snake_case_to_camel('hello_world', False), 'helloWorld')\n        self.assertEqual(snake_case_to_camel('the_snake_is_green', False), 'theSnakeIsGreen')\n        self.assertEqual(snake_case_to_camel('the_number_of_the_beast_is_666', False), 'theNumberOfTheBeastIs666')\n        self.assertEqual(snake_case_to_camel('a_b_c_d', False), 'aBCD')\n        self.assertEqual(snake_case_to_camel('_one', False), 'one')\n        self.assertEqual(snake_case_to_camel('__one', False), 'one')\n        self.assertEqual(snake_case_to_camel('one_', False), 'one')\n        self.assertEqual(snake_case_to_camel('_one_', False), 'one')"
    },
    {
        "name": "test_should_return_false_for_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_return_false_for_non_string_objects(self):\n        # noinspection PyTypeChecker\n        self.assertFalse(is_email(None))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_email(False))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_email(0))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_email([]))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_email({'a': 1}))"
    },
    {
        "name": "test_string_cannot_be_empty",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_cannot_be_empty(self):\n        self.assertFalse(is_email(''))\n        self.assertFalse(is_email(' '))"
    },
    {
        "name": "test_tail_is_required",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tail_is_required(self):\n        self.assertFalse(is_email('name@'))"
    },
    {
        "name": "test_head_is_required",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_head_is_required(self):\n        self.assertFalse(is_email('@foo.com'))"
    },
    {
        "name": "test_at_sign_is_required",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_at_sign_is_required(self):\n        self.assertFalse(is_email('name.site.com'))"
    },
    {
        "name": "test_domain_extension_is_required",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_domain_extension_is_required(self):\n        self.assertFalse(is_email('name@site'))\n        self.assertFalse(is_email('name@site.'))"
    },
    {
        "name": "test_domain_extension_should_be_letters_only_from_2_to_4_chars",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_domain_extension_should_be_letters_only_from_2_to_4_chars(self):\n        self.assertFalse(is_email('me@foo.123'))\n        self.assertFalse(is_email('me@foo.c'))\n        self.assertFalse(is_email('me@foo.!!'))\n        self.assertFalse(is_email('me@foo.___'))\n        self.assertFalse(is_email('me@foo.toolongext'))"
    },
    {
        "name": "test_head_cannot_contain_suqare_brackets",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_head_cannot_contain_suqare_brackets(self):\n        self.assertFalse(is_email('[myemail@foo.com'))\n        self.assertFalse(is_email('my]email@foo.com'))"
    },
    {
        "name": "test_tail_cannot_contain_bad_signs",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tail_cannot_contain_bad_signs(self):\n        self.assertFalse(is_email('me@#foo#.com'))\n        self.assertFalse(is_email('me@foo!.com'))\n        self.assertFalse(is_email('someone@[foo].com'))"
    },
    {
        "name": "test_tail_cannot_be_uppercase",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tail_cannot_be_uppercase(self):\n        self.assertFalse(is_email('someone@SOMESITE.COM'))"
    },
    {
        "name": "test_tail_cannot_contain_dots_sequence",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tail_cannot_contain_dots_sequence(self):\n        self.assertFalse(is_email('name@em..ail.net'))\n        self.assertFalse(is_email('name@email..net'))"
    },
    {
        "name": "test_domain_cannot_be_single_char",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_domain_cannot_be_single_char(self):\n        self.assertFalse(is_email('name@d.com'))"
    },
    {
        "name": "test_should_accept_valid_emails",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_accept_valid_emails(self):\n        self.assertTrue(is_email('me@foo.com'))\n        self.assertTrue(is_email('name@gmail.com'))\n        self.assertTrue(is_email('name2@gmail.com'))\n        self.assertTrue(is_email('PeterParker@gmail.com'))\n        self.assertTrue(is_email('first_name.last_name@yahoo.it'))\n        self.assertTrue(is_email('foo@domamin.subdomain.com'))\n        self.assertTrue(is_email('is1email@domain.org'))\n        self.assertTrue(is_email('UPPER_CASE_EMAIL@somesite.com'))"
    },
    {
        "name": "test_max_email_length_is_respected",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_max_email_length_is_respected(self):\n        invalid_email = ('a' * 320) + '@gmail.com'\n        self.assertFalse(is_email(invalid_email))"
    },
    {
        "name": "test_head_length_is_respected",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_head_length_is_respected(self):\n        # max head size is 64\n        invalid_email = ('a' * 65) + '@gmail.com'\n        self.assertFalse(is_email(invalid_email))"
    },
    {
        "name": "test_tail_length_is_respected",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tail_length_is_respected(self):\n        # max tail size is 255\n        invalid_email = 'a@{}.com'.format(255 * 'x')\n        self.assertFalse(is_email(invalid_email))"
    },
    {
        "name": "test_plus_is_valid_char_in_head",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_plus_is_valid_char_in_head(self):\n        self.assertTrue(is_email('my+mail@gmail.com'))"
    },
    {
        "name": "test_plus_is_invalid_char_in_tail",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_plus_is_invalid_char_in_tail(self):\n        self.assertFalse(is_email('mymail@foo+bar.com'))"
    },
    {
        "name": "test_minus_is_valid_char_in_head",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_minus_is_valid_char_in_head(self):\n        self.assertTrue(is_email('my-mail@gmail.com'))"
    },
    {
        "name": "test_slash_is_valid_char_in_head",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_slash_is_valid_char_in_head(self):\n        self.assertTrue(is_email('my/mail@gmail.com'))"
    },
    {
        "name": "test_slash_is_invalid_char_in_tail",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_slash_is_invalid_char_in_tail(self):\n        self.assertFalse(is_email('mymail@foo/bar.com'))"
    },
    {
        "name": "test_back_slash_is_valid_char_in_head",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_back_slash_is_valid_char_in_head(self):\n        self.assertTrue(is_email('my\\\\mail@gmail.com'))"
    },
    {
        "name": "test_equal_is_valid_char_in_head",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_equal_is_valid_char_in_head(self):\n        self.assertTrue(is_email('my=mail@gmail.com'))"
    },
    {
        "name": "test_equal_is_invalid_char_in_tail",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_equal_is_invalid_char_in_tail(self):\n        self.assertFalse(is_email('mymail@gm=ail.com'))"
    },
    {
        "name": "test_question_mark_is_valid_char_in_head",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_question_mark_is_valid_char_in_head(self):\n        self.assertTrue(is_email('my?mail@gmail.com'))"
    },
    {
        "name": "test_question_mark_is_invalid_char_in_tail",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_question_mark_is_invalid_char_in_tail(self):\n        self.assertFalse(is_email('mymail@gm?ail.com'))"
    },
    {
        "name": "test_sharp_is_valid_char_in_head",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_sharp_is_valid_char_in_head(self):\n        self.assertTrue(is_email('my#mail@gmail.com'))"
    },
    {
        "name": "test_sharp_is_invalid_char_in_tail",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_sharp_is_invalid_char_in_tail(self):\n        self.assertFalse(is_email('mymail@gma#il.com'))"
    },
    {
        "name": "test_dollar_is_valid_char_in_head",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_dollar_is_valid_char_in_head(self):\n        self.assertTrue(is_email('my$mail@gmail.com'))"
    },
    {
        "name": "test_dollar_is_invalid_char_in_tail",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_dollar_is_invalid_char_in_tail(self):\n        self.assertFalse(is_email('mymail@gm$ail.com'))"
    },
    {
        "name": "test_and_is_valid_char_in_head",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_and_is_valid_char_in_head(self):\n        self.assertTrue(is_email('my&mail@gmail.com'))"
    },
    {
        "name": "test_and_is_invalid_char_in_tail",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_and_is_invalid_char_in_tail(self):\n        self.assertFalse(is_email('mymail@gm&ail.com'))"
    },
    {
        "name": "test_asterisk_is_valid_char_in_head",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_asterisk_is_valid_char_in_head(self):\n        self.assertTrue(is_email('my*mail@gmail.com'))"
    },
    {
        "name": "test_asterisk_is_invalid_char_in_tail",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_asterisk_is_invalid_char_in_tail(self):\n        self.assertFalse(is_email('mymail@gmai*l.com'))"
    },
    {
        "name": "test_apostrophe_is_valid_char_in_head",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_apostrophe_is_valid_char_in_head(self):\n        self.assertTrue(is_email('my\\'mail@gmail.com'))"
    },
    {
        "name": "test_apostrophe_is_invalid_char_in_tail",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_apostrophe_is_invalid_char_in_tail(self):\n        self.assertFalse(is_email('mymail@gma\\'il.com'))"
    },
    {
        "name": "test_acute_accent_is_valid_char_in_head",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_acute_accent_is_valid_char_in_head(self):\n        self.assertTrue(is_email('my`mail@gmail.com'))"
    },
    {
        "name": "test_acute_accent_is_invalid_char_in_tail",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_acute_accent_is_invalid_char_in_tail(self):\n        self.assertFalse(is_email('mymail@gma`il.com'))"
    },
    {
        "name": "test_percentage_is_valid_char_in_head",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_percentage_is_valid_char_in_head(self):\n        self.assertTrue(is_email('my%mail@gmail.com'))"
    },
    {
        "name": "test_percentage_is_invalid_char_in_tail",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_percentage_is_invalid_char_in_tail(self):\n        self.assertFalse(is_email('mymail@gma%il.com'))"
    },
    {
        "name": "test_exclamation_mark_is_valid_char_in_head",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_exclamation_mark_is_valid_char_in_head(self):\n        self.assertTrue(is_email('my!mail@gmail.com'))"
    },
    {
        "name": "test_exclamation_mark_is_invalid_char_in_tail",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_exclamation_mark_is_invalid_char_in_tail(self):\n        self.assertFalse(is_email('mymail@gm!ail.com'))"
    },
    {
        "name": "test_caret_is_valid_char_in_head",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_caret_is_valid_char_in_head(self):\n        self.assertTrue(is_email('my^mail@gmail.com'))"
    },
    {
        "name": "test_caret_is_invalid_char_in_tail",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_caret_is_invalid_char_in_tail(self):\n        self.assertFalse(is_email('mymail@gma^il.com'))"
    },
    {
        "name": "test_pipe_is_valid_char_in_head",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_pipe_is_valid_char_in_head(self):\n        self.assertTrue(is_email('my|mail@gmail.com'))"
    },
    {
        "name": "test_pipe_is_invalid_char_in_tail",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_pipe_is_invalid_char_in_tail(self):\n        self.assertFalse(is_email('mymail@gm|ail.com'))"
    },
    {
        "name": "test_tilde_is_valid_char_in_head",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tilde_is_valid_char_in_head(self):\n        self.assertTrue(is_email('my~mail@gmail.com'))"
    },
    {
        "name": "test_tilde_is_invalid_char_in_tail",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tilde_is_invalid_char_in_tail(self):\n        self.assertFalse(is_email('mymail@gma~il.com'))"
    },
    {
        "name": "test_curly_braces_are_valid_char_in_head",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_curly_braces_are_valid_char_in_head(self):\n        self.assertTrue(is_email('my{mail@gmail.com'))\n        self.assertTrue(is_email('my}mail@gmail.com'))\n        self.assertTrue(is_email('{mymail}@gmail.com'))"
    },
    {
        "name": "test_head_cannot_start_with_period",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_head_cannot_start_with_period(self):\n        self.assertFalse(is_email('.myemail@gmail.com'))"
    },
    {
        "name": "test_head_cannot_end_with_period",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_head_cannot_end_with_period(self):\n        self.assertFalse(is_email('myemail.@gmail.com'))"
    },
    {
        "name": "test_head_cannot_have_multiple_consecutive_periods",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_head_cannot_have_multiple_consecutive_periods(self):\n        self.assertFalse(is_email('my..email@gmail.com'))\n        self.assertFalse(is_email('my.email...nope@gmail.com'))"
    },
    {
        "name": "test_empty_spaces_are_allowed_only_if_escaped",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_empty_spaces_are_allowed_only_if_escaped(self):\n        self.assertFalse(is_email('my mail@gmail.com'))\n        self.assertTrue(is_email('my\\\\ mail@gmail.com'))\n        self.assertTrue(is_email('\"my mail\"@gmail.com'))"
    },
    {
        "name": "test_head_can_be_quoted",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_head_can_be_quoted(self):\n        self.assertTrue(is_email('\"foo\"@example.com'))"
    },
    {
        "name": "test_head_quotes_must_be_correct",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_head_quotes_must_be_correct(self):\n        self.assertFalse(is_email('\"nope@gmail.com'))\n        self.assertFalse(is_email('no\"pe@gmail.com'))\n        self.assertFalse(is_email('nope\"@gmail.com'))\n        self.assertFalse(is_email('\"\"@gmail.com'))\n        self.assertFalse(is_email('\"no\"pe\"@gmail.com'))"
    },
    {
        "name": "test_with_quoted_string_multiple_at_are_accepted",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_with_quoted_string_multiple_at_are_accepted(self):\n        self.assertTrue(is_email('\"Abc@def\"@example.com'))"
    },
    {
        "name": "test_with_escape_multiple_at_are_accepted",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_with_escape_multiple_at_are_accepted(self):\n        self.assertTrue(is_email('Abc\\\\@def@example.com'))"
    },
    {
        "name": "test_head_can_have_self_escape",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_head_can_have_self_escape(self):\n        self.assertTrue(is_email('Joe.\\\\\\\\Blow@example.com'))"
    },
    {
        "name": "test_return_false_for_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_return_false_for_non_string_objects(self):\n        # noinspection PyTypeChecker\n        self.assertFalse(is_ip_v4(None))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_ip_v4(1))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_ip_v4([]))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_ip_v4({'a': 1}))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_ip_v4(True))"
    },
    {
        "name": "test_ip_cannot_be_blank",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_ip_cannot_be_blank(self):\n        self.assertFalse(is_ip_v4(''))\n        self.assertFalse(is_ip_v4(' '))"
    },
    {
        "name": "test_recognize_ip_strings",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_recognize_ip_strings(self):\n        self.assertTrue(is_ip_v4('127.0.0.1'))\n        self.assertTrue(is_ip_v4('0.0.0.0'))\n        self.assertTrue(is_ip_v4('255.255.10.1'))"
    },
    {
        "name": "test_returns_false_if_ipv4_out_of_range",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_false_if_ipv4_out_of_range(self):\n        self.assertFalse(is_ip_v4('999.200.100.75'))\n        self.assertFalse(is_ip_v4('255.999.100.75'))\n        self.assertFalse(is_ip_v4('255.200.999.75'))\n        self.assertFalse(is_ip_v4('255.200.100.999'))"
    },
    {
        "name": "test_ip_cannot_contain_spaces",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_ip_cannot_contain_spaces(self):\n        self.assertFalse(is_ip_v4(' 127.0.0.1 '))\n        self.assertFalse(is_ip_v4('0.0.0.0 '))\n        self.assertFalse(is_ip_v4(' 255.255.10.1'))\n        self.assertFalse(is_ip_v4('255. 255.10.1'))"
    },
    {
        "name": "test_ip_cannot_have_multiple_dots",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_ip_cannot_have_multiple_dots(self):\n        self.assertFalse(is_ip_v4('127.0.0..1'))\n        self.assertFalse(is_ip_v4('0..0.0.0'))\n        self.assertFalse(is_ip_v4('255.255.10.1.'))"
    },
    {
        "name": "test_numbers_cannot_be_divided_by_other_signs_in_ipv4",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_numbers_cannot_be_divided_by_other_signs_in_ipv4(self):\n        self.assertFalse(is_ip_v4('127:0:0:1'))\n        self.assertFalse(is_ip_v4('127-0-0-1'))\n        self.assertFalse(is_ip_v4('0_0_0_0'))\n        self.assertFalse(is_ip_v4('255,255,10,1'))"
    },
    {
        "name": "test_ip_v6_is_not_recognized",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_ip_v6_is_not_recognized(self):\n        self.assertFalse(is_ip_v4('2001:db8:85a3:0:0:8a2e:370:7334'))"
    },
    {
        "name": "test_return_false_for_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_return_false_for_non_string_objects(self):\n        self.assertFalse(is_string(None))\n        self.assertFalse(is_string(False))\n        self.assertFalse(is_string(0))\n        self.assertFalse(is_string([]))\n        self.assertFalse(is_string({'a': 1}))"
    },
    {
        "name": "test_bytes_sequence_is_ont_considered_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_bytes_sequence_is_ont_considered_string(self):\n        self.assertFalse(is_string(b'nope!'))"
    },
    {
        "name": "test_return_true_for_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_return_true_for_string_objects(self):\n        self.assertTrue(is_string(''))\n        self.assertTrue(is_string('hello world'))\n        self.assertTrue(is_string(r'[a-z]'))"
    },
    {
        "name": "test_raise_exception_if_object_is_not_a_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_raise_exception_if_object_is_not_a_string(self):\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            reverse(None)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"NoneType\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            reverse(False)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"bool\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            reverse(0)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"int\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            reverse([])\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"list\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            reverse({'a': 1})\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"dict\"')"
    },
    {
        "name": "test_returns_original_string_if_unreversible",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_original_string_if_unreversible(self):\n        self.assertEqual(reverse(''), '')\n        self.assertEqual(reverse('x'), 'x')\n        self.assertEqual(reverse('!!!'), '!!!')"
    },
    {
        "name": "test_returns_reversed_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_reversed_string(self):\n        self.assertEqual(reverse('hello world'), 'dlrow olleh')"
    },
    {
        "name": "test_should_return_false_for_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_return_false_for_non_string_objects(self):\n        # noinspection PyTypeChecker\n        self.assertFalse(is_credit_card(None))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_credit_card(False))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_credit_card(0))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_credit_card([]))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_credit_card({'a': 1}))"
    },
    {
        "name": "test_string_cannot_be_empty",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_cannot_be_empty(self):\n        self.assertFalse(is_credit_card(''))\n        self.assertFalse(is_credit_card(' '))"
    },
    {
        "name": "test_string_cannot_contain_letters",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_cannot_contain_letters(self):\n        self.assertFalse(is_credit_card('not a credit card for sure'))"
    },
    {
        "name": "test_numbers_in_string_should_be_15_at_least",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_numbers_in_string_should_be_15_at_least(self):\n        self.assertFalse(is_credit_card('1' * 14))"
    },
    {
        "name": "test_should_accept_any_valid_card_number_if_type_is_not_specified",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_accept_any_valid_card_number_if_type_is_not_specified(self):\n        for card_type in self.sample_cards:\n            for card_number in self.sample_cards[card_type]:\n                self.assertTrue(is_credit_card(card_number), 'Invalid card: %s (%s)' % (card_number, card_type))"
    },
    {
        "name": "test_should_validate_only_specific_card_type_if_specified",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_validate_only_specific_card_type_if_specified(self):\n        for card_type in self.sample_cards:\n            for card_number in self.sample_cards[card_type]:\n                self.assertTrue(\n                    is_credit_card(card_number, card_type=card_type),\n                    'Invalid card: %s (%s)' % (card_number, card_type)\n                )\n                other_cards = self.sample_cards.copy()\n                del other_cards[card_type]\n                for other_card in other_cards:\n                    self.assertFalse(\n                        is_credit_card(card_number, card_type=other_card),\n                        'Card %s should not be a valid %s' % (card_number, other_card)\n                    )"
    },
    {
        "name": "test_cannot_provide_unsupported_card_type",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_cannot_provide_unsupported_card_type(self):\n        self.assertRaises(KeyError, lambda: is_credit_card(self.sample_cards['VISA'][0], card_type='FOO_CARD'))"
    },
    {
        "name": "test_cannot_handle_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_cannot_handle_non_string_objects(self):\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            prettify(None)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"NoneType\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            prettify(False)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"bool\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            prettify(0)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"int\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            prettify([])\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"list\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            prettify({'a': 1})\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"dict\"')"
    },
    {
        "name": "test_should_return_empty_string_from_empty_string_or_space_only_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_return_empty_string_from_empty_string_or_space_only_string(self):\n        self.assertEqual('', prettify(''))\n        self.assertEqual('', prettify(' '))"
    },
    {
        "name": "test_should_uppercase_first_letter",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_uppercase_first_letter(self):\n        self.assertEqual('Hello world', prettify('hello world'))"
    },
    {
        "name": "test_should_strip_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_strip_string(self):\n        self.assertEqual('Hello world', prettify(' hello world '))"
    },
    {
        "name": "test_should_strip_empty_lines",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_strip_empty_lines(self):\n        self.assertEqual('Hello world', prettify('''\n\n            hello world\n\n        '''))"
    },
    {
        "name": "test_should_replace_multiple_brackets_with_single_ones",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_replace_multiple_brackets_with_single_ones(self):\n        self.assertEqual('(foo)', prettify('((foo)'))\n        self.assertEqual('(foo)', prettify('(foo))'))\n        self.assertEqual('(foo)', prettify('((foo))'))\n        self.assertEqual('(foo)', prettify('((((((((foo)))'))\n        self.assertEqual('[foo]', prettify('[[foo]'))\n        self.assertEqual('[foo]', prettify('[foo]]'))\n        self.assertEqual('[foo]', prettify('[[foo]]'))\n        self.assertEqual('[foo]', prettify('[[[[[[[[foo]]]'))\n        self.assertEqual('{foo}', prettify('{{foo}'))\n        self.assertEqual('{foo}', prettify('{foo}}'))\n        self.assertEqual('{foo}', prettify('{{foo}}'))\n        self.assertEqual('{foo}', prettify('{{{{{{{{foo}}}'))"
    },
    {
        "name": "test_should_remove_internal_spaces_in_brackets",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_remove_internal_spaces_in_brackets(self):\n        self.assertEqual('(foo)', prettify('( foo)'))\n        self.assertEqual('(foo)', prettify('(foo )'))\n        self.assertEqual('(foo)', prettify('( foo )'))"
    },
    {
        "name": "test_should_add_spaces_outside_brackets",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_add_spaces_outside_brackets(self):\n        self.assertEqual('Boo (bar) baz', prettify('boo(bar)baz'))"
    },
    {
        "name": "test_should_not_add_right_space_after_bracket_if_followed_by_punctuation",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_not_add_right_space_after_bracket_if_followed_by_punctuation(self):\n        self.assertEqual('Foo (bar)? Yes!', prettify('Foo(bar)? Yes!'))\n        self.assertEqual('Foo (bar): Yes!', prettify('Foo(bar): Yes!'))\n        self.assertEqual('Foo (bar). Yes!', prettify('Foo(bar). Yes!'))\n        self.assertEqual('Foo (bar); yes!', prettify('Foo(bar); yes!'))\n        self.assertEqual('Foo (bar), yes!', prettify('Foo(bar), yes!'))"
    },
    {
        "name": "test_should_replace_multiple_commas_with_single_ones",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_replace_multiple_commas_with_single_ones(self):\n        self.assertEqual('Hello, world', prettify('Hello,,, world'))\n        self.assertEqual('Hello, world, banana', prettify('Hello,,, world,, banana'))"
    },
    {
        "name": "test_should_replace_multiple_colons_with_single_ones",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_replace_multiple_colons_with_single_ones(self):\n        self.assertEqual('Hello: world', prettify('Hello::: world'))\n        self.assertEqual('Hello: world: banana', prettify('Hello::: world:: banana'))"
    },
    {
        "name": "test_should_replace_multiple_semicolons_with_single_ones",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_replace_multiple_semicolons_with_single_ones(self):\n        self.assertEqual('Hello; world', prettify('Hello;;; world'))\n        self.assertEqual('Hello; world; banana', prettify('Hello;;; world;; banana'))"
    },
    {
        "name": "test_should_replace_multiple_double_quotes_with_single_ones",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_replace_multiple_double_quotes_with_single_ones(self):\n        self.assertEqual('\"hello\" world', prettify('\"\"hello\"\" world'))\n        self.assertEqual('\"hello\" world', prettify('\"\"hello\" world'))\n        self.assertEqual('\"hello\" world', prettify('\"hello\"\" world'))\n        self.assertEqual('\"hello\" world', prettify('\"\"\"\"\"\"hello\"\"\"\"\" world'))"
    },
    {
        "name": "test_should_add_spaces_for_double_quotes",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_add_spaces_for_double_quotes(self):\n        self.assertEqual('Foo \"bar\" baz', prettify('foo\"bar\"baz'))\n        self.assertEqual('Foo \"bar\" baz', prettify('foo\"bar\" baz'))\n        self.assertEqual('Foo \"bar\" baz', prettify('foo \"bar\"baz'))"
    },
    {
        "name": "test_should_trim_spaces_inside_double_quotes",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_trim_spaces_inside_double_quotes(self):\n        self.assertEqual('Foo \"bar\" baz', prettify('foo \" bar \" baz'))\n        self.assertEqual('Foo \"bar\" baz', prettify('foo \"bar \" baz'))\n        self.assertEqual('Foo \"bar\" baz', prettify('foo \" bar\" baz'))"
    },
    {
        "name": "test_should_not_add_right_space_after_double_quotes_if_followed_by_punctuation",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_not_add_right_space_after_double_quotes_if_followed_by_punctuation(self):\n        self.assertEqual('Foo \"bar\"? Yes!', prettify('Foo\"bar\"? Yes!'))\n        self.assertEqual('Foo \"bar\": Yes!', prettify('Foo\"bar\": Yes!'))\n        self.assertEqual('Foo \"bar\". Yes!', prettify('Foo\"bar\". Yes!'))\n        self.assertEqual('Foo \"bar\"; yes!', prettify('Foo\"bar\"; yes!'))\n        self.assertEqual('Foo \"bar\", yes!', prettify('Foo\"bar\", yes!'))"
    },
    {
        "name": "test_should_replace_multiple_single_quotes_with_single_ones",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_replace_multiple_single_quotes_with_single_ones(self):\n        self.assertEqual('Dave\\'s job', prettify(\"Dave''s job\"))\n        self.assertEqual(\"'destiny'\", prettify(\"'''destiny'''\"))"
    },
    {
        "name": "test_should_fix_saxon_genitive_spaces",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_fix_saxon_genitive_spaces(self):\n        self.assertEqual(\"Dave's dog\", prettify(\"Dave' s dog\"))\n        self.assertEqual(\"Dave's dog\", prettify(\"Dave 's dog\"))\n        self.assertEqual(\"Dave's dog\", prettify(\"Dave 'sdog\"))"
    },
    {
        "name": "test_should_replace_multiple_percentage_with_single_ones",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_replace_multiple_percentage_with_single_ones(self):\n        self.assertEqual('%', prettify('%%%'))\n        self.assertEqual('A % b % c', prettify('a %% b %%%%%% c'))"
    },
    {
        "name": "test_should_add_space_after_comma_if_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_add_space_after_comma_if_missing(self):\n        self.assertEqual('One, two, three', prettify('one,two,three'))"
    },
    {
        "name": "test_should_not_add_right_space_after_dot_for_numbers",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_not_add_right_space_after_dot_for_numbers(self):\n        self.assertEqual('12,55', prettify('12,55'))"
    },
    {
        "name": "test_should_remove_space_before_comma",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_remove_space_before_comma(self):\n        self.assertEqual('One, two, three', prettify('one , two , three'))"
    },
    {
        "name": "test_should_uppercase_first_letter_after_period",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_uppercase_first_letter_after_period(self):\n        self.assertEqual('Foo. Bar', prettify('Foo. bar'))"
    },
    {
        "name": "test_should_add_space_after_period_if_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_add_space_after_period_if_missing(self):\n        self.assertEqual('One. Two. Three', prettify('one.two.three'))"
    },
    {
        "name": "test_should_not_add_right_space_after_comma_for_numbers",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_not_add_right_space_after_comma_for_numbers(self):\n        self.assertEqual('12.55', prettify('12.55'))"
    },
    {
        "name": "test_should_remove_space_before_period",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_remove_space_before_period(self):\n        self.assertEqual('One. Two. Three', prettify('one . two . three'))"
    },
    {
        "name": "test_should_add_space_after_colon_if_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_add_space_after_colon_if_missing(self):\n        self.assertEqual('Test: this', prettify('Test:this'))"
    },
    {
        "name": "test_should_remove_space_before_colon",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_remove_space_before_colon(self):\n        self.assertEqual('Test: this', prettify('Test :this'))\n        self.assertEqual('Test:', prettify('Test :'))"
    },
    {
        "name": "test_should_add_space_after_semicolon_if_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_add_space_after_semicolon_if_missing(self):\n        self.assertEqual('Test; this', prettify('Test;this'))"
    },
    {
        "name": "test_should_remove_space_before_semicolon",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_remove_space_before_semicolon(self):\n        self.assertEqual('Test; this', prettify('Test ;this'))\n        self.assertEqual('Test;', prettify('Test ;'))"
    },
    {
        "name": "test_should_uppercase_first_letter_after_exclamation",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_uppercase_first_letter_after_exclamation(self):\n        self.assertEqual('Foo! Bar', prettify('Foo! bar'))"
    },
    {
        "name": "test_should_add_space_after_exclamation_if_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_add_space_after_exclamation_if_missing(self):\n        self.assertEqual('Test! This', prettify('Test!this'))"
    },
    {
        "name": "test_should_remove_space_before_exclamation",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_remove_space_before_exclamation(self):\n        self.assertEqual('Test! This', prettify('Test !this'))\n        self.assertEqual('Test!', prettify('Test !'))"
    },
    {
        "name": "test_should_uppercase_first_letter_after_question",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_uppercase_first_letter_after_question(self):\n        self.assertEqual('Foo? Bar', prettify('Foo? bar'))"
    },
    {
        "name": "test_should_add_space_after_question_if_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_add_space_after_question_if_missing(self):\n        self.assertEqual('Test? This', prettify('Test?this'))"
    },
    {
        "name": "test_should_remove_space_before_question",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_remove_space_before_question(self):\n        self.assertEqual('Test? This', prettify('Test ?this'))\n        self.assertEqual('Test?', prettify('Test ?'))"
    },
    {
        "name": "test_should_remove_space_before_dot",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_remove_space_before_dot(self):\n        self.assertEqual('Test. This', prettify('Test . This'))\n        self.assertEqual('Test.', prettify('Test .'))"
    },
    {
        "name": "test_should_remove_space_after_number_if_followed_by_percentage",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_remove_space_after_number_if_followed_by_percentage(self):\n        self.assertEqual('100% python', prettify('100 % python'))\n        self.assertEqual('100%', prettify('100 %'))"
    },
    {
        "name": "test_should_add_space_after_percentage_if_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_add_space_after_percentage_if_missing(self):\n        self.assertEqual('100% python code', prettify('100%python code'))"
    },
    {
        "name": "test_should_add_spaces_around_plus_if_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_add_spaces_around_plus_if_missing(self):\n        self.assertEqual('5 + 2', prettify('5 +2'))\n        self.assertEqual('5 + 2', prettify('5+ 2'))\n        self.assertEqual('5 + 2', prettify('5+2'))"
    },
    {
        "name": "test_should_add_spaces_around_minus_if_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_add_spaces_around_minus_if_missing(self):\n        self.assertEqual('5 - 2', prettify('5 -2'))\n        self.assertEqual('5 - 2', prettify('5- 2'))\n        self.assertEqual('5 - 2', prettify('5-2'))"
    },
    {
        "name": "test_should_add_spaces_around_equal_if_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_add_spaces_around_equal_if_missing(self):\n        self.assertEqual('5 - 2 = 3', prettify('5 - 2=3'))\n        self.assertEqual('5 - 2 = 3', prettify('5 - 2 =3'))\n        self.assertEqual('5 - 2 = 3', prettify('5 - 2= 3'))"
    },
    {
        "name": "test_should_add_spaces_around_division_if_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_add_spaces_around_division_if_missing(self):\n        self.assertEqual('5 / 2 = 2.5', prettify('5/ 2 = 2.5'))\n        self.assertEqual('5 / 2 = 2.5', prettify('5 /2 = 2.5'))\n        self.assertEqual('5 / 2 = 2.5', prettify('5/2 = 2.5'))"
    },
    {
        "name": "test_should_add_spaces_around_multiplication_if_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_add_spaces_around_multiplication_if_missing(self):\n        self.assertEqual('5 * 2 = 10', prettify('5* 2 = 10'))\n        self.assertEqual('5 * 2 = 10', prettify('5 *2 = 10'))\n        self.assertEqual('5 * 2 = 10', prettify('5*2 = 10'))"
    },
    {
        "name": "test_triple_dot_preserved",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_triple_dot_preserved(self):\n        self.assertEqual('Test...', prettify('Test...'))\n        self.assertEqual('Test... This', prettify('Test...This'))"
    },
    {
        "name": "test_triple_exclamation_preserved",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_triple_exclamation_preserved(self):\n        self.assertEqual('Test!!!', prettify('Test!!!'))\n        self.assertEqual('Test!!! This', prettify('Test!!!This'))"
    },
    {
        "name": "test_triple_question_preserved",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_triple_question_preserved(self):\n        self.assertEqual('Test???', prettify('Test???'))\n        self.assertEqual('Test??? This', prettify('Test???This'))"
    },
    {
        "name": "test_should_prettify_string_as_expected",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_prettify_string_as_expected(self):\n        original = ' unprettified string ,, like this one,will be\"prettified\" .it\\' s awesome!( like python)) '\n        pretty = 'Unprettified string, like this one, will be \"prettified\". It\\'s awesome! (like python)'\n        self.assertEqual(pretty, prettify(original))"
    },
    {
        "name": "test_should_work_as_expected_for_multiple_lines_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_work_as_expected_for_multiple_lines_string(self):\n        original = '''\n\n        unprettified string ,,\n\n        like this one,will be\"prettified\"\n\n        .it' s awesome!( like python))\n\n        '''\n        pretty = 'Unprettified string, like this one, will be \"prettified\". It\\'s awesome! (like python)'\n        self.assertEqual(pretty, prettify(original))"
    },
    {
        "name": "test_does_not_try_to_format_email",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_does_not_try_to_format_email(self):\n        email = 'my.email_name@gmail.com'\n        self.assertTrue(is_email(email))\n        self.assertEqual(email, prettify(email))\n        self.assertEqual('This is the email: {}'.format(email), prettify('this is the email : {}'.format(email)))\n\n        multiple_emails = ['mail.one@gmail.com', 'mail.two@gmail.com', 'mail.three@gmail.com']\n        self.assertEqual(prettify(','.join(multiple_emails)), ', '.join(multiple_emails))"
    },
    {
        "name": "test_does_not_try_to_format_url",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_does_not_try_to_format_url(self):\n        url = 'https://www.mysite.com/path/page.php?query=foo'\n        self.assertEqual(url, prettify(url))\n        self.assertEqual('This is the url: {}'.format(url), prettify('this is the url : {}'.format(url)))\n\n        multiple_urls = ['http://www.site1.com', 'http://foo.com', 'https://www.something.it']\n        self.assertEqual(prettify(','.join(multiple_urls)), ', '.join(multiple_urls))"
    },
    {
        "name": "test_does_not_try_to_format_ip",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_does_not_try_to_format_ip(self):\n        ip = '127.0.0.1'\n        self.assertEqual(ip, prettify(ip))\n        self.assertEqual('This is the ip: {}'.format(ip), prettify('this is the ip : {}'.format(ip)))\n\n        multiple_ip = ['255.255.10.1', '255.255.10.2', '255.255.10.3']\n        self.assertEqual(prettify(' '.join(multiple_ip)), ' '.join(multiple_ip))"
    },
    {
        "name": "test_non_string_objects_return_false",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_non_string_objects_return_false(self):\n        # noinspection PyTypeChecker\n        self.assertFalse(is_palindrome(1))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_palindrome(['xx']))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_palindrome({}))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_palindrome(False))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_palindrome((1, 2, 3)))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_palindrome(object()))"
    },
    {
        "name": "test_empty_strings_are_not_palindromes",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_empty_strings_are_not_palindromes(self):\n        self.assertFalse(is_palindrome(''))\n        self.assertFalse(is_palindrome(' '))\n        self.assertFalse(is_palindrome('\\n\\t\\n'))"
    },
    {
        "name": "test_returns_true_if_palindrome_with_default_options",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_true_if_palindrome_with_default_options(self):\n        self.assertTrue(is_palindrome('LOL'))\n        self.assertTrue(is_palindrome('otto'))"
    },
    {
        "name": "test_returns_false_if_not_palindrome_with_default_options",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_false_if_not_palindrome_with_default_options(self):\n        self.assertFalse(is_palindrome('nope!'))\n        self.assertFalse(is_palindrome('ROTFL'))"
    },
    {
        "name": "test_if_not_specified_case_matters",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_if_not_specified_case_matters(self):\n        self.assertFalse(is_palindrome('Lol'))\n        self.assertTrue(is_palindrome('Lol', ignore_case=True))"
    },
    {
        "name": "test_if_not_specified_spaces_matter",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_if_not_specified_spaces_matter(self):\n        self.assertFalse(is_palindrome('i topi non avevano nipoti'))\n        self.assertTrue(is_palindrome('i topi non avevano nipoti', ignore_spaces=True))"
    },
    {
        "name": "test_requires_valid_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_requires_valid_string(self):\n        # noinspection PyTypeChecker\n        self.assertRaises(InvalidInputError, lambda: is_isbn_13(None))\n\n        # noinspection PyTypeChecker\n        self.assertRaises(InvalidInputError, lambda: is_isbn_13(True))\n\n        # noinspection PyTypeChecker\n        self.assertRaises(InvalidInputError, lambda: is_isbn_13(9780312498580))\n\n        # noinspection PyTypeChecker\n        self.assertRaises(InvalidInputError, lambda: is_isbn_13([9780312498580]))"
    },
    {
        "name": "test_returns_true_for_valid_isbn_13",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_true_for_valid_isbn_13(self):\n        # isbn numbers have been taken from actual books on amazon\n        self.assertTrue(is_isbn_13('9780312498580'))\n        self.assertTrue(is_isbn_13('9781941325827'))\n        self.assertTrue(is_isbn_13('9780062853851'))\n        self.assertTrue(is_isbn_13('9781250107817'))\n        self.assertTrue(is_isbn_13('9788891229243'))"
    },
    {
        "name": "test_dashes_are_not_considered_by_default",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_dashes_are_not_considered_by_default(self):\n        # isbn numbers have been taken from actual books on amazon\n        self.assertTrue(is_isbn_13('978-0312498580'))\n        self.assertTrue(is_isbn_13('978-194-132-582-7'))\n        self.assertTrue(is_isbn_13('978-0-0-6-2-8-5-3-8-5-1'))"
    },
    {
        "name": "test_isbn_not_recognized_if_normalization_is_disabled",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_isbn_not_recognized_if_normalization_is_disabled(self):\n        # isbn numbers have been taken from actual books on amazon\n        self.assertFalse(is_isbn_13('978-0312498580', normalize=False))\n        self.assertFalse(is_isbn_13('978-194-132-582-7', normalize=False))\n        self.assertFalse(is_isbn_13('978-0-0-6-2-8-5-3-8-5-1', normalize=False))"
    },
    {
        "name": "test_returns_false_if_isbn_10",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_false_if_isbn_10(self):\n        # isbn numbers have been taken from actual books on amazon\n        self.assertFalse(is_isbn_13('8891229245'))"
    },
    {
        "name": "test_returns_false_if_not_isbn",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_false_if_not_isbn(self):\n        self.assertFalse(is_isbn_13('9780312498580!'))\n        self.assertFalse(is_isbn_13(' 9780312498580'))\n        self.assertFalse(is_isbn_13('x9780312498580'))\n        self.assertFalse(is_isbn_13('x' * 13))\n        self.assertFalse(is_isbn_13(''))"
    },
    {
        "name": "test_decode_throws_input_error_if_input_is_not_a_string_or_is_empty",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_decode_throws_input_error_if_input_is_not_a_string_or_is_empty(self):\n        # noinspection PyTypeChecker\n        self.assertRaises(ValueError, lambda: roman_decode(None))\n\n        # noinspection PyTypeChecker\n        self.assertRaises(ValueError, lambda: roman_decode(42))\n\n        # noinspection PyTypeChecker\n        self.assertRaises(ValueError, lambda: roman_decode(True))\n\n        self.assertRaises(ValueError, lambda: roman_decode(''))\n        self.assertRaises(ValueError, lambda: roman_decode(' '))"
    },
    {
        "name": "test_units_are_decoded_as_expected",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_units_are_decoded_as_expected(self):\n        self.assertEqual(roman_decode('I'), 1)\n        self.assertEqual(roman_decode('II'), 2)\n        self.assertEqual(roman_decode('III'), 3)\n        self.assertEqual(roman_decode('IV'), 4)\n        self.assertEqual(roman_decode('V'), 5)\n        self.assertEqual(roman_decode('VI'), 6)\n        self.assertEqual(roman_decode('VII'), 7)\n        self.assertEqual(roman_decode('VIII'), 8)\n        self.assertEqual(roman_decode('IX'), 9)"
    },
    {
        "name": "test_tens_are_decoded_as_expected",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tens_are_decoded_as_expected(self):\n        self.assertEqual(roman_decode('X'), 10)\n        self.assertEqual(roman_decode('XX'), 20)\n        self.assertEqual(roman_decode('XXX'), 30)\n        self.assertEqual(roman_decode('XL'), 40)\n        self.assertEqual(roman_decode('L'), 50)\n        self.assertEqual(roman_decode('LX'), 60)\n        self.assertEqual(roman_decode('LXX'), 70)\n        self.assertEqual(roman_decode('LXXX'), 80)\n        self.assertEqual(roman_decode('XC'), 90)"
    },
    {
        "name": "test_tens_and_units_are_decoded_as_expected",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tens_and_units_are_decoded_as_expected(self):\n        # 1x\n        self.assertEqual(11, roman_decode('XI'))\n        self.assertEqual(12, roman_decode('XII'))\n        self.assertEqual(13, roman_decode('XIII'))\n        self.assertEqual(14, roman_decode('XIV'))\n        self.assertEqual(15, roman_decode('XV'))\n        self.assertEqual(16, roman_decode('XVI'))\n        self.assertEqual(17, roman_decode('XVII'))\n        self.assertEqual(18, roman_decode('XVIII'))\n        self.assertEqual(19, roman_decode('XIX'))\n\n        # 2x\n        self.assertEqual(21, roman_decode('XXI'))\n        self.assertEqual(22, roman_decode('XXII'))\n        self.assertEqual(23, roman_decode('XXIII'))\n        self.assertEqual(24, roman_decode('XXIV'))\n        self.assertEqual(25, roman_decode('XXV'))\n        self.assertEqual(26, roman_decode('XXVI'))\n        self.assertEqual(27, roman_decode('XXVII'))\n        self.assertEqual(28, roman_decode('XXVIII'))\n        self.assertEqual(29, roman_decode('XXIX'))\n\n        # 3x\n        self.assertEqual(31, roman_decode('XXXI'))\n        self.assertEqual(32, roman_decode('XXXII'))\n        self.assertEqual(33, roman_decode('XXXIII'))\n        self.assertEqual(34, roman_decode('XXXIV'))\n        self.assertEqual(35, roman_decode('XXXV'))\n        self.assertEqual(36, roman_decode('XXXVI'))\n        self.assertEqual(37, roman_decode('XXXVII'))\n        self.assertEqual(38, roman_decode('XXXVIII'))\n        self.assertEqual(39, roman_decode('XXXIX'))\n\n        # 4x\n        self.assertEqual(41, roman_decode('XLI'))\n        self.assertEqual(42, roman_decode('XLII'))\n        self.assertEqual(43, roman_decode('XLIII'))\n        self.assertEqual(44, roman_decode('XLIV'))\n        self.assertEqual(45, roman_decode('XLV'))\n        self.assertEqual(46, roman_decode('XLVI'))\n        self.assertEqual(47, roman_decode('XLVII'))\n        self.assertEqual(48, roman_decode('XLVIII'))\n        self.assertEqual(49, roman_decode('XLIX'))\n\n        # 5x\n        self.assertEqual(51, roman_decode('LI'))\n        self.assertEqual(52, roman_decode('LII'))\n        self.assertEqual(53, roman_decode('LIII'))\n        self.assertEqual(54, roman_decode('LIV'))\n        self.assertEqual(55, roman_decode('LV'))\n        self.assertEqual(56, roman_decode('LVI'))\n        self.assertEqual(57, roman_decode('LVII'))\n        self.assertEqual(58, roman_decode('LVIII'))\n        self.assertEqual(59, roman_decode('LIX'))\n\n        # 6x\n        self.assertEqual(61, roman_decode('LXI'))\n        self.assertEqual(62, roman_decode('LXII'))\n        self.assertEqual(63, roman_decode('LXIII'))\n        self.assertEqual(64, roman_decode('LXIV'))\n        self.assertEqual(65, roman_decode('LXV'))\n        self.assertEqual(66, roman_decode('LXVI'))\n        self.assertEqual(67, roman_decode('LXVII'))\n        self.assertEqual(68, roman_decode('LXVIII'))\n        self.assertEqual(69, roman_decode('LXIX'))\n\n        # 7x\n        self.assertEqual(71, roman_decode('LXXI'))\n        self.assertEqual(72, roman_decode('LXXII'))\n        self.assertEqual(73, roman_decode('LXXIII'))\n        self.assertEqual(74, roman_decode('LXXIV'))\n        self.assertEqual(75, roman_decode('LXXV'))\n        self.assertEqual(76, roman_decode('LXXVI'))\n        self.assertEqual(77, roman_decode('LXXVII'))\n        self.assertEqual(78, roman_decode('LXXVIII'))\n        self.assertEqual(79, roman_decode('LXXIX'))\n\n        # 8x\n        self.assertEqual(81, roman_decode('LXXXI'))\n        self.assertEqual(82, roman_decode('LXXXII'))\n        self.assertEqual(83, roman_decode('LXXXIII'))\n        self.assertEqual(84, roman_decode('LXXXIV'))\n        self.assertEqual(85, roman_decode('LXXXV'))\n        self.assertEqual(86, roman_decode('LXXXVI'))\n        self.assertEqual(87, roman_decode('LXXXVII'))\n        self.assertEqual(88, roman_decode('LXXXVIII'))\n        self.assertEqual(89, roman_decode('LXXXIX'))\n\n        # 9x\n        self.assertEqual(91, roman_decode('XCI'))\n        self.assertEqual(92, roman_decode('XCII'))\n        self.assertEqual(93, roman_decode('XCIII'))\n        self.assertEqual(94, roman_decode('XCIV'))\n        self.assertEqual(95, roman_decode('XCV'))\n        self.assertEqual(96, roman_decode('XCVI'))\n        self.assertEqual(97, roman_decode('XCVII'))\n        self.assertEqual(98, roman_decode('XCVIII'))\n        self.assertEqual(99, roman_decode('XCIX'))"
    },
    {
        "name": "test_hundreds_are_decoded_as_expected",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_hundreds_are_decoded_as_expected(self):\n        self.assertEqual(100, roman_decode('C'))\n        self.assertEqual(200, roman_decode('CC'))\n        self.assertEqual(300, roman_decode('CCC'))\n        self.assertEqual(400, roman_decode('CD'))\n        self.assertEqual(500, roman_decode('D'))\n        self.assertEqual(600, roman_decode('DC'))\n        self.assertEqual(700, roman_decode('DCC'))\n        self.assertEqual(800, roman_decode('DCCC'))\n        self.assertEqual(900, roman_decode('CM'))"
    },
    {
        "name": "test_thousands_are_decoded_as_expected",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_thousands_are_decoded_as_expected(self):\n        self.assertEqual(1000, roman_decode('M'))\n        self.assertEqual(2000, roman_decode('MM'))\n        self.assertEqual(3000, roman_decode('MMM'))"
    },
    {
        "name": "test_combined_numbers_decode",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_combined_numbers_decode(self):\n        self.assertEqual(3001, roman_decode('MMMI'))\n        self.assertEqual(3090, roman_decode('MMMXC'))\n        self.assertEqual(1200, roman_decode('MCC'))\n        self.assertEqual(2739, roman_decode('MMDCCXXXIX'))\n        self.assertEqual(3999, roman_decode('MMMCMXCIX'))"
    },
    {
        "name": "test_decode_raise_exception_for_unexpected_sign",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_decode_raise_exception_for_unexpected_sign(self):\n        with self.assertRaises(ValueError) as raised:\n            roman_decode('wtf?')\n\n        self.assertEqual(str(raised.exception), 'Invalid token found: \"?\"')\n\n        with self.assertRaises(ValueError) as raised:\n            roman_decode('OK')\n\n        self.assertEqual(str(raised.exception), 'Invalid token found: \"K\"')\n\n        with self.assertRaises(ValueError) as raised:\n            roman_decode('QMMMCMXCIX')\n\n        self.assertEqual(str(raised.exception), 'Invalid token found: \"Q\"')"
    },
    {
        "name": "test_decode_does_not_care_about_case",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_decode_does_not_care_about_case(self):\n        self.assertEqual(3, roman_decode('iii'))\n        self.assertEqual(30, roman_decode('xxx'))\n        self.assertEqual(82, roman_decode('lxxxii'))\n        self.assertEqual(roman_decode('VII'), roman_decode('vii'))\n        self.assertEqual(roman_decode('VII'), roman_decode('Vii'))"
    },
    {
        "name": "test_throws_error_if_size_is_null",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_throws_error_if_size_is_null(self):\n        with self.assertRaises(ValueError) as raised:\n            # noinspection PyTypeChecker\n            secure_random_hex(None)\n\n        self.assertEqual(str(raised.exception), 'byte_count must be >= 1')"
    },
    {
        "name": "test_throws_error_if_size_is_less_than_1",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_throws_error_if_size_is_less_than_1(self):\n        msg = 'byte_count must be >= 1'\n\n        with self.assertRaises(ValueError) as raised:\n            secure_random_hex(-12)\n\n        self.assertEqual(str(raised.exception), msg)\n\n        with self.assertRaises(ValueError) as raised:\n            secure_random_hex(0)\n\n        self.assertEqual(str(raised.exception), msg)"
    },
    {
        "name": "test_returns_random_hex",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_random_hex(self):\n        sr = secure_random_hex(9)\n        self.assertEqual(len(sr), 18)\n        self.assertTrue(sr.isalnum())"
    },
    {
        "name": "test_returns_different_string_on_each_call",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_different_string_on_each_call(self):\n        strings = [secure_random_hex(12) for _ in range(1000)]\n\n        self.assertEqual(len(strings), len(set(strings)))"
    },
    {
        "name": "test_cannot_handle_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_cannot_handle_non_string_objects(self):\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            is_integer(None)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"NoneType\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            is_integer(False)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"bool\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            is_integer(0)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"int\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            is_integer([])\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"list\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            is_integer({'a': 1})\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"dict\"')"
    },
    {
        "name": "test_returns_true_for_unsigned_integers",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_true_for_unsigned_integers(self):\n        self.assertTrue(is_integer('1'))\n        self.assertTrue(is_integer('42'))\n        self.assertTrue(is_integer('1e3'))"
    },
    {
        "name": "test_returns_true_for_signed_integers",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_true_for_signed_integers(self):\n        self.assertTrue(is_integer('+1'))\n        self.assertTrue(is_integer('+42'))\n        self.assertTrue(is_integer('+1e3'))\n\n        self.assertTrue(is_integer('-1'))\n        self.assertTrue(is_integer('-42'))\n        self.assertTrue(is_integer('-1e3'))"
    },
    {
        "name": "test_returns_false_for_decimals",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_false_for_decimals(self):\n        self.assertFalse(is_integer('1.1'))\n        self.assertFalse(is_integer('42.1'))\n        self.assertFalse(is_integer('1.1e3'))"
    },
    {
        "name": "test_returns_false_for_string_that_are_not_numbers",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_false_for_string_that_are_not_numbers(self):\n        self.assertFalse(is_integer('no'))\n        self.assertFalse(is_integer('a1'))\n        self.assertFalse(is_integer('ten'))\n        self.assertFalse(is_integer('beast666'))"
    },
    {
        "name": "test_non_string_objects_are_properly_handled",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_non_string_objects_are_properly_handled(self):\n        # noinspection PyTypeChecker\n        self.assertFalse(is_json({'a': 1}))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_json(None))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_json([1, 2, 3]))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_json(500))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_json(True))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_json({1, 2}))"
    },
    {
        "name": "test_empty_string_are_invalid",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_empty_string_are_invalid(self):\n        self.assertFalse(is_json(''))\n        self.assertFalse(is_json(' '))"
    },
    {
        "name": "test_json_object_can_be_empty",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_json_object_can_be_empty(self):\n        self.assertTrue(is_json('{}'))"
    },
    {
        "name": "test_json_array_can_be_empty",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_json_array_can_be_empty(self):\n        self.assertTrue(is_json('[]'))"
    },
    {
        "name": "test_external_spaces_are_ignored",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_external_spaces_are_ignored(self):\n        self.assertTrue(is_json('{\"foo\":\"bar\"}'))\n        self.assertTrue(is_json(' { \"foo\": \"bar\" } '))\n        self.assertTrue(is_json('''\n            {\n                \"foo\": \"bar\"\n            }\n        '''))\n        self.assertTrue(is_json('''\n        [\n            1, 2, 3\n        ]\n        '''))"
    },
    {
        "name": "test_attributes_quotes_are_mandatory",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_attributes_quotes_are_mandatory(self):\n        self.assertFalse(is_json('{foo: 1}'))"
    },
    {
        "name": "test_quotes_should_be_double_quotes",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_quotes_should_be_double_quotes(self):\n        self.assertFalse(is_json(\"{'foo': 1}\"))\n        self.assertFalse(is_json(\"['boo', 'bar']\"))"
    },
    {
        "name": "test_string_values_should_be_wrapped_by_double_quotes",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_values_should_be_wrapped_by_double_quotes(self):\n        self.assertFalse(is_json('{\"foo\": hello}'))\n        self.assertFalse(is_json('{\"foo\": \\'hello\\'}'))\n        self.assertTrue(is_json('{\"foo\": \"hello\"}'))"
    },
    {
        "name": "test_boolean_should_be_lowercase",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_boolean_should_be_lowercase(self):\n        self.assertFalse(is_json('{\"bool\": True}'))\n        self.assertFalse(is_json('{\"bool\": FALSE}'))\n        self.assertTrue(is_json('{\"bool\": true}'))\n        self.assertIsInstance(json.loads('{\"bool\": true}'), dict)\n        self.assertTrue(is_json('{\"bool\": false}'))\n        self.assertIsInstance(json.loads('{\"bool\": false}'), dict)"
    },
    {
        "name": "test_null_should_be_lowercase",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_null_should_be_lowercase(self):\n        self.assertFalse(is_json('{\"null\": NULL}'))\n        self.assertFalse(is_json('{\"null\": Null}'))\n        self.assertTrue(is_json('{\"null\": null}'))\n        self.assertIsInstance(json.loads('{\"null\": null}'), dict)"
    },
    {
        "name": "test_int_number_can_be_any_length",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_int_number_can_be_any_length(self):\n        self.assertTrue(is_json('{\"number\": 1}'))\n        self.assertTrue(is_json('{\"number\": 99}'))\n        self.assertTrue(is_json('{\"number\": 1000}'))\n        self.assertTrue(is_json('{\"number\": 1234567890}'))"
    },
    {
        "name": "test_float_numbers_should_use_dot_as_separator",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_float_numbers_should_use_dot_as_separator(self):\n        self.assertFalse(is_json('{\"float\": 4,5}'))\n        self.assertTrue(is_json('{\"float\": 4.5}'))\n        self.assertIsInstance(json.loads('{\"float\": 4.5}'), dict)"
    },
    {
        "name": "test_negative_numbers_should_be_start_with_minus",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_negative_numbers_should_be_start_with_minus(self):\n        self.assertFalse(is_json('{\"number\": - 2}'))\n        self.assertFalse(is_json('{\"number\": - 2.5}'))\n        self.assertTrue(is_json('{\"number\": -2}'))\n        self.assertTrue(is_json('{\"number\": -2.5}'))"
    },
    {
        "name": "test_array_can_be_empty",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_array_can_be_empty(self):\n        self.assertTrue(is_json('{\"array\": []}'))\n        self.assertTrue(is_json('{\"array\": [ ]}'))"
    },
    {
        "name": "test_object_can_be_empty",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_object_can_be_empty(self):\n        self.assertTrue(is_json('{\"obj\": {}}'))\n        self.assertTrue(is_json('{\"obj\": { }}'))"
    },
    {
        "name": "test_cannot_have_trailing_comma_in_array",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_cannot_have_trailing_comma_in_array(self):\n        self.assertFalse(is_json('{\"numbers\": [1,2,3,]}'))"
    },
    {
        "name": "test_cannot_have_multiple_comma_in_array",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_cannot_have_multiple_comma_in_array(self):\n        self.assertFalse(is_json('{\"numbers\": [1,2,,3]}'))"
    },
    {
        "name": "test_cannot_have_trailing_comma_in_object",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_cannot_have_trailing_comma_in_object(self):\n        self.assertFalse(is_json('{\"numbers\": {\"a\": 1, \"b\": 2,}}'))"
    },
    {
        "name": "test_cannot_have_multiple_comma_in_object",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_cannot_have_multiple_comma_in_object(self):\n        self.assertFalse(is_json('{\"numbers\": {\"a\": 1,, \"b\": 2}}'))"
    },
    {
        "name": "test_string_can_contain_escaped_quotes",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_can_contain_escaped_quotes(self):\n        s = '{\"string\": \"Look: \\\\\"escaped string here!\\\\\"\"}'\n        self.assertTrue(is_json(s))\n        self.assertIsInstance(json.loads(s), dict)"
    },
    {
        "name": "test_array_is_json",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_array_is_json(self):\n        self.assertTrue(is_json('[1,2,3]'))\n        self.assertTrue(is_json('[]'))\n        self.assertTrue(is_json('[\"foo\", \"bar\"]'))\n        self.assertTrue(is_json('[true]'))\n        self.assertTrue(is_json('[false]'))\n        self.assertTrue(is_json('[{\"a\": \"b\"}]'))"
    },
    {
        "name": "test_complete_json_case",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_complete_json_case(self):\n        string = '''\n            {\n                \"books\": [\n                    {\n                        \"title\": \"Book title 1\",\n                        \"author\": \"FirstName LastName\",\n                        \"tags\": [\"tech\", \"programming\", \"python\"],\n                        \"available\": true,\n                        \"pageCount\": 516,\n                        \"rating\": 4.5,\n                        \"comments\": [\n                            {\n                                \"author\": \"FirstName LastName\",\n                                \"content\": \"Nice book!\"\n                            }\n                        ]\n                    },\n                    {\n                        \"title\": \"Book title 2\",\n                        \"author\": \"FirstName LastName\",\n                        \"tags\": [\"tech\", \"programming\", \"javascript\"],\n                        \"available\": true,\n                        \"rating\": 4,\n                        \"pageCount\": 422,\n                        \"comments\": [\n\n                        ]\n                    }\n                ]\n            }\n        '''\n        self.assertTrue(is_json(string))\n        self.assertIsInstance(json.loads(string), dict)"
    },
    {
        "name": "test_non_string_objects_return_false",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_non_string_objects_return_false(self):\n        # noinspection PyTypeChecker\n        self.assertFalse(is_pangram(1))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_pangram(['xx']))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_pangram({}))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_pangram(False))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_pangram((1, 2, 3)))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_pangram(object()))"
    },
    {
        "name": "test_is_pangram_returns_false_if_not_pangram",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_is_pangram_returns_false_if_not_pangram(self):\n        self.assertFalse(is_pangram('hello world'))"
    },
    {
        "name": "test_is_pangram_returns_true_if_pangram",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_is_pangram_returns_true_if_pangram(self):\n        self.assertTrue(is_pangram('The quick brown fox jumps over the lazy dog'))"
    },
    {
        "name": "test_should_consider_false_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_consider_false_non_string_objects(self):\n        # noinspection PyTypeChecker\n        self.assertFalse(is_uuid(None))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_uuid(1))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_uuid([]))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_uuid({'a': 1}))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_uuid(True))"
    },
    {
        "name": "test_should_accept_valid_uuid_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_accept_valid_uuid_objects(self):\n        for i in range(1000):\n            # noinspection PyTypeChecker\n            self.assertTrue(is_uuid(uuid4()))\n            self.assertTrue(is_uuid(uuid1()))"
    },
    {
        "name": "test_should_accept_valid_uuid_strings",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_accept_valid_uuid_strings(self):\n        for i in range(1000):\n            self.assertTrue(is_uuid(str(uuid4())))\n            self.assertTrue(is_uuid(str(uuid1())))"
    },
    {
        "name": "test_accepts_hex_value_of_uuid",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_accepts_hex_value_of_uuid(self):\n        for i in range(1000):\n            # noinspection PyTypeChecker\n            self.assertTrue(is_uuid(uuid4().hex, True))\n            self.assertTrue(is_uuid(uuid1().hex, True))"
    },
    {
        "name": "test_non_string_objects_return_false",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_non_string_objects_return_false(self):\n        # noinspection PyTypeChecker\n        self.assertFalse(is_slug(1))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_slug(['xx']))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_slug({}))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_slug(False))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_slug((1, 2, 3)))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_slug(object()))"
    },
    {
        "name": "test_recognizes_slugs",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_recognizes_slugs(self):\n        self.assertTrue(is_slug('yep-i-am-a-slug'))\n        self.assertTrue(is_slug('yep-i-am-a-slug', '-'))\n        self.assertTrue(is_slug('yep.i.am.a.slug', '.'))\n        self.assertTrue(is_slug('yep_i_am_a_slug', '_'))"
    },
    {
        "name": "test_slug_can_have_multiple_consecutive_separator_signs",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_slug_can_have_multiple_consecutive_separator_signs(self):\n        self.assertTrue(is_slug('oh-----yeah'))\n        self.assertTrue(is_slug('oh_____yeah', '_'))\n        self.assertTrue(is_slug('1----2'))"
    },
    {
        "name": "test_slug_cannot_contain_spaces",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_slug_cannot_contain_spaces(self):\n        self.assertFalse(is_slug('not - a - slug'))\n        self.assertFalse(is_slug('not- a - slug'))\n        self.assertFalse(is_slug('not- a- slug'))\n        self.assertFalse(is_slug('not-a- slug'))\n        self.assertFalse(is_slug('not-a-slug '))\n        self.assertFalse(is_slug(' not-a-slug'))"
    },
    {
        "name": "test_slug_cannot_contain_non_ascii_chars",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_slug_cannot_contain_non_ascii_chars(self):\n        self.assertFalse(is_slug('fo\u00f2-b\u00e4r'))"
    },
    {
        "name": "test_slug_cannot_contain_punctuation",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_slug_cannot_contain_punctuation(self):\n        self.assertFalse(is_slug('foo.-bar'))\n        self.assertFalse(is_slug('foo-bar.'))\n        self.assertFalse(is_slug('foo-bar,'))\n        self.assertFalse(is_slug('!foo-bar'))\n        self.assertFalse(is_slug('foo-bar?'))\n        self.assertFalse(is_slug('foo-bar:'))\n        self.assertFalse(is_slug('foo-bar;'))"
    },
    {
        "name": "test_exclude_invalid_slugs",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_exclude_invalid_slugs(self):\n        self.assertFalse(is_slug(' nope'))\n        self.assertFalse(is_slug('nope '))\n        self.assertFalse(is_slug(' nope '))\n        self.assertFalse(is_slug('#nope'))\n        self.assertFalse(is_slug('-nope-'))\n        self.assertFalse(is_slug('-no-no-no-'))\n        self.assertFalse(is_slug('100%no-slug!'))\n        self.assertFalse(is_slug('NOT-AS-UPPERCASE'))"
    },
    {
        "name": "test_slug_can_be_single_word",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_slug_can_be_single_word(self):\n        self.assertTrue(is_slug('hello'))\n        self.assertTrue(is_slug('x'))\n        self.assertTrue(is_slug('42'))\n        self.assertTrue(is_slug('5'))"
    },
    {
        "name": "test_slug_must_have_at_least_one_non_separator_char",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_slug_must_have_at_least_one_non_separator_char(self):\n        self.assertFalse(is_slug('-'))"
    },
    {
        "name": "test_return_false_for_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_return_false_for_non_string_objects(self):\n        # noinspection PyTypeChecker\n        self.assertFalse(is_ip_v6(None))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_ip_v6(1))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_ip_v6([]))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_ip_v6({'a': 1}))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_ip_v6(True))"
    },
    {
        "name": "test_ip_cannot_be_blank",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_ip_cannot_be_blank(self):\n        self.assertFalse(is_ip_v6(''))\n        self.assertFalse(is_ip_v6(' '))"
    },
    {
        "name": "test_ipv4_is_not_recognized",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_ipv4_is_not_recognized(self):\n        self.assertFalse(is_ip_v6('255.100.100.75'))"
    },
    {
        "name": "test_returns_false_for_invalid_ip_v6",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_false_for_invalid_ip_v6(self):\n        self.assertFalse(is_ip_v6('2001.db8:85a3:0000:0000:8a2e:370:7334'))\n        self.assertFalse(is_ip_v6('2001:db8|85a3:0000:0000:8a2e:370:1'))\n        self.assertFalse(is_ip_v6('123:db8:85a3:0000:0000:8a2e:370,1'))\n        self.assertFalse(is_ip_v6('2001:db8:85a3:0:0:8a2e:370'))"
    },
    {
        "name": "test_recognizes_valid_ip_v6",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_recognizes_valid_ip_v6(self):\n        self.assertTrue(is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334'))\n        self.assertTrue(is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:1'))\n        self.assertTrue(is_ip_v6('123:db8:85a3:0000:0000:8a2e:370:1'))\n        self.assertTrue(is_ip_v6('2001:db8:85a3:0:0:8a2e:370:7334'))"
    },
    {
        "name": "test_encode_throws_an_exception_if_number_is_less_than_1",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_encode_throws_an_exception_if_number_is_less_than_1(self):\n        self.assertRaises(ValueError, lambda: roman_encode(0))\n        self.assertRaises(ValueError, lambda: roman_encode(-12))"
    },
    {
        "name": "test_encode_throws_an_exception_if_number_is_decimal",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_encode_throws_an_exception_if_number_is_decimal(self):\n        # noinspection PyTypeChecker\n        self.assertRaises(ValueError, lambda: roman_encode(1.1))\n\n        # noinspection PyTypeChecker\n        self.assertRaises(ValueError, lambda: roman_encode(-4.3))"
    },
    {
        "name": "test_encode_throws_an_exception_if_input_is_not_a_number",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_encode_throws_an_exception_if_input_is_not_a_number(self):\n        # noinspection PyTypeChecker\n        self.assertRaises(ValueError, lambda: roman_encode(None))\n\n        # noinspection PyTypeChecker\n        self.assertRaises(ValueError, lambda: roman_encode(False))\n\n        # noinspection PyTypeChecker\n        self.assertRaises(ValueError, lambda: roman_encode([11]))"
    },
    {
        "name": "test_encode_accepts_strings",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_encode_accepts_strings(self):\n        self.assertEqual(roman_encode('15'), 'XV')\n        self.assertEqual(roman_encode('9'), 'IX')\n        self.assertEqual(roman_encode('30'), 'XXX')"
    },
    {
        "name": "test_units_are_encoded_as_expected",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_units_are_encoded_as_expected(self):\n        self.assertEqual(roman_encode(1), 'I')\n        self.assertEqual(roman_encode(2), 'II')\n        self.assertEqual(roman_encode(3), 'III')\n        self.assertEqual(roman_encode(4), 'IV')\n        self.assertEqual(roman_encode(5), 'V')\n        self.assertEqual(roman_encode(6), 'VI')\n        self.assertEqual(roman_encode(7), 'VII')\n        self.assertEqual(roman_encode(8), 'VIII')\n        self.assertEqual(roman_encode(9), 'IX')"
    },
    {
        "name": "test_tens_are_encoded_as_expected",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tens_are_encoded_as_expected(self):\n        self.assertEqual(roman_encode(10), 'X')\n        self.assertEqual(roman_encode(20), 'XX')\n        self.assertEqual(roman_encode(30), 'XXX')\n        self.assertEqual(roman_encode(40), 'XL')\n        self.assertEqual(roman_encode(50), 'L')\n        self.assertEqual(roman_encode(60), 'LX')\n        self.assertEqual(roman_encode(70), 'LXX')\n        self.assertEqual(roman_encode(80), 'LXXX')\n        self.assertEqual(roman_encode(90), 'XC')"
    },
    {
        "name": "test_tens_and_units_are_encoded_as_expected",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tens_and_units_are_encoded_as_expected(self):\n        # 1x\n        self.assertEqual(roman_encode(11), 'XI')\n        self.assertEqual(roman_encode(12), 'XII')\n        self.assertEqual(roman_encode(13), 'XIII')\n        self.assertEqual(roman_encode(14), 'XIV')\n        self.assertEqual(roman_encode(15), 'XV')\n        self.assertEqual(roman_encode(16), 'XVI')\n        self.assertEqual(roman_encode(17), 'XVII')\n        self.assertEqual(roman_encode(18), 'XVIII')\n        self.assertEqual(roman_encode(19), 'XIX')\n\n        # 2x\n        self.assertEqual(roman_encode(21), 'XXI')\n        self.assertEqual(roman_encode(22), 'XXII')\n        self.assertEqual(roman_encode(23), 'XXIII')\n        self.assertEqual(roman_encode(24), 'XXIV')\n        self.assertEqual(roman_encode(25), 'XXV')\n        self.assertEqual(roman_encode(26), 'XXVI')\n        self.assertEqual(roman_encode(27), 'XXVII')\n        self.assertEqual(roman_encode(28), 'XXVIII')\n        self.assertEqual(roman_encode(29), 'XXIX')\n\n        # 3x\n        self.assertEqual(roman_encode(31), 'XXXI')\n        self.assertEqual(roman_encode(32), 'XXXII')\n        self.assertEqual(roman_encode(33), 'XXXIII')\n        self.assertEqual(roman_encode(34), 'XXXIV')\n        self.assertEqual(roman_encode(35), 'XXXV')\n        self.assertEqual(roman_encode(36), 'XXXVI')\n        self.assertEqual(roman_encode(37), 'XXXVII')\n        self.assertEqual(roman_encode(38), 'XXXVIII')\n        self.assertEqual(roman_encode(39), 'XXXIX')\n\n        # 4x\n        self.assertEqual(roman_encode(41), 'XLI')\n        self.assertEqual(roman_encode(42), 'XLII')\n        self.assertEqual(roman_encode(43), 'XLIII')\n        self.assertEqual(roman_encode(44), 'XLIV')\n        self.assertEqual(roman_encode(45), 'XLV')\n        self.assertEqual(roman_encode(46), 'XLVI')\n        self.assertEqual(roman_encode(47), 'XLVII')\n        self.assertEqual(roman_encode(48), 'XLVIII')\n        self.assertEqual(roman_encode(49), 'XLIX')\n\n        # 5x\n        self.assertEqual(roman_encode(51), 'LI')\n        self.assertEqual(roman_encode(52), 'LII')\n        self.assertEqual(roman_encode(53), 'LIII')\n        self.assertEqual(roman_encode(54), 'LIV')\n        self.assertEqual(roman_encode(55), 'LV')\n        self.assertEqual(roman_encode(56), 'LVI')\n        self.assertEqual(roman_encode(57), 'LVII')\n        self.assertEqual(roman_encode(58), 'LVIII')\n        self.assertEqual(roman_encode(59), 'LIX')\n\n        # 6x\n        self.assertEqual(roman_encode(61), 'LXI')\n        self.assertEqual(roman_encode(62), 'LXII')\n        self.assertEqual(roman_encode(63), 'LXIII')\n        self.assertEqual(roman_encode(64), 'LXIV')\n        self.assertEqual(roman_encode(65), 'LXV')\n        self.assertEqual(roman_encode(66), 'LXVI')\n        self.assertEqual(roman_encode(67), 'LXVII')\n        self.assertEqual(roman_encode(68), 'LXVIII')\n        self.assertEqual(roman_encode(69), 'LXIX')\n\n        # 7x\n        self.assertEqual(roman_encode(71), 'LXXI')\n        self.assertEqual(roman_encode(72), 'LXXII')\n        self.assertEqual(roman_encode(73), 'LXXIII')\n        self.assertEqual(roman_encode(74), 'LXXIV')\n        self.assertEqual(roman_encode(75), 'LXXV')\n        self.assertEqual(roman_encode(76), 'LXXVI')\n        self.assertEqual(roman_encode(77), 'LXXVII')\n        self.assertEqual(roman_encode(78), 'LXXVIII')\n        self.assertEqual(roman_encode(79), 'LXXIX')\n\n        # 8x\n        self.assertEqual(roman_encode(81), 'LXXXI')\n        self.assertEqual(roman_encode(82), 'LXXXII')\n        self.assertEqual(roman_encode(83), 'LXXXIII')\n        self.assertEqual(roman_encode(84), 'LXXXIV')\n        self.assertEqual(roman_encode(85), 'LXXXV')\n        self.assertEqual(roman_encode(86), 'LXXXVI')\n        self.assertEqual(roman_encode(87), 'LXXXVII')\n        self.assertEqual(roman_encode(88), 'LXXXVIII')\n        self.assertEqual(roman_encode(89), 'LXXXIX')\n\n        # 9x\n        self.assertEqual(roman_encode(91), 'XCI')\n        self.assertEqual(roman_encode(92), 'XCII')\n        self.assertEqual(roman_encode(93), 'XCIII')\n        self.assertEqual(roman_encode(94), 'XCIV')\n        self.assertEqual(roman_encode(95), 'XCV')\n        self.assertEqual(roman_encode(96), 'XCVI')\n        self.assertEqual(roman_encode(97), 'XCVII')\n        self.assertEqual(roman_encode(98), 'XCVIII')\n        self.assertEqual(roman_encode(99), 'XCIX')"
    },
    {
        "name": "test_hundreds_are_encoded_as_expected",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_hundreds_are_encoded_as_expected(self):\n        self.assertEqual(roman_encode(100), 'C')\n        self.assertEqual(roman_encode(200), 'CC')\n        self.assertEqual(roman_encode(300), 'CCC')\n        self.assertEqual(roman_encode(400), 'CD')\n        self.assertEqual(roman_encode(500), 'D')\n        self.assertEqual(roman_encode(600), 'DC')\n        self.assertEqual(roman_encode(700), 'DCC')\n        self.assertEqual(roman_encode(800), 'DCCC')\n        self.assertEqual(roman_encode(900), 'CM')"
    },
    {
        "name": "test_thousands_are_encoded_as_expected",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_thousands_are_encoded_as_expected(self):\n        self.assertEqual(roman_encode(1000), 'M')\n        self.assertEqual(roman_encode(2000), 'MM')\n        self.assertEqual(roman_encode(3000), 'MMM')"
    },
    {
        "name": "test_combined_numbers_encode",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_combined_numbers_encode(self):\n        self.assertEqual(roman_encode(3001), 'MMMI')\n        self.assertEqual(roman_encode(3090), 'MMMXC')\n        self.assertEqual(roman_encode(1200), 'MCC')\n        self.assertEqual(roman_encode(2739), 'MMDCCXXXIX')\n        self.assertEqual(roman_encode(3999), 'MMMCMXCIX')"
    },
    {
        "name": "test_requires_valid_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_requires_valid_string(self):\n        # noinspection PyTypeChecker\n        self.assertRaises(InvalidInputError, lambda: is_isbn_10(None))\n\n        # noinspection PyTypeChecker\n        self.assertRaises(InvalidInputError, lambda: is_isbn_10(True))\n\n        # noinspection PyTypeChecker\n        self.assertRaises(InvalidInputError, lambda: is_isbn_10(9780312498580))\n\n        # noinspection PyTypeChecker\n        self.assertRaises(InvalidInputError, lambda: is_isbn_10([9780312498580]))"
    },
    {
        "name": "test_returns_true_for_valid_isbn_10",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_true_for_valid_isbn_10(self):\n        # isbn numbers have been taken from actual books on amazon\n        self.assertTrue(is_isbn_10('1506715214'))\n        self.assertTrue(is_isbn_10('1506715532'))\n        self.assertTrue(is_isbn_10('0451494504'))\n        self.assertTrue(is_isbn_10('0718079183'))\n        self.assertTrue(is_isbn_10('8830102180'))"
    },
    {
        "name": "test_dashes_are_not_considered_by_default",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_dashes_are_not_considered_by_default(self):\n        # isbn numbers have been taken from actual books on amazon\n        self.assertTrue(is_isbn_10('150-6715214'))\n        self.assertTrue(is_isbn_10('150-671-5532'))\n        self.assertTrue(is_isbn_10('045-14-94-50-4'))\n        self.assertTrue(is_isbn_10('071-8-0-7-9-1-8-3'))\n        self.assertTrue(is_isbn_10('8-8-3-0-1-0-2-1-8-0'))"
    },
    {
        "name": "test_isbn_not_recognized_if_normalization_is_disabled",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_isbn_not_recognized_if_normalization_is_disabled(self):\n        # isbn numbers have been taken from actual books on amazon\n        self.assertFalse(is_isbn_10('150-6715214', normalize=False))\n        self.assertFalse(is_isbn_10('150-671-521-4', normalize=False))"
    },
    {
        "name": "test_returns_false_if_isbn_13",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_false_if_isbn_13(self):\n        # isbn numbers have been taken from actual books on amazon\n        self.assertFalse(is_isbn_10('978-8830102187'))\n        self.assertFalse(is_isbn_10('9788830102187'))"
    },
    {
        "name": "test_returns_false_if_not_isbn",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_false_if_not_isbn(self):\n        self.assertFalse(is_isbn_10('1506715214!'))\n        self.assertFalse(is_isbn_10(' 1506715214'))\n        self.assertFalse(is_isbn_10('1506715214y'))\n        self.assertFalse(is_isbn_10('x' * 10))\n        self.assertFalse(is_isbn_10(''))"
    },
    {
        "name": "test_cannot_handle_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_cannot_handle_non_string_objects(self):\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            words_count(None)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"NoneType\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            words_count(False)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"bool\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            words_count(0)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"int\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            words_count([])\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"list\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            words_count({'a': 1})\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"dict\"')"
    },
    {
        "name": "test_signs_are_not_considered_words",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_signs_are_not_considered_words(self):\n        self.assertEqual(words_count(r'. . ! <> [] {} + % --- _ = @ # ~ | \\ / \" \\''), 0)"
    },
    {
        "name": "test_case_doesnt_matter",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_case_doesnt_matter(self):\n        self.assertEqual(words_count('hello world'), 2)\n        self.assertEqual(words_count('HELLO WORLD'), 2)\n        self.assertEqual(words_count('hello WORLD'), 2)"
    },
    {
        "name": "test_support_multi_line",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_support_multi_line(self):\n        self.assertEqual(words_count('''\n\n            hello\n\n            world\n\n        '''), 2)"
    },
    {
        "name": "test_word_with_numbers_is_considered_single_word",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_word_with_numbers_is_considered_single_word(self):\n        self.assertEqual(words_count('jinja2'), 1)\n        self.assertEqual(words_count('Area52'), 1)"
    },
    {
        "name": "test_words_divided_by_underscore_are_considered_multiple_even_if_space_is_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_words_divided_by_underscore_are_considered_multiple_even_if_space_is_missing(self):\n        self.assertEqual(words_count('hello _world'), 2)\n        self.assertEqual(words_count('hello _ world'), 2)\n        self.assertEqual(words_count('hello_ world'), 2)\n        self.assertEqual(words_count('hello_world'), 2)"
    },
    {
        "name": "test_words_divided_by_dash_are_considered_multiple_even_if_space_is_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_words_divided_by_dash_are_considered_multiple_even_if_space_is_missing(self):\n        self.assertEqual(words_count('hello - world'), 2)\n        self.assertEqual(words_count('hello -world'), 2)\n        self.assertEqual(words_count('hello- world'), 2)\n        self.assertEqual(words_count('hello-world'), 2)"
    },
    {
        "name": "test_words_divided_by_pipe_are_considered_multiple_even_if_space_is_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_words_divided_by_pipe_are_considered_multiple_even_if_space_is_missing(self):\n        self.assertEqual(words_count('hello | world'), 2)\n        self.assertEqual(words_count('hello |world'), 2)\n        self.assertEqual(words_count('hello| world'), 2)\n        self.assertEqual(words_count('hello|world'), 2)"
    },
    {
        "name": "test_words_divided_by_plus_are_considered_multiple_even_if_space_is_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_words_divided_by_plus_are_considered_multiple_even_if_space_is_missing(self):\n        self.assertEqual(words_count('hello + world'), 2)\n        self.assertEqual(words_count('hello +world'), 2)\n        self.assertEqual(words_count('hello+ world'), 2)\n        self.assertEqual(words_count('hello+world'), 2)"
    },
    {
        "name": "test_words_divided_by_colons_are_considered_multiple_even_if_space_is_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_words_divided_by_colons_are_considered_multiple_even_if_space_is_missing(self):\n        self.assertEqual(words_count('hello : world'), 2)\n        self.assertEqual(words_count('hello :world'), 2)\n        self.assertEqual(words_count('hello: world'), 2)\n        self.assertEqual(words_count('hello:world'), 2)"
    },
    {
        "name": "test_words_divided_by_semicolons_are_considered_multiple_even_if_space_is_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_words_divided_by_semicolons_are_considered_multiple_even_if_space_is_missing(self):\n        self.assertEqual(words_count('hello ; world'), 2)\n        self.assertEqual(words_count('hello ;world'), 2)\n        self.assertEqual(words_count('hello; world'), 2)\n        self.assertEqual(words_count('hello;world'), 2)"
    },
    {
        "name": "test_words_divided_by_equal_are_considered_multiple_even_if_space_is_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_words_divided_by_equal_are_considered_multiple_even_if_space_is_missing(self):\n        self.assertEqual(words_count('hello = world'), 2)\n        self.assertEqual(words_count('hello =world'), 2)\n        self.assertEqual(words_count('hello= world'), 2)\n        self.assertEqual(words_count('hello=world'), 2)"
    },
    {
        "name": "test_words_divided_by_question_mark_are_considered_multiple_even_if_space_is_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_words_divided_by_question_mark_are_considered_multiple_even_if_space_is_missing(self):\n        self.assertEqual(words_count('hello ? world'), 2)\n        self.assertEqual(words_count('hello ?world'), 2)\n        self.assertEqual(words_count('hello? world'), 2)\n        self.assertEqual(words_count('hello?world'), 2)"
    },
    {
        "name": "test_words_divided_by_exclamation_mark_are_considered_multiple_even_if_space_is_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_words_divided_by_exclamation_mark_are_considered_multiple_even_if_space_is_missing(self):\n        self.assertEqual(words_count('hello ! world'), 2)\n        self.assertEqual(words_count('hello !world'), 2)\n        self.assertEqual(words_count('hello! world'), 2)\n        self.assertEqual(words_count('hello!world'), 2)"
    },
    {
        "name": "test_words_divided_by_apos_are_considered_multiple_even_if_space_is_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_words_divided_by_apos_are_considered_multiple_even_if_space_is_missing(self):\n        self.assertEqual(words_count('hello \\' world'), 2)\n        self.assertEqual(words_count('hello \\'world'), 2)\n        self.assertEqual(words_count('hello\\' world'), 2)\n        self.assertEqual(words_count('hello\\'world'), 2)"
    },
    {
        "name": "test_words_divided_by_and_are_considered_multiple_even_if_space_is_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_words_divided_by_and_are_considered_multiple_even_if_space_is_missing(self):\n        self.assertEqual(words_count('joseph & joseph'), 2)\n        self.assertEqual(words_count('joseph &joseph'), 2)\n        self.assertEqual(words_count('joseph& joseph'), 2)\n        self.assertEqual(words_count('joseph&joseph'), 2)"
    },
    {
        "name": "test_words_divided_by_comma_are_considered_multiple_even_if_space_is_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_words_divided_by_comma_are_considered_multiple_even_if_space_is_missing(self):\n        self.assertEqual(words_count('hello , world'), 2)\n        self.assertEqual(words_count('hello ,world'), 2)\n        self.assertEqual(words_count('hello, world'), 2)\n        self.assertEqual(words_count('hello,world'), 2)"
    },
    {
        "name": "test_words_divided_by_dot_are_considered_multiple_even_if_space_is_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_words_divided_by_dot_are_considered_multiple_even_if_space_is_missing(self):\n        self.assertEqual(words_count('hello . world'), 2)\n        self.assertEqual(words_count('hello .world'), 2)\n        self.assertEqual(words_count('hello. world'), 2)\n        self.assertEqual(words_count('hello.world'), 2)"
    },
    {
        "name": "test_quoted_text_is_handled_properly",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_quoted_text_is_handled_properly(self):\n        self.assertEqual(words_count('this text \"is quoted\"'), 4)\n        self.assertEqual(words_count('this text\"is quoted\"'), 4)"
    },
    {
        "name": "test_parenthesis_are_properly_handled",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_parenthesis_are_properly_handled(self):\n        self.assertEqual(words_count('Does it work? (just a test)'), 6)\n        self.assertEqual(words_count('Does it work?(just a test)'), 6)\n        self.assertEqual(words_count('Does it work? (just a test)I hope'), 8)"
    },
    {
        "name": "test_return_expected_count",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_return_expected_count(self):\n        self.assertEqual(words_count('hello'), 1)\n        self.assertEqual(words_count('hello world'), 2)\n        self.assertEqual(words_count('a couple of words and the number 1'), 8)\n        self.assertEqual(words_count('Testing (this)'), 2)\n        self.assertEqual(words_count('''\n            this is my list:\n\n            - (1) one\n            - (2) two\n            - (3) three\n\n        '''), 10)"
    },
    {
        "name": "test_should_count_non_ascii_words",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_count_non_ascii_words(self):\n        self.assertEqual(words_count('\u00e9 vero o \u00e9 falso?'), 5)"
    },
    {
        "name": "test_return_false_for_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_return_false_for_non_string_objects(self):\n        # noinspection PyTypeChecker\n        self.assertFalse(is_snake_case(None))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_snake_case(False))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_snake_case(0))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_snake_case([]))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_snake_case({'a': 1}))"
    },
    {
        "name": "test_string_cannot_be_blank",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_cannot_be_blank(self):\n        self.assertFalse(is_snake_case(''))\n        self.assertFalse(is_snake_case(' '))"
    },
    {
        "name": "test_string_cannot_be_lowercase_letters_only",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_cannot_be_lowercase_letters_only(self):\n        self.assertFalse(is_snake_case('lowercaseonly'))"
    },
    {
        "name": "test_string_cannot_be_camel_case",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_cannot_be_camel_case(self):\n        self.assertFalse(is_snake_case('Banana'))"
    },
    {
        "name": "test_string_cannot_be_all_uppercase",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_cannot_be_all_uppercase(self):\n        self.assertFalse(is_snake_case('HELLO'))"
    },
    {
        "name": "test_string_cannot_contain_only_underscores",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_cannot_contain_only_underscores(self):\n        self.assertFalse(is_snake_case('_'))\n        self.assertFalse(is_snake_case('__'))\n        self.assertFalse(is_snake_case('___'))\n        self.assertFalse(is_snake_case('____________________'))"
    },
    {
        "name": "test_string_cannot_contain_bad_signs",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_cannot_contain_bad_signs(self):\n        self.assertFalse(is_snake_case('1_no_snake'))\n        self.assertFalse(is_snake_case('^_no_snake'))\n        self.assertFalse(is_snake_case('@_no_snake'))\n        self.assertFalse(is_snake_case('%_no_snake'))\n        self.assertFalse(is_snake_case('no_snake#'))\n        self.assertFalse(is_snake_case('no_!'))\n        self.assertFalse(is_snake_case('!no_'))\n        self.assertFalse(is_snake_case('.no_'))"
    },
    {
        "name": "test_should_accept_valid_snake_strings",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_accept_valid_snake_strings(self):\n        self.assertTrue(is_snake_case('HELLO_WORLD'))\n        self.assertTrue(is_snake_case('Hello_World'))\n        self.assertTrue(is_snake_case('_hello_world'))\n        self.assertTrue(is_snake_case('hello_world_'))\n        self.assertTrue(is_snake_case('hello_world'))\n        self.assertTrue(is_snake_case('_hello_'))\n        self.assertTrue(is_snake_case('_hello__'))\n        self.assertTrue(is_snake_case('__hello_'))\n        self.assertTrue(is_snake_case('a_'))\n        self.assertTrue(is_snake_case('_b'))\n        self.assertTrue(is_snake_case('a_b_c_d_e'))\n        self.assertTrue(is_snake_case('snake_case_string'))\n        self.assertTrue(is_snake_case('snake_2'))\n        self.assertTrue(is_snake_case('a_snake_string_4_you'))"
    },
    {
        "name": "test_should_consider_custom_separator",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_consider_custom_separator(self):\n        s = 'snake-string-with-dashes'\n        self.assertFalse(is_snake_case(s))\n        self.assertTrue(is_snake_case(s, separator='-'))"
    },
    {
        "name": "test_should_return_false_for_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_return_false_for_non_string_objects(self):\n        self.assertFalse(is_url(None))\n        self.assertFalse(is_url(False))\n        self.assertFalse(is_url(0))\n        self.assertFalse(is_url([]))\n        self.assertFalse(is_url({'a': 1}))"
    },
    {
        "name": "test_string_cannot_be_blank",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_cannot_be_blank(self):\n        self.assertFalse(is_url(''))\n        self.assertFalse(is_url(' '))"
    },
    {
        "name": "test_string_cannot_contain_spaces",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_cannot_contain_spaces(self):\n        self.assertFalse(is_url(' http://www.google.com'))\n        self.assertFalse(is_url('http://www.google.com '))\n        self.assertFalse(is_url('http://www.google.com/ ncr'))\n        self.assertFalse(is_url('http://www.goo gle.com'))"
    },
    {
        "name": "test_scheme_is_required",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_scheme_is_required(self):\n        self.assertFalse(is_url('google.com'))\n        self.assertFalse(is_url('www.google.com'))"
    },
    {
        "name": "test_domain_extension_is_required_for_named_urls",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_domain_extension_is_required_for_named_urls(self):\n        self.assertFalse(is_url('http://google'))\n        self.assertFalse(is_url('http://google.'))"
    },
    {
        "name": "test_domain_extension_should_be_between_2_and_6_letters",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_domain_extension_should_be_between_2_and_6_letters(self):\n        self.assertFalse(is_url('http://google.c'))\n        self.assertFalse(is_url('http://google.abcdefghi'))"
    },
    {
        "name": "test_should_accept_any_scheme_by_default",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_accept_any_scheme_by_default(self):\n        self.assertTrue(is_url('http://site.com'))\n        self.assertTrue(is_url('http://www.site.com'))\n        self.assertTrue(is_url('https://site.com'))\n        self.assertTrue(is_url('https://www.site.com'))\n        self.assertTrue(is_url('ftp://site.com'))\n        self.assertTrue(is_url('git://site.com'))"
    },
    {
        "name": "test_should_restrict_checking_on_provided_schemes",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_restrict_checking_on_provided_schemes(self):\n        self.assertTrue(is_url('git://site.com'))\n        self.assertFalse(is_url('git://site.com', allowed_schemes=['http', 'https']))"
    },
    {
        "name": "test_url_cannot_start_with_dot",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_url_cannot_start_with_dot(self):\n        self.assertFalse(is_url('http://.site.com'))"
    },
    {
        "name": "test_url_can_contain_dash",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_url_can_contain_dash(self):\n        self.assertTrue(is_url('http://some-site-name.com'))"
    },
    {
        "name": "test_url_cannot_start_with_dash",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_url_cannot_start_with_dash(self):\n        self.assertFalse(is_url('http://-site.com'))"
    },
    {
        "name": "test_url_cannot_start_with_slash",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_url_cannot_start_with_slash(self):\n        self.assertFalse(is_url('http:///www.site.com'))"
    },
    {
        "name": "test_www_is_optional",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_www_is_optional(self):\n        self.assertTrue(is_url('http://www.mysite.com'))\n        self.assertTrue(is_url('http://mysite.com'))"
    },
    {
        "name": "test_localhost_is_an_accepted_url",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_localhost_is_an_accepted_url(self):\n        self.assertTrue(is_url('http://localhost'))"
    },
    {
        "name": "test_should_accept_valid_ip_url",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_accept_valid_ip_url(self):\n        self.assertTrue(is_url('http://123.123.123.123'))\n        self.assertTrue(is_url('http://1.123.123.123'))\n        self.assertTrue(is_url('http://1.1.123.123'))\n        self.assertTrue(is_url('http://1.1.1.123'))\n        self.assertTrue(is_url('http://1.1.1.1'))\n        self.assertTrue(is_url('http://123.123.123.1'))\n        self.assertTrue(is_url('http://123.123.1.1'))\n        self.assertTrue(is_url('http://123.1.1.1'))"
    },
    {
        "name": "test_should_exclude_invalid_ip",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_exclude_invalid_ip(self):\n        self.assertFalse(is_url('http://1.2.3'))\n        self.assertFalse(is_url('http://1.2.3.'))\n        self.assertFalse(is_url('http://123.123.123.1234'))\n        self.assertFalse(is_url('http://.123.123.123.123'))\n        self.assertFalse(is_url('http://123.123.123.123.'))\n        self.assertFalse(is_url('http://123.123...123.123'))\n        self.assertFalse(is_url('http://123..123..123.123'))"
    },
    {
        "name": "test_url_can_have_port_number",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_url_can_have_port_number(self):\n        self.assertTrue(is_url('http://localhost:8080'))"
    },
    {
        "name": "test_url_can_contain_sub_folders",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_url_can_contain_sub_folders(self):\n        self.assertTrue(is_url('http://www.site.com/one'))\n        self.assertTrue(is_url('http://www.site.com/one/'))\n        self.assertTrue(is_url('http://www.site.com/one/two'))\n        self.assertTrue(is_url('http://www.site.com/one/two/'))\n        self.assertTrue(is_url('http://www.site.com/one/two/three/four/five/six'))"
    },
    {
        "name": "test_url_can_have_user_and_password",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_url_can_have_user_and_password(self):\n        self.assertTrue(is_url('postgres://myuser:mypassword@localhost:5432/mydb'))"
    },
    {
        "name": "test_url_can_contain_file_extension",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_url_can_contain_file_extension(self):\n        self.assertTrue(is_url('http://site.com/foo/photo.jpg'))\n        self.assertTrue(is_url('http://site.com/index.html'))"
    },
    {
        "name": "test_file_can_contains_multiple_dots",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_file_can_contains_multiple_dots(self):\n        self.assertTrue(is_url('http://site.com/foo/file.name.ext'))"
    },
    {
        "name": "test_url_can_contain_query_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_url_can_contain_query_string(self):\n        self.assertTrue(is_url('http://site.com/foo/?'))\n        self.assertTrue(is_url('http://site.com/foo/?foo'))\n        self.assertTrue(is_url('http://site.com/foo/?foo=bar'))\n        self.assertTrue(is_url('http://site.com/foo/?foo=bar&baz=1'))\n        self.assertTrue(is_url('http://site.com/foo/?foo=bar&baz=1&'))"
    },
    {
        "name": "test_url_can_have_hash_part",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_url_can_have_hash_part(self):\n        self.assertTrue(is_url('http://site.com/foo#anchor'))\n        self.assertTrue(is_url('http://site.com/foo#anchor2-with_several+signs++'))"
    },
    {
        "name": "test_a_full_url",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_a_full_url(self):\n        self.assertTrue(is_url('https://www.site.com/a/b/c/banana/file.html?foo=1&bar=2#hello-world'))"
    },
    {
        "name": "test_cannot_handle_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_cannot_handle_non_string_objects(self):\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            contains_html(None)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"NoneType\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            contains_html(False)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"bool\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            contains_html(0)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"int\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            contains_html([])\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"list\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            contains_html({'a': 1})\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"dict\"')"
    },
    {
        "name": "test_handle_empty_strings_as_expected",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_handle_empty_strings_as_expected(self):\n        self.assertFalse(contains_html(''))\n        self.assertFalse(contains_html(' '))"
    },
    {
        "name": "test_handle_text_only_as_expected",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_handle_text_only_as_expected(self):\n        self.assertFalse(contains_html('hello world! No html here :)'))"
    },
    {
        "name": "test_ignores_tag_signs_if_not_valid_tag",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_ignores_tag_signs_if_not_valid_tag(self):\n        self.assertFalse(contains_html('>No html>'))\n        self.assertFalse(contains_html('<No <html'))"
    },
    {
        "name": "test_is_not_html_tag_if_name_is_missing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_is_not_html_tag_if_name_is_missing(self):\n        self.assertFalse(contains_html('<>'))\n        self.assertFalse(contains_html('<1>'))\n        self.assertFalse(contains_html('</123>'))\n        self.assertFalse(contains_html('no <> no'))\n        self.assertFalse(contains_html('</>'))\n        self.assertFalse(contains_html('no </> no'))\n        self.assertFalse(contains_html('< />'))\n        self.assertFalse(contains_html('< no />'))\n        self.assertFalse(contains_html('< />nooooo'))\n        self.assertFalse(contains_html('<[nope]>'))\n        self.assertFalse(contains_html('<!nope>'))\n        self.assertFalse(contains_html('<?nope>'))\n        self.assertFalse(contains_html('<#nope>'))"
    },
    {
        "name": "test_tag_can_be_self_closing_or_not_and_space_before_closing_is_optional",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tag_can_be_self_closing_or_not_and_space_before_closing_is_optional(self):\n        self.assertTrue(contains_html('one: <br>'))\n        self.assertTrue(contains_html('two: <br/>'))\n        self.assertTrue(contains_html('three: <br />'))"
    },
    {
        "name": "test_tag_name_can_contain_dashes_but_not_as_first_char",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tag_name_can_contain_dashes_but_not_as_first_char(self):\n        self.assertTrue(contains_html('test <my-custom-tag /> this'))\n        self.assertFalse(contains_html('test <-> this'))\n        self.assertFalse(contains_html('test <---> this'))\n        self.assertFalse(contains_html('test <---/> this'))\n        self.assertFalse(contains_html('test <-nope/> this'))"
    },
    {
        "name": "test_html_comment_is_properly_recognized",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_html_comment_is_properly_recognized(self):\n        self.assertTrue(contains_html('foo bar baz <!-- html comment --> banana'))\n        self.assertFalse(contains_html('foo bar baz <!- no html comment -> banana'))"
    },
    {
        "name": "test_tag_name_cane_even_contain_number_but_not_as_first_char",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tag_name_cane_even_contain_number_but_not_as_first_char(self):\n        self.assertTrue(contains_html('<daitarn3 />'))\n        self.assertFalse(contains_html('<3daitarn />'))"
    },
    {
        "name": "test_detects_doctype",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_detects_doctype(self):\n        self.assertTrue(contains_html('<!DOCTYPE html>'))"
    },
    {
        "name": "test_tag_can_have_properties",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tag_can_have_properties(self):\n        self.assertTrue(contains_html('bla bla <input disabled /> bla bla '))\n        self.assertTrue(contains_html('bla bla <div flex>xxx</div> bla bla '))\n        self.assertTrue(contains_html('bla bla <a one two three />bla bla '))"
    },
    {
        "name": "test_tag_properties_can_have_content",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tag_properties_can_have_content(self):\n        self.assertTrue(contains_html('bla bla <span id=\"foo\">yo</span> bla bla '))\n        self.assertTrue(contains_html('bla bla <div style=\"width: 300px; height: 50px; background: #000\">yo</div>'))\n        self.assertTrue(contains_html('bla bla <div id=\"x\" class=\"container\">text</div> bla bla '))"
    },
    {
        "name": "test_tag_properties_can_use_single_duble_quotes_or_nothing",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tag_properties_can_use_single_duble_quotes_or_nothing(self):\n        self.assertTrue(contains_html('<span id=\"foo\">yo</span>'))\n        self.assertTrue(contains_html('<span id=\\'foo\\'>yo</span>'))\n        self.assertTrue(contains_html('<span id=foo>yo</span>'))"
    },
    {
        "name": "test_tag_properties_can_have_space_before_or_after_equal_sign",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tag_properties_can_have_space_before_or_after_equal_sign(self):\n        self.assertTrue(contains_html('<span id =\"foo\">yo</span>'))\n        self.assertTrue(contains_html('<span id= \\'foo\\'>yo</span>'))\n        self.assertTrue(contains_html('<span id = foo>yo</span>'))"
    },
    {
        "name": "test_tag_can_have_both_simple_and_complex_properties",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tag_can_have_both_simple_and_complex_properties(self):\n        self.assertTrue(contains_html('bla bla <div id=\"x\" class=\"container\" boom>text</div>'))"
    },
    {
        "name": "test_tag_can_have_namespace",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tag_can_have_namespace(self):\n        self.assertTrue(contains_html('namespace tag: <dz:foo power=\"100\"></dz:foo>'))\n        self.assertTrue(contains_html('namespace tag: <dz:test> content </dz:test>'))\n        self.assertTrue(contains_html('namespace tag: <a:test/>'))\n        self.assertTrue(contains_html('namespace tag: <dz:banana />'))"
    },
    {
        "name": "test_tag_can_contains_any_content",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tag_can_contains_any_content(self):\n        self.assertTrue(contains_html('<html></html>'))\n        self.assertTrue(contains_html('<html> content </html>'))\n        self.assertTrue(contains_html('<html> <body><p> content </p></body> </html>'))"
    },
    {
        "name": "test_tag_can_be_multi_line",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_tag_can_be_multi_line(self):\n        self.assertTrue(contains_html('''\n            multi_line tag here:\n            <div\n                style=\"width:200px\"\n                id=\"foo\"\n                class=\"bar\">hello</div>\n        '''))"
    },
    {
        "name": "test_multi_line_are_handled_properly",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_multi_line_are_handled_properly(self):\n        self.assertTrue(contains_html('''\n\n            Text here, followed by html:\n\n            <script>\n                document.write('you are fucked!');\n            </script>\n\n            end!\n\n        '''))\n        self.assertFalse(contains_html('''\n\n            plain text\n            here\n\n            ...\n\n            should return false!\n\n        '''))"
    },
    {
        "name": "test_cannot_handle_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_cannot_handle_non_string_objects(self):\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            is_decimal(None)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"NoneType\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            is_decimal(False)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"bool\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            is_decimal(0)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"int\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            is_decimal([])\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"list\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            is_decimal({'a': 1})\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"dict\"')"
    },
    {
        "name": "test_returns_true_for_unsigned_decimals",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_true_for_unsigned_decimals(self):\n        self.assertTrue(is_decimal('1.1'))\n        self.assertTrue(is_decimal('42.123'))\n        self.assertTrue(is_decimal('1.999e3'))"
    },
    {
        "name": "test_returns_true_for_signed_decimals",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_true_for_signed_decimals(self):\n        self.assertTrue(is_decimal('+1.1'))\n        self.assertTrue(is_decimal('+42.999'))\n        self.assertTrue(is_decimal('+1.999e3'))\n\n        self.assertTrue(is_decimal('-1.999'))\n        self.assertTrue(is_decimal('-42.999'))\n        self.assertTrue(is_decimal('-1.999e3'))"
    },
    {
        "name": "test_cannot_contain_multiple_dots",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_cannot_contain_multiple_dots(self):\n        self.assertFalse(is_decimal('+1...1'))\n        self.assertFalse(is_decimal('+42..999'))\n        self.assertFalse(is_decimal('+1..999e3'))\n\n        self.assertFalse(is_decimal('-1..999'))\n        self.assertFalse(is_decimal('-42...999'))\n        self.assertFalse(is_decimal('-1......999e3'))"
    },
    {
        "name": "test_cannot_contain_spaces",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_cannot_contain_spaces(self):\n        self.assertFalse(is_decimal('1. 1'))\n        self.assertFalse(is_decimal('1 .1'))\n        self.assertFalse(is_decimal('1 . 1'))\n        self.assertFalse(is_decimal(' 1.1'))\n        self.assertFalse(is_decimal('1.1 '))\n        self.assertFalse(is_decimal(' 1.1 '))"
    },
    {
        "name": "test_returns_false_for_integers",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_false_for_integers(self):\n        self.assertFalse(is_decimal('1'))\n        self.assertFalse(is_decimal('42'))\n        self.assertFalse(is_decimal('1e3'))"
    },
    {
        "name": "test_returns_false_for_string_that_are_not_numbers",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_false_for_string_that_are_not_numbers(self):\n        self.assertFalse(is_decimal('no'))\n        self.assertFalse(is_decimal('a1.1'))\n        self.assertFalse(is_decimal('ten'))\n        self.assertFalse(is_decimal('>1.1'))\n        self.assertFalse(is_decimal('1.1?'))"
    },
    {
        "name": "test_empty_string_is_not_full",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_empty_string_is_not_full(self):\n        self.assertFalse(is_full_string(''))"
    },
    {
        "name": "test_white_space_is_not_full",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_white_space_is_not_full(self):\n        self.assertFalse(is_full_string(' '))\n        self.assertFalse(is_full_string('\\t'))\n        self.assertFalse(is_full_string('''\n            \\n\n            \\n\n            \\n\n        '''))"
    },
    {
        "name": "test_word_string_is_full",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_word_string_is_full(self):\n        self.assertTrue(is_full_string('ciao'))\n        self.assertTrue(is_full_string(' hi '))\n        self.assertTrue(is_full_string('1'))\n        self.assertTrue(is_full_string(' @*& '))\n        self.assertTrue(is_full_string('...'))"
    },
    {
        "name": "test_raise_exception_if_object_is_not_a_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_raise_exception_if_object_is_not_a_string(self):\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            shuffle(None)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"NoneType\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            shuffle(False)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"bool\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            shuffle(0)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"int\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            shuffle([])\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"list\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            shuffle({'a': 1})\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"dict\"')"
    },
    {
        "name": "test_shuffled_string_should_be_different_from_original_one",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_shuffled_string_should_be_different_from_original_one(self):\n        self.assertNotEqual(self.original_string, shuffle(self.original_string))"
    },
    {
        "name": "test_original_string_is_not_modified",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_original_string_is_not_modified(self):\n        shuffle(self.original_string)\n        self.assertEqual(self.original_string, 'Hello World!')"
    },
    {
        "name": "test_shuffle_generates_new_string_for_each_call",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_shuffle_generates_new_string_for_each_call(self):\n        self.assertNotEqual(shuffle(self.original_string), shuffle(self.original_string))"
    },
    {
        "name": "test_shuffled_string_should_have_same_len_of_original_one",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_shuffled_string_should_have_same_len_of_original_one(self):\n        shuffled = shuffle(self.original_string)\n        self.assertTrue(len(self.original_string), len(shuffled))"
    },
    {
        "name": "test_sorted_strings_should_match",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_sorted_strings_should_match(self):\n        shuffled = shuffle(self.original_string)\n        self.assertEqual(sorted(self.original_string), sorted(shuffled))"
    },
    {
        "name": "test_raise_exception_if_not_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_raise_exception_if_not_string(self):\n        # noinspection PyTypeChecker\n        self.assertRaises(InvalidInputError, lambda: asciify(None))\n\n        # noinspection PyTypeChecker\n        self.assertRaises(InvalidInputError, lambda: asciify(1))\n\n        # noinspection PyTypeChecker\n        self.assertRaises(InvalidInputError, lambda: asciify(True))\n\n        # noinspection PyTypeChecker\n        self.assertRaises(InvalidInputError, lambda: asciify(['nope']))"
    },
    {
        "name": "test_returns_same_string_if_ascii",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_same_string_if_ascii(self):\n        self.assertEqual(asciify(''), '')\n        self.assertEqual(asciify(' '), ' ')\n        self.assertEqual(asciify('Hello World!'), 'Hello World!')\n        self.assertEqual(asciify('-12.99'), '-12.99')\n        self.assertEqual(asciify('<foo></foo>'), '<foo></foo>')"
    },
    {
        "name": "test_returns_asciified_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_asciified_string(self):\n        self.assertEqual('eeuuooaaeynAAACIINOE', asciify('\u00e8\u00e9\u00f9\u00fa\u00f2\u00f3\u00e4\u00e5\u00eb\u00fd\u00f1\u00c5\u00c0\u00c1\u00c7\u00cc\u00cd\u00d1\u00d3\u00cb'))"
    },
    {
        "name": "test_return_false_for_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_return_false_for_non_string_objects(self):\n        # noinspection PyTypeChecker\n        self.assertFalse(is_ip(None))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_ip(1))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_ip([]))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_ip({'a': 1}))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_ip(True))"
    },
    {
        "name": "test_recognize_ip_v4_strings",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_recognize_ip_v4_strings(self):\n        self.assertTrue(is_ip('127.0.0.1'))\n        self.assertTrue(is_ip('0.0.0.0'))\n        self.assertTrue(is_ip('255.255.10.1'))"
    },
    {
        "name": "test_returns_false_if_ipv4_out_of_range",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_false_if_ipv4_out_of_range(self):\n        self.assertFalse(is_ip('999.200.100.75'))\n        self.assertFalse(is_ip('255.999.100.75'))\n        self.assertFalse(is_ip('255.200.999.75'))\n        self.assertFalse(is_ip('255.200.100.999'))"
    },
    {
        "name": "test_ip_v4_cannot_contain_spaces",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_ip_v4_cannot_contain_spaces(self):\n        self.assertFalse(is_ip(' 127.0.0.1 '))\n        self.assertFalse(is_ip('0.0.0.0 '))\n        self.assertFalse(is_ip(' 255.255.10.1'))\n        self.assertFalse(is_ip('255. 255.10.1'))"
    },
    {
        "name": "test_ip_v4_cannot_have_multiple_dots",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_ip_v4_cannot_have_multiple_dots(self):\n        self.assertFalse(is_ip('127.0.0..1'))\n        self.assertFalse(is_ip('0..0.0.0'))\n        self.assertFalse(is_ip('255.255.10.1.'))"
    },
    {
        "name": "test_numbers_cannot_be_divided_by_other_signs_in_ipv4",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_numbers_cannot_be_divided_by_other_signs_in_ipv4(self):\n        self.assertFalse(is_ip('127:0:0:1'))\n        self.assertFalse(is_ip('127-0-0-1'))\n        self.assertFalse(is_ip('0_0_0_0'))\n        self.assertFalse(is_ip('255,255,10,1'))"
    },
    {
        "name": "test_ip_cannot_be_blank",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_ip_cannot_be_blank(self):\n        self.assertFalse(is_ip(''))\n        self.assertFalse(is_ip(' '))"
    },
    {
        "name": "test_requires_valid_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_requires_valid_string(self):\n        # noinspection PyTypeChecker\n        self.assertRaises(InvalidInputError, lambda: is_isbn(None))\n\n        # noinspection PyTypeChecker\n        self.assertRaises(InvalidInputError, lambda: is_isbn(True))\n\n        # noinspection PyTypeChecker\n        self.assertRaises(InvalidInputError, lambda: is_isbn(9780312498580))\n\n        # noinspection PyTypeChecker\n        self.assertRaises(InvalidInputError, lambda: is_isbn([9780312498580]))"
    },
    {
        "name": "test_returns_true_for_valid_isbn_10",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_true_for_valid_isbn_10(self):\n        # isbn numbers have been taken from actual books on amazon\n        self.assertTrue(is_isbn('1506715214'))\n        self.assertTrue(is_isbn('1506715532'))\n        self.assertTrue(is_isbn('0451494504'))\n        self.assertTrue(is_isbn('0718079183'))\n        self.assertTrue(is_isbn('8830102180'))"
    },
    {
        "name": "test_returns_true_for_valid_isbn_13",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_true_for_valid_isbn_13(self):\n        # isbn numbers have been taken from actual books on amazon\n        self.assertTrue(is_isbn('9780312498580'))\n        self.assertTrue(is_isbn('9781941325827'))\n        self.assertTrue(is_isbn('9780062853851'))\n        self.assertTrue(is_isbn('9781250107817'))\n        self.assertTrue(is_isbn('9788891229243'))"
    },
    {
        "name": "test_hyphens_are_not_considered_by_default",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_hyphens_are_not_considered_by_default(self):\n        # isbn numbers have been taken from actual books on amazon\n        self.assertTrue(is_isbn('150-6715214'))\n        self.assertTrue(is_isbn('150-671-5532'))\n        self.assertTrue(is_isbn('045-14-94-50-4'))\n        self.assertTrue(is_isbn('071-8-0-7-9-1-8-3'))\n        self.assertTrue(is_isbn('8-8-3-0-1-0-2-1-8-0'))\n        self.assertTrue(is_isbn('978-0312498580'))\n        self.assertTrue(is_isbn('978-194-132-582-7'))\n        self.assertTrue(is_isbn('978-0-0-6-2-8-5-3-8-5-1'))"
    },
    {
        "name": "test_isbn_not_recognized_if_normalization_is_disabled",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_isbn_not_recognized_if_normalization_is_disabled(self):\n        # isbn numbers have been taken from actual books on amazon\n        self.assertFalse(is_isbn('150-6715214', normalize=False))\n        self.assertFalse(is_isbn('150-671-521-4', normalize=False))\n        self.assertFalse(is_isbn('978-0312498580', normalize=False))\n        self.assertFalse(is_isbn('978-194-132-582-7', normalize=False))\n        self.assertFalse(is_isbn('978-0-0-6-2-8-5-3-8-5-1', normalize=False))"
    },
    {
        "name": "test_returns_false_if_not_isbn",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_false_if_not_isbn(self):\n        self.assertFalse(is_isbn('9780312498580!'))\n        self.assertFalse(is_isbn(' 1506715214'))\n        self.assertFalse(is_isbn('1506715214y'))"
    },
    {
        "name": "test_cannot_handle_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_cannot_handle_non_string_objects(self):\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            strip_html(None)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"NoneType\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            strip_html(False)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"bool\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            strip_html(0)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"int\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            strip_html([])\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"list\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            strip_html({'a': 1})\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"dict\"')"
    },
    {
        "name": "test_should_return_original_string_if_does_not_contain_html",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_return_original_string_if_does_not_contain_html(self):\n        self.assertEqual('', strip_html(''))\n        self.assertEqual(' hello world ', strip_html(' hello world '))\n        multi_line_string = '''\n            > line 1\n            > line 2\n            > line 3\n        '''\n        self.assertEqual(multi_line_string, strip_html(multi_line_string))"
    },
    {
        "name": "test_should_remove_html_tags",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_remove_html_tags(self):\n        self.assertEqual('foo  bar', strip_html('foo <br> bar'))\n        self.assertEqual('foo  bar', strip_html('foo <br/> bar'))\n        self.assertEqual('foo  bar', strip_html('foo <br /> bar'))\n        self.assertEqual('  ', strip_html(' <div></div> '))"
    },
    {
        "name": "test_should_be_able_to_remove_multiple_tags",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_be_able_to_remove_multiple_tags(self):\n        stripped = strip_html('''\n            a <div>on the first line</div>\n            a <span>on the second line</span>\n            a <strong>on the third line</strong>\n            a <hr />\n        ''')\n        self.assertEqual('aaaa', re.sub(r'\\s', '', stripped))\n        stripped2 = strip_html('''\n            a <div>(on the first line)</div>\n            a <span>(on the second line)</span>\n            a <strong>(on the third line)</strong>\n            a <hr />\n        ''', keep_tag_content=True)\n        self.assertEqual('a(onthefirstline)a(onthesecondline)a(onthethirdline)a', re.sub(r'\\s', '', stripped2))"
    },
    {
        "name": "test_should_keep_tag_content_if_specified",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_should_keep_tag_content_if_specified(self):\n        s = 'test: <a href=\"foo/bar\">click here</a>'\n        self.assertEqual('test: ', strip_html(s))\n        self.assertEqual('test: click here', strip_html(s, keep_tag_content=True))\n        multiline_string = '''\n            <html>\n                <body>\n                    <div id=\"container\">\n                        <p>content text!<p>\n                    </div>\n                </body>\n            </html>\n        '''\n        self.assertEqual('content text!', strip_html(multiline_string, keep_tag_content=True).strip())"
    },
    {
        "name": "test_throws_error_if_size_is_null",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_throws_error_if_size_is_null(self):\n        with self.assertRaises(ValueError) as raised:\n            # noinspection PyTypeChecker\n            random_string(None)\n\n        self.assertEqual(str(raised.exception), 'size must be >= 1')"
    },
    {
        "name": "test_throws_error_if_size_is_less_than_1",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_throws_error_if_size_is_less_than_1(self):\n        msg = 'size must be >= 1'\n\n        with self.assertRaises(ValueError) as raised:\n            random_string(-12)\n\n        self.assertEqual(str(raised.exception), msg)\n\n        with self.assertRaises(ValueError) as raised:\n            random_string(0)\n\n        self.assertEqual(str(raised.exception), msg)"
    },
    {
        "name": "test_returns_string_of_the_desired_size",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_string_of_the_desired_size(self):\n        rs1 = random_string(2)\n        self.assertEqual(len(rs1), 2)\n        self.assertTrue(rs1.isalnum())\n\n        rs2 = random_string(9)\n        self.assertEqual(len(rs2), 9)\n        self.assertTrue(rs2.isalnum())\n\n        rs3 = random_string(36)\n        self.assertEqual(len(rs3), 36)\n        self.assertTrue(rs3.isalnum())"
    },
    {
        "name": "test_returns_different_string_at_each_call",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_different_string_at_each_call(self):\n        count = 1000\n        strings = [random_string(9) for _ in range(count)]\n\n        self.assertEqual(len(strings), count)\n        self.assertEqual(len(set(strings)), count)"
    },
    {
        "name": "test_cannot_handle_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_cannot_handle_non_string_objects(self):\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            is_number(None)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"NoneType\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            is_number(False)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"bool\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            is_number(0)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"int\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            is_number([])\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"list\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            is_number({'a': 1})\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"dict\"')"
    },
    {
        "name": "test_returns_false_if_string_is_empty",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_false_if_string_is_empty(self):\n        self.assertFalse(is_number(''))\n        self.assertFalse(is_number(' '))"
    },
    {
        "name": "test_returns_false_if_string_contains_number_but_has_spaces",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_false_if_string_contains_number_but_has_spaces(self):\n        self.assertFalse(is_number(' 1'))\n        self.assertFalse(is_number('99 '))\n        self.assertFalse(is_number(' 1234 '))\n        self.assertFalse(is_number(' +1234567890'))\n        self.assertFalse(is_number(' 1.2 '))"
    },
    {
        "name": "test_returns_false_if_string_is_sign_only",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_false_if_string_is_sign_only(self):\n        self.assertFalse(is_number('+'))\n        self.assertFalse(is_number('-'))"
    },
    {
        "name": "test_returns_false_if_contains_operations",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_false_if_contains_operations(self):\n        self.assertFalse(is_number('1 + 1'))\n        self.assertFalse(is_number('1+1'))\n        self.assertFalse(is_number('1 - 1'))\n        self.assertFalse(is_number('1-1'))"
    },
    {
        "name": "test_returns_true_for_unsigned_integers",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_true_for_unsigned_integers(self):\n        self.assertTrue(is_number('1'))\n        self.assertTrue(is_number('99'))\n        self.assertTrue(is_number('1234567890'))"
    },
    {
        "name": "test_returns_true_for_signed_integers",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_true_for_signed_integers(self):\n        self.assertTrue(is_number('+1'))\n        self.assertTrue(is_number('+99'))\n        self.assertTrue(is_number('+1234567890'))\n\n        self.assertTrue(is_number('-1'))\n        self.assertTrue(is_number('-99'))\n        self.assertTrue(is_number('-1234567890'))"
    },
    {
        "name": "test_returns_true_for_unsigned_double",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_true_for_unsigned_double(self):\n        self.assertTrue(is_number('1.0'))\n        self.assertTrue(is_number('.007'))\n        self.assertTrue(is_number('1.000'))\n        self.assertTrue(is_number('99.99'))\n        self.assertTrue(is_number('1234567890.000123456'))"
    },
    {
        "name": "test_returns_true_for_signed_double",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_true_for_signed_double(self):\n        self.assertTrue(is_number('+1.0'))\n        self.assertTrue(is_number('+.007'))\n        self.assertTrue(is_number('+1.000'))\n        self.assertTrue(is_number('+99.99'))\n        self.assertTrue(is_number('+1234567890.000123456'))\n\n        self.assertTrue(is_number('-1.0'))\n        self.assertTrue(is_number('-.007'))\n        self.assertTrue(is_number('-1.000'))\n        self.assertTrue(is_number('-99.99'))\n        self.assertTrue(is_number('-1234567890.000123456'))"
    },
    {
        "name": "test_double_cannot_contain_multiple_dots",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_double_cannot_contain_multiple_dots(self):\n        self.assertFalse(is_number('+1..0'))\n        self.assertFalse(is_number('+..007'))\n        self.assertFalse(is_number('+1..000'))\n        self.assertFalse(is_number('+99..99'))\n        self.assertFalse(is_number('+1234567890..000123456'))\n\n        self.assertFalse(is_number('-1..0'))\n        self.assertFalse(is_number('-..007'))\n        self.assertFalse(is_number('-1..000'))\n        self.assertFalse(is_number('-99..99'))\n        self.assertFalse(is_number('-1234567890..000123456'))"
    },
    {
        "name": "test_number_cannot_contain_multiple_sign",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_number_cannot_contain_multiple_sign(self):\n        self.assertFalse(is_number('+-1'))\n        self.assertFalse(is_number('++1'))\n        self.assertFalse(is_number('--1'))\n        self.assertFalse(is_number('+-1.1'))\n        self.assertFalse(is_number('++1.1'))\n        self.assertFalse(is_number('--1.1'))"
    },
    {
        "name": "test_returns_true_for_scientific_notation",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_returns_true_for_scientific_notation(self):\n        self.assertTrue(is_number('1e3'))\n        self.assertTrue(is_number('50e2'))\n        self.assertTrue(is_number('1.245e10'))"
    },
    {
        "name": "test_generates_uuid_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_generates_uuid_string(self):\n        uid = uuid()\n\n        self.assertIsInstance(uid, str)\n        self.assertTrue(is_uuid(uid))"
    },
    {
        "name": "test_as_hex",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_as_hex(self):\n        uid = uuid(True)\n\n        self.assertIsInstance(uid, str)\n        self.assertFalse(is_uuid(uid))"
    },
    {
        "name": "test_compress_raise_exception_if_provided_input_is_not_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_compress_raise_exception_if_provided_input_is_not_string(self):\n        with self.assertRaises(InvalidInputError) as raised:\n            # noinspection PyTypeChecker\n            compress(None)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"NoneType\"')"
    },
    {
        "name": "test_compress_raise_exception_if_provided_encoding_is_not_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_compress_raise_exception_if_provided_encoding_is_not_string(self):\n        with self.assertRaises(ValueError) as raised:\n            # noinspection PyTypeChecker\n            compress('A string to compress', encoding=None)\n\n        self.assertEqual(str(raised.exception), 'Invalid encoding')"
    },
    {
        "name": "test_compress_raise_exception_if_provided_level_is_invalid",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_compress_raise_exception_if_provided_level_is_invalid(self):\n        expected_msg = 'Invalid compression_level: it must be an \"int\" between 0 and 9'\n\n        with self.assertRaises(ValueError) as raised:\n            # noinspection PyTypeChecker\n            compress('A string to compress', compression_level=None)\n\n        self.assertEqual(str(raised.exception), expected_msg)\n\n        with self.assertRaises(ValueError) as raised:\n            compress('A string to compress', compression_level=-1)\n\n        self.assertEqual(str(raised.exception), expected_msg)\n\n        with self.assertRaises(ValueError) as raised:\n            # noinspection PyTypeChecker\n            compress('A string to compress', compression_level=5.5)\n\n        self.assertEqual(str(raised.exception), expected_msg)\n\n        with self.assertRaises(ValueError) as raised:\n            compress('A string to compress', compression_level=10)\n\n        self.assertEqual(str(raised.exception), expected_msg)"
    },
    {
        "name": "test_compress_raise_exception_if_string_if_empty",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_compress_raise_exception_if_string_if_empty(self):\n        with self.assertRaises(ValueError) as raised:\n            compress('')\n\n        self.assertEqual(str(raised.exception), 'Input string cannot be empty')"
    },
    {
        "name": "test_compress_returns_compressed_string_if_input_is_valid",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_compress_returns_compressed_string_if_input_is_valid(self):\n        compressed = compress(self.input_string_with_utf8_chars)\n\n        self.assertTrue(isinstance(compressed, str))\n        self.assertTrue(len(compressed) < len(self.input_string_with_utf8_chars))\n        self.assertFalse(' ' in compressed)"
    },
    {
        "name": "test_decompress_raise_exception_if_provided_input_is_not_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_decompress_raise_exception_if_provided_input_is_not_string(self):\n        with self.assertRaises(InvalidInputError) as raised:\n            # noinspection PyTypeChecker\n            decompress(None)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"NoneType\"')"
    },
    {
        "name": "test_decompress_raise_exception_if_provided_encoding_is_not_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_decompress_raise_exception_if_provided_encoding_is_not_string(self):\n        with self.assertRaises(ValueError) as raised:\n            # noinspection PyTypeChecker\n            decompress('A string to decompress', encoding=None)\n\n        self.assertEqual(str(raised.exception), 'Invalid encoding')"
    },
    {
        "name": "test_decompress_returns_original_string",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_decompress_returns_original_string(self):\n        compressed = compress(self.input_string_with_utf8_chars)\n        decompressed = decompress(compressed)\n\n        self.assertNotEqual(self.input_string_with_utf8_chars, compressed)\n        self.assertEqual(self.input_string_with_utf8_chars, decompressed)"
    },
    {
        "name": "test_cannot_handle_non_string_objects",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_cannot_handle_non_string_objects(self):\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            strip_margin(None)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"NoneType\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            strip_margin(False)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"bool\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            strip_margin(0)\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"int\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            strip_margin([])\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"list\"')\n\n        with self.assertRaises(TypeError) as raised:\n            # noinspection PyTypeChecker\n            strip_margin({'a': 1})\n\n        self.assertEqual(str(raised.exception), 'Expected \"str\", received \"dict\"')"
    },
    {
        "name": "test_string_is_not_modified_if_there_is_nothing_to_strip",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_string_is_not_modified_if_there_is_nothing_to_strip(self):\n        self.assertEqual(strip_margin(''), '')\n        self.assertEqual(strip_margin('abc'), 'abc')\n        self.assertEqual(strip_margin('this will not change'), 'this will not change')\n        self.assertEqual(strip_margin('this will not change neither '), 'this will not change neither ')"
    },
    {
        "name": "test_margins_are_stripped",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def test_margins_are_stripped(self):\n        # DO NOT REFORMAT THIS BLOCK (IT MUST STAY AS IS FOR THE TEST!)\n        expected_string = '''\n1. this is a string to strip\n\n2. this is a string to strip\n\n3. this is a string to strip\n\n4. this is a string to strip\n\n'''\n\n        self.assertEqual(\n            strip_margin(\n                '''\n                1. this is a string to strip\n                \n                2. this is a string to strip\n                \n                3. this is a string to strip\n                \n                4. this is a string to strip\n                \n                '''\n            ),\n            expected_string\n        )"
    },
    {
        "name": "__encode_digit",
        "docstring": null,
        "args": [
            "cls",
            "index",
            "value"
        ],
        "defaults": [],
        "code": "    def __encode_digit(cls, index: int, value: int) -> str:\n        # if digit is zero, there is no sign to display\n        if value == 0:\n            return ''\n\n        # from 1 to 3 we have just to repeat the sign N times (eg: III, XXX...)\n        if value <= 3:\n            return cls.__mappings[index][1] * value\n\n        # if 4 we have to add unit prefix\n        if value == 4:\n            return cls.__mappings[index][1] + cls.__mappings[index][5]\n\n        # if is 5, is a straight map\n        if value == 5:\n            return cls.__mappings[index][5]\n\n        # if 6, 7 or 8 we have to append unit suffixes\n        if value <= 8:\n            suffix = cls.__mappings[index][1] * (value - 5)\n            return cls.__mappings[index][5] + suffix\n\n        # if 9 we have to prepend current unit to next\n        return cls.__mappings[index][1] + cls.__mappings[index + 1][1]"
    },
    {
        "name": "encode",
        "docstring": null,
        "args": [
            "cls",
            "input_number"
        ],
        "defaults": [],
        "code": "    def encode(cls, input_number: Union[str, int]) -> str:\n        # force input conversion to a string (we need it in order to iterate on each digit)\n        input_string = str(input_number)\n\n        if not is_integer(input_string):\n            raise ValueError('Invalid input, only strings or integers are allowed')\n\n        value = int(input_string)\n\n        if value < 1 or value > 3999:\n            raise ValueError('Input must be >= 1 and <= 3999')\n\n        input_len = len(input_string)\n        output = ''\n\n        # decode digits from right to left (start from units to thousands)\n        for index in range(input_len):\n            # get actual digit value as int\n            digit = int(input_string[input_len - index - 1])\n\n            # encode digit to roman string\n            encoded_digit = cls.__encode_digit(index, digit)\n\n            # prepend encoded value to the current output in order to have the final string sorted\n            # from thousands to units\n            output = encoded_digit + output\n\n        return output"
    },
    {
        "name": "__index_for_sign",
        "docstring": null,
        "args": [
            "cls",
            "sign"
        ],
        "defaults": [],
        "code": "    def __index_for_sign(cls, sign: str) -> int:\n        for index, mapping in enumerate(cls.__reversed_mappings):\n            if sign in mapping:\n                return index\n\n        raise ValueError('Invalid token found: \"{}\"'.format(sign))"
    },
    {
        "name": "decode",
        "docstring": null,
        "args": [
            "cls",
            "input_string"
        ],
        "defaults": [],
        "code": "    def decode(cls, input_string: str) -> int:\n        if not is_full_string(input_string):\n            raise ValueError('Input must be a non empty string')\n\n        # reverse the provided string so that we can start parsing from units to thousands\n        reversed_string = reverse(input_string.upper())\n\n        # track last used value\n        last_value = None\n\n        # computed number to return\n        output = 0\n\n        # for each sign in the string we get its numeric value and add or subtract it to the computed output\n        for sign in reversed_string:\n            # are we dealing with units, tens, hundreds or thousands?\n            index = cls.__index_for_sign(sign)\n\n            # it's basically 1 or 5 (based on mapping rules definitions)\n            key_value = cls.__reversed_mappings[index][sign]\n\n            # Based on the level (tens, hundreds...) we have to add as many zeroes as the level into which we are\n            # in order to have the actual sign value.\n            # For instance, if we are at level 2 we are dealing with hundreds, therefore instead of 1 or 5, we will\n            # obtain 100 or 500 by adding 2 zeroes\n            sign_value = int(str(key_value) + '0' * index)\n\n            # increase total value if we are moving on with level\n            if last_value is None or sign_value >= last_value:\n                output += sign_value\n\n            # Decrease value if we are back to a previous level\n            # For instance, if we are parsing \"IX\", we first encounter \"X\" which is ten then \"I\" which is unit,\n            # So we have to do the following operation in order to get 9 (the final result): 10 - 1\n            else:\n                output -= sign_value\n\n            last_value = sign_value\n\n        return output"
    },
    {
        "name": "__require_valid_input_and_encoding",
        "docstring": null,
        "args": [
            "input_string",
            "encoding"
        ],
        "defaults": [],
        "code": "    def __require_valid_input_and_encoding(input_string: str, encoding: str):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        if len(input_string) == 0:\n            raise ValueError('Input string cannot be empty')\n\n        if not is_string(encoding):\n            raise ValueError('Invalid encoding')"
    },
    {
        "name": "compress",
        "docstring": null,
        "args": [
            "cls",
            "input_string",
            "encoding",
            "compression_level"
        ],
        "defaults": [
            "'utf-8'",
            "9"
        ],
        "code": "    def compress(cls, input_string: str, encoding: str = 'utf-8', compression_level: int = 9) -> str:\n        cls.__require_valid_input_and_encoding(input_string, encoding)\n\n        if not isinstance(compression_level, int) or compression_level < 0 or compression_level > 9:\n            raise ValueError('Invalid compression_level: it must be an \"int\" between 0 and 9')\n\n        # turns input string into a sequence of bytes using provided encoding\n        original_bytes = input_string.encode(encoding)\n\n        # compress bytes using zlib library\n        compressed_bytes = zlib.compress(original_bytes, compression_level)\n\n        # encode compressed bytes using base64\n        # (this ensure that all characters will be available and that the output string can be used safely in any\n        # context such URLs)\n        encoded_bytes = base64.urlsafe_b64encode(compressed_bytes)\n\n        # finally turns base64 bytes into a string\n        output = encoded_bytes.decode(encoding)\n\n        return output"
    },
    {
        "name": "decompress",
        "docstring": null,
        "args": [
            "cls",
            "input_string",
            "encoding"
        ],
        "defaults": [
            "'utf-8'"
        ],
        "code": "    def decompress(cls, input_string: str, encoding: str = 'utf-8') -> str:\n        cls.__require_valid_input_and_encoding(input_string, encoding)\n\n        # turns input string into a sequence of bytes\n        # (the string is assumed to be a previously compressed string, therefore we have to decode it using base64)\n        input_bytes = base64.urlsafe_b64decode(input_string)\n\n        # decompress bytes using zlib\n        decompressed_bytes = zlib.decompress(input_bytes)\n\n        # decode the decompressed bytes to get the original string back\n        original_string = decompressed_bytes.decode(encoding)\n\n        return original_string"
    },
    {
        "name": "__init__",
        "docstring": null,
        "args": [
            "self",
            "input_string"
        ],
        "defaults": [],
        "code": "    def __init__(self, input_string):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string"
    },
    {
        "name": "__uppercase_first_char",
        "docstring": null,
        "args": [
            "self",
            "regex_match"
        ],
        "defaults": [],
        "code": "    def __uppercase_first_char(self, regex_match):\n        return regex_match.group(0).upper()"
    },
    {
        "name": "__remove_duplicates",
        "docstring": null,
        "args": [
            "self",
            "regex_match"
        ],
        "defaults": [],
        "code": "    def __remove_duplicates(self, regex_match):\n        return regex_match.group(1)[0]"
    },
    {
        "name": "__uppercase_first_letter_after_sign",
        "docstring": null,
        "args": [
            "self",
            "regex_match"
        ],
        "defaults": [],
        "code": "    def __uppercase_first_letter_after_sign(self, regex_match):\n        match = regex_match.group(1)\n        return match[:-1] + match[2].upper()"
    },
    {
        "name": "__ensure_right_space_only",
        "docstring": null,
        "args": [
            "self",
            "regex_match"
        ],
        "defaults": [],
        "code": "    def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '"
    },
    {
        "name": "__ensure_left_space_only",
        "docstring": null,
        "args": [
            "self",
            "regex_match"
        ],
        "defaults": [],
        "code": "    def __ensure_left_space_only(self, regex_match):\n        return ' ' + regex_match.group(1).strip()"
    },
    {
        "name": "__ensure_spaces_around",
        "docstring": null,
        "args": [
            "self",
            "regex_match"
        ],
        "defaults": [],
        "code": "    def __ensure_spaces_around(self, regex_match):\n        return ' ' + regex_match.group(1).strip() + ' '"
    },
    {
        "name": "__remove_internal_spaces",
        "docstring": null,
        "args": [
            "self",
            "regex_match"
        ],
        "defaults": [],
        "code": "    def __remove_internal_spaces(self, regex_match):\n        return regex_match.group(1).strip()"
    },
    {
        "name": "__fix_saxon_genitive",
        "docstring": null,
        "args": [
            "self",
            "regex_match"
        ],
        "defaults": [],
        "code": "    def __fix_saxon_genitive(self, regex_match):\n        return regex_match.group(1).replace(' ', '') + ' '"
    },
    {
        "name": "__placeholder_key",
        "docstring": null,
        "args": [],
        "defaults": [],
        "code": "    def __placeholder_key():\n        return '$' + uuid4().hex + '$'"
    },
    {
        "name": "format",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def format(self) -> str:\n        # map of temporary placeholders\n        placeholders = {}\n        out = self.input_string\n\n        # looks for url or email and updates placeholders map with found values\n        placeholders.update({self.__placeholder_key(): m[0] for m in URLS_RE.findall(out)})\n        placeholders.update({self.__placeholder_key(): m for m in EMAILS_RE.findall(out)})\n\n        # replace original value with the placeholder key\n        for p in placeholders:\n            out = out.replace(placeholders[p], p, 1)\n\n        out = PRETTIFY_RE['UPPERCASE_FIRST_LETTER'].sub(self.__uppercase_first_char, out)\n        out = PRETTIFY_RE['DUPLICATES'].sub(self.__remove_duplicates, out)\n        out = PRETTIFY_RE['RIGHT_SPACE'].sub(self.__ensure_right_space_only, out)\n        out = PRETTIFY_RE['LEFT_SPACE'].sub(self.__ensure_left_space_only, out)\n        out = PRETTIFY_RE['SPACES_AROUND'].sub(self.__ensure_spaces_around, out)\n        out = PRETTIFY_RE['SPACES_INSIDE'].sub(self.__remove_internal_spaces, out)\n        out = PRETTIFY_RE['UPPERCASE_AFTER_SIGN'].sub(self.__uppercase_first_letter_after_sign, out)\n        out = PRETTIFY_RE['SAXON_GENITIVE'].sub(self.__fix_saxon_genitive, out)\n        out = out.strip()\n\n        # restore placeholder keys with their associated original value\n        for p in placeholders:\n            out = out.replace(p, placeholders[p], 1)\n\n        return out"
    },
    {
        "name": "reverse",
        "docstring": "Returns the string with its chars reversed.\n\n*Example:*\n\n>>> reverse('hello') # returns 'olleh'\n\n:param input_string: String to revert.\n:type input_string: str\n:return: Reversed string.",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def reverse(input_string: str) -> str:\n    \"\"\"\n    Returns the string with its chars reversed.\n\n    *Example:*\n\n    >>> reverse('hello') # returns 'olleh'\n\n    :param input_string: String to revert.\n    :type input_string: str\n    :return: Reversed string.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return input_string[::-1]"
    },
    {
        "name": "camel_case_to_snake",
        "docstring": "Convert a camel case string into a snake case one.\n(The original string is returned if is not a valid camel case string)\n\n*Example:*\n\n>>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign to use as separator.\n:type separator: str\n:return: Converted string.",
        "args": [
            "input_string",
            "separator"
        ],
        "defaults": [
            "'_'"
        ],
        "code": "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_camel_case(input_string):\n        return input_string\n\n    return CAMEL_CASE_REPLACE_RE.sub(lambda m: m.group(1) + separator, input_string).lower()"
    },
    {
        "name": "snake_case_to_camel",
        "docstring": "Convert a snake case string into a camel case one.\n(The original string is returned if is not a valid snake case string)\n\n*Example:*\n\n>>> snake_case_to_camel('the_snake_is_green') # returns 'TheSnakeIsGreen'\n\n:param input_string: String to convert.\n:type input_string: str\n:param upper_case_first: True to turn the first letter into uppercase (default).\n:type upper_case_first: bool\n:param separator: Sign to use as separator (default to \"_\").\n:type separator: str\n:return: Converted string",
        "args": [
            "input_string",
            "upper_case_first",
            "separator"
        ],
        "defaults": [
            "True",
            "'_'"
        ],
        "code": "def snake_case_to_camel(input_string: str, upper_case_first: bool = True, separator: str = '_') -> str:\n    \"\"\"\n    Convert a snake case string into a camel case one.\n    (The original string is returned if is not a valid snake case string)\n\n    *Example:*\n\n    >>> snake_case_to_camel('the_snake_is_green') # returns 'TheSnakeIsGreen'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param upper_case_first: True to turn the first letter into uppercase (default).\n    :type upper_case_first: bool\n    :param separator: Sign to use as separator (default to \"_\").\n    :type separator: str\n    :return: Converted string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_snake_case(input_string, separator):\n        return input_string\n\n    tokens = [s.title() for s in input_string.split(separator) if is_full_string(s)]\n\n    if not upper_case_first:\n        tokens[0] = tokens[0].lower()\n\n    out = ''.join(tokens)\n\n    return out"
    },
    {
        "name": "shuffle",
        "docstring": "Return a new string containing same chars of the given one but in a randomized order.\n\n*Example:*\n\n>>> shuffle('hello world') # possible output: 'l wodheorll'\n\n:param input_string: String to shuffle\n:type input_string: str\n:return: Shuffled string",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def shuffle(input_string: str) -> str:\n    \"\"\"\n    Return a new string containing same chars of the given one but in a randomized order.\n\n    *Example:*\n\n    >>> shuffle('hello world') # possible output: 'l wodheorll'\n\n    :param input_string: String to shuffle\n    :type input_string: str\n    :return: Shuffled string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    # turn the string into a list of chars\n    chars = list(input_string)\n\n    # shuffle the list\n    random.shuffle(chars)\n\n    # convert the shuffled list back to string\n    return ''.join(chars)"
    },
    {
        "name": "strip_html",
        "docstring": "Remove html code contained into the given string.\n\n*Examples:*\n\n>>> strip_html('test: <a href=\"foo/bar\">click here</a>') # returns 'test: '\n>>> strip_html('test: <a href=\"foo/bar\">click here</a>', keep_tag_content=True) # returns 'test: click here'\n\n:param input_string: String to manipulate.\n:type input_string: str\n:param keep_tag_content: True to preserve tag content, False to remove tag and its content too (default).\n:type keep_tag_content: bool\n:return: String with html removed.",
        "args": [
            "input_string",
            "keep_tag_content"
        ],
        "defaults": [
            "False"
        ],
        "code": "def strip_html(input_string: str, keep_tag_content: bool = False) -> str:\n    \"\"\"\n    Remove html code contained into the given string.\n\n    *Examples:*\n\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>') # returns 'test: '\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>', keep_tag_content=True) # returns 'test: click here'\n\n    :param input_string: String to manipulate.\n    :type input_string: str\n    :param keep_tag_content: True to preserve tag content, False to remove tag and its content too (default).\n    :type keep_tag_content: bool\n    :return: String with html removed.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    r = HTML_TAG_ONLY_RE if keep_tag_content else HTML_RE\n\n    return r.sub('', input_string)"
    },
    {
        "name": "prettify",
        "docstring": "Reformat a string by applying the following basic grammar and formatting rules:\n\n- String cannot start or end with spaces\n- The first letter in the string and the ones after a dot, an exclamation or a question mark must be uppercase\n- String cannot have multiple sequential spaces, empty lines or punctuation (except for \"?\", \"!\" and \".\")\n- Arithmetic operators (+, -, /, \\*, =) must have one, and only one space before and after themselves\n- One, and only one space should follow a dot, a comma, an exclamation or a question mark\n- Text inside double quotes cannot start or end with spaces, but one, and only one space must come first and     after quotes (foo\" bar\"baz -> foo \"bar\" baz)\n- Text inside round brackets cannot start or end with spaces, but one, and only one space must come first and     after brackets (\"foo(bar )baz\" -> \"foo (bar) baz\")\n- Percentage sign (\"%\") cannot be preceded by a space if there is a number before (\"100 %\" -> \"100%\")\n- Saxon genitive is correct (\"Dave' s dog\" -> \"Dave's dog\")\n\n*Examples:*\n\n>>> prettify(' unprettified string ,, like this one,will be\"prettified\" .it\\' s awesome! ')\n>>> # -> 'Unprettified string, like this one, will be \"prettified\". It's awesome!'\n\n:param input_string: String to manipulate\n:return: Prettified string.",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def prettify(input_string: str) -> str:\n    \"\"\"\n    Reformat a string by applying the following basic grammar and formatting rules:\n\n    - String cannot start or end with spaces\n    - The first letter in the string and the ones after a dot, an exclamation or a question mark must be uppercase\n    - String cannot have multiple sequential spaces, empty lines or punctuation (except for \"?\", \"!\" and \".\")\n    - Arithmetic operators (+, -, /, \\\\*, =) must have one, and only one space before and after themselves\n    - One, and only one space should follow a dot, a comma, an exclamation or a question mark\n    - Text inside double quotes cannot start or end with spaces, but one, and only one space must come first and \\\n    after quotes (foo\" bar\"baz -> foo \"bar\" baz)\n    - Text inside round brackets cannot start or end with spaces, but one, and only one space must come first and \\\n    after brackets (\"foo(bar )baz\" -> \"foo (bar) baz\")\n    - Percentage sign (\"%\") cannot be preceded by a space if there is a number before (\"100 %\" -> \"100%\")\n    - Saxon genitive is correct (\"Dave' s dog\" -> \"Dave's dog\")\n\n    *Examples:*\n\n    >>> prettify(' unprettified string ,, like this one,will be\"prettified\" .it\\\\' s awesome! ')\n    >>> # -> 'Unprettified string, like this one, will be \"prettified\". It\\'s awesome!'\n\n    :param input_string: String to manipulate\n    :return: Prettified string.\n    \"\"\"\n    formatted = __StringFormatter(input_string).format()\n    return formatted"
    },
    {
        "name": "asciify",
        "docstring": "Force string content to be ascii-only by translating all non-ascii chars into the closest possible representation\n(eg: \u00f3 -> o, \u00cb -> E, \u00e7 -> c...).\n\n**Bear in mind**: Some chars may be lost if impossible to translate.\n\n*Example:*\n\n>>> asciify('\u00e8\u00e9\u00f9\u00fa\u00f2\u00f3\u00e4\u00e5\u00eb\u00fd\u00f1\u00c5\u00c0\u00c1\u00c7\u00cc\u00cd\u00d1\u00d3\u00cb') # returns 'eeuuooaaeynAAACIINOE'\n\n:param input_string: String to convert\n:return: Ascii utf-8 string",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def asciify(input_string: str) -> str:\n    \"\"\"\n    Force string content to be ascii-only by translating all non-ascii chars into the closest possible representation\n    (eg: \u00f3 -> o, \u00cb -> E, \u00e7 -> c...).\n\n    **Bear in mind**: Some chars may be lost if impossible to translate.\n\n    *Example:*\n\n    >>> asciify('\u00e8\u00e9\u00f9\u00fa\u00f2\u00f3\u00e4\u00e5\u00eb\u00fd\u00f1\u00c5\u00c0\u00c1\u00c7\u00cc\u00cd\u00d1\u00d3\u00cb') # returns 'eeuuooaaeynAAACIINOE'\n\n    :param input_string: String to convert\n    :return: Ascii utf-8 string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    # \"NFKD\" is the algorithm which is able to successfully translate the most of non-ascii chars\n    normalized = unicodedata.normalize('NFKD', input_string)\n\n    # encode string forcing ascii and ignore any errors (unrepresentable chars will be stripped out)\n    ascii_bytes = normalized.encode('ascii', 'ignore')\n\n    # turns encoded bytes into an utf-8 string\n    ascii_string = ascii_bytes.decode('utf-8')\n\n    return ascii_string"
    },
    {
        "name": "slugify",
        "docstring": "Converts a string into a \"slug\" using provided separator.\nThe returned string has the following properties:\n\n- it has no spaces\n- all letters are in lower case\n- all punctuation signs and non alphanumeric chars are removed\n- words are divided using provided separator\n- all chars are encoded as ascii (by using `asciify()`)\n- is safe for URL\n\n*Examples:*\n\n>>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n>>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n:param input_string: String to convert.\n:type input_string: str\n:param separator: Sign used to join string tokens (default to \"-\").\n:type separator: str\n:return: Slug string",
        "args": [
            "input_string",
            "separator"
        ],
        "defaults": [
            "'-'"
        ],
        "code": "def slugify(input_string: str, separator: str = '-') -> str:\n    \"\"\"\n    Converts a string into a \"slug\" using provided separator.\n    The returned string has the following properties:\n\n    - it has no spaces\n    - all letters are in lower case\n    - all punctuation signs and non alphanumeric chars are removed\n    - words are divided using provided separator\n    - all chars are encoded as ascii (by using `asciify()`)\n    - is safe for URL\n\n    *Examples:*\n\n    >>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n    >>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign used to join string tokens (default to \"-\").\n    :type separator: str\n    :return: Slug string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    # replace any character that is NOT letter or number with spaces\n    out = NO_LETTERS_OR_NUMBERS_RE.sub(' ', input_string.lower()).strip()\n\n    # replace spaces with join sign\n    out = SPACES_RE.sub(separator, out)\n\n    # normalize joins (remove duplicates)\n    out = re.sub(re.escape(separator) + r'+', separator, out)\n\n    return asciify(out)"
    },
    {
        "name": "booleanize",
        "docstring": "Turns a string into a boolean based on its content (CASE INSENSITIVE).\n\nA positive boolean (True) is returned if the string value is one of the following:\n\n- \"true\"\n- \"1\"\n- \"yes\"\n- \"y\"\n\nOtherwise False is returned.\n\n*Examples:*\n\n>>> booleanize('true') # returns True\n>>> booleanize('YES') # returns True\n>>> booleanize('nope') # returns False\n\n:param input_string: String to convert\n:type input_string: str\n:return: True if the string contains a boolean-like positive value, false otherwise",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def booleanize(input_string: str) -> bool:\n    \"\"\"\n    Turns a string into a boolean based on its content (CASE INSENSITIVE).\n\n    A positive boolean (True) is returned if the string value is one of the following:\n\n    - \"true\"\n    - \"1\"\n    - \"yes\"\n    - \"y\"\n\n    Otherwise False is returned.\n\n    *Examples:*\n\n    >>> booleanize('true') # returns True\n    >>> booleanize('YES') # returns True\n    >>> booleanize('nope') # returns False\n\n    :param input_string: String to convert\n    :type input_string: str\n    :return: True if the string contains a boolean-like positive value, false otherwise\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return input_string.lower() in ('true', '1', 'yes', 'y')"
    },
    {
        "name": "strip_margin",
        "docstring": "Removes tab indentation from multi line strings (inspired by analogous Scala function).\n\n*Example:*\n\n>>> strip_margin('''\n>>>                 line 1\n>>>                 line 2\n>>>                 line 3\n>>> ''')\n>>> # returns:\n>>> '''\n>>> line 1\n>>> line 2\n>>> line 3\n>>> '''\n\n:param input_string: String to format\n:type input_string: str\n:return: A string without left margins",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def strip_margin(input_string: str) -> str:\n    \"\"\"\n    Removes tab indentation from multi line strings (inspired by analogous Scala function).\n\n    *Example:*\n\n    >>> strip_margin('''\n    >>>                 line 1\n    >>>                 line 2\n    >>>                 line 3\n    >>> ''')\n    >>> # returns:\n    >>> '''\n    >>> line 1\n    >>> line 2\n    >>> line 3\n    >>> '''\n\n    :param input_string: String to format\n    :type input_string: str\n    :return: A string without left margins\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    line_separator = '\\n'\n    lines = [MARGIN_RE.sub('', line) for line in input_string.split(line_separator)]\n    out = line_separator.join(lines)\n\n    return out"
    },
    {
        "name": "compress",
        "docstring": "Compress the given string by returning a shorter one that can be safely used in any context (like URL) and\nrestored back to its original state using `decompress()`.\n\n**Bear in mind:**\nBesides the provided `compression_level`, the compression result (how much the string is actually compressed\nby resulting into a shorter string) depends on 2 factors:\n\n1. The amount of data (string size): short strings might not provide a significant compression result    or even be longer than the given input string (this is due to the fact that some bytes have to be embedded    into the compressed string in order to be able to restore it later on)\n2. The content type: random sequences of chars are very unlikely to be successfully compressed, while the best    compression result is obtained when the string contains several recurring char sequences (like in the example).\n\nBehind the scenes this method makes use of the standard Python's zlib and base64 libraries.\n\n*Examples:*\n\n>>> n = 0 # <- ignore this, it's a fix for Pycharm (not fixable using ignore comments)\n>>> # \"original\" will be a string with 169 chars:\n>>> original = ' '.join(['word n{}'.format(n) for n in range(20)])\n>>> # \"compressed\" will be a string of 88 chars\n>>> compressed = compress(original)\n\n:param input_string: String to compress (must be not empty or a ValueError will be raised).\n:type input_string: str\n:param encoding: String encoding (default to \"utf-8\").\n:type encoding: str\n:param compression_level: A value between 0 (no compression) and 9 (best compression), default to 9.\n:type compression_level: int\n:return: Compressed string.",
        "args": [
            "input_string",
            "encoding",
            "compression_level"
        ],
        "defaults": [
            "'utf-8'",
            "9"
        ],
        "code": "def compress(input_string: str, encoding: str = 'utf-8', compression_level: int = 9) -> str:\n    \"\"\"\n    Compress the given string by returning a shorter one that can be safely used in any context (like URL) and\n    restored back to its original state using `decompress()`.\n\n    **Bear in mind:**\n    Besides the provided `compression_level`, the compression result (how much the string is actually compressed\n    by resulting into a shorter string) depends on 2 factors:\n\n    1. The amount of data (string size): short strings might not provide a significant compression result\\\n    or even be longer than the given input string (this is due to the fact that some bytes have to be embedded\\\n    into the compressed string in order to be able to restore it later on)\\\n\n    2. The content type: random sequences of chars are very unlikely to be successfully compressed, while the best\\\n    compression result is obtained when the string contains several recurring char sequences (like in the example).\n\n    Behind the scenes this method makes use of the standard Python's zlib and base64 libraries.\n\n    *Examples:*\n\n    >>> n = 0 # <- ignore this, it's a fix for Pycharm (not fixable using ignore comments)\n    >>> # \"original\" will be a string with 169 chars:\n    >>> original = ' '.join(['word n{}'.format(n) for n in range(20)])\n    >>> # \"compressed\" will be a string of 88 chars\n    >>> compressed = compress(original)\n\n    :param input_string: String to compress (must be not empty or a ValueError will be raised).\n    :type input_string: str\n    :param encoding: String encoding (default to \"utf-8\").\n    :type encoding: str\n    :param compression_level: A value between 0 (no compression) and 9 (best compression), default to 9.\n    :type compression_level: int\n    :return: Compressed string.\n    \"\"\"\n    return __StringCompressor.compress(input_string, encoding, compression_level)"
    },
    {
        "name": "decompress",
        "docstring": "Restore a previously compressed string (obtained using `compress()`) back to its original state.\n\n:param input_string: String to restore.\n:type input_string: str\n:param encoding: Original string encoding.\n:type encoding: str\n:return: Decompressed string.",
        "args": [
            "input_string",
            "encoding"
        ],
        "defaults": [
            "'utf-8'"
        ],
        "code": "def decompress(input_string: str, encoding: str = 'utf-8') -> str:\n    \"\"\"\n    Restore a previously compressed string (obtained using `compress()`) back to its original state.\n\n    :param input_string: String to restore.\n    :type input_string: str\n    :param encoding: Original string encoding.\n    :type encoding: str\n    :return: Decompressed string.\n    \"\"\"\n    return __StringCompressor.decompress(input_string, encoding)"
    },
    {
        "name": "roman_encode",
        "docstring": "Convert the given number/string into a roman number.\n\nThe passed input must represents a positive integer in the range 1-3999 (inclusive).\n\nWhy this limit? You may be wondering:\n\n1. zero is forbidden since there is no related representation in roman numbers\n2. the upper bound 3999 is due to the limitation in the ascii charset    (the higher quantity sign displayable in ascii is \"M\" which is equal to 1000, therefore based on    roman numbers rules we can use 3 times M to reach 3000 but we can't go any further in thousands without    special \"boxed chars\").\n\n*Examples:*\n\n>>> roman_encode(37) # returns 'XXXVIII'\n>>> roman_encode('2020') # returns 'MMXX'\n\n:param input_number: An integer or a string to be converted.\n:type input_number: Union[str, int]\n:return: Roman number string.",
        "args": [
            "input_number"
        ],
        "defaults": [],
        "code": "def roman_encode(input_number: Union[str, int]) -> str:\n    \"\"\"\n    Convert the given number/string into a roman number.\n\n    The passed input must represents a positive integer in the range 1-3999 (inclusive).\n\n    Why this limit? You may be wondering:\n\n    1. zero is forbidden since there is no related representation in roman numbers\n    2. the upper bound 3999 is due to the limitation in the ascii charset\\\n    (the higher quantity sign displayable in ascii is \"M\" which is equal to 1000, therefore based on\\\n    roman numbers rules we can use 3 times M to reach 3000 but we can't go any further in thousands without\\\n    special \"boxed chars\").\n\n    *Examples:*\n\n    >>> roman_encode(37) # returns 'XXXVIII'\n    >>> roman_encode('2020') # returns 'MMXX'\n\n    :param input_number: An integer or a string to be converted.\n    :type input_number: Union[str, int]\n    :return: Roman number string.\n    \"\"\"\n    return __RomanNumbers.encode(input_number)"
    },
    {
        "name": "roman_decode",
        "docstring": "Decode a roman number string into an integer if the provided string is valid.\n\n*Example:*\n\n>>> roman_decode('VII') # returns 7\n\n:param input_string: (Assumed) Roman number\n:type input_string: str\n:return: Integer value",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def roman_decode(input_string: str) -> int:\n    \"\"\"\n    Decode a roman number string into an integer if the provided string is valid.\n\n    *Example:*\n\n    >>> roman_decode('VII') # returns 7\n\n    :param input_string: (Assumed) Roman number\n    :type input_string: str\n    :return: Integer value\n    \"\"\"\n    return __RomanNumbers.decode(input_string)"
    },
    {
        "name": "uuid",
        "docstring": "Generated an UUID string (using `uuid.uuid4()`).\n\n*Examples:*\n\n>>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n>>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n:param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n:return: uuid string.",
        "args": [
            "as_hex"
        ],
        "defaults": [
            "False"
        ],
        "code": "def uuid(as_hex: bool = False) -> str:\n    \"\"\"\n    Generated an UUID string (using `uuid.uuid4()`).\n\n    *Examples:*\n\n    >>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n    >>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n    :param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n    :return: uuid string.\n    \"\"\"\n    uid = uuid4()\n\n    if as_hex:\n        return uid.hex\n\n    return str(uid)"
    },
    {
        "name": "random_string",
        "docstring": "Returns a string of the specified size containing random characters (uppercase/lowercase ascii letters and digits).\n\n*Example:*\n\n>>> random_string(9) # possible output: \"cx3QQbzYg\"\n\n:param size: Desired string size\n:type size: int\n:return: Random string",
        "args": [
            "size"
        ],
        "defaults": [],
        "code": "def random_string(size: int) -> str:\n    \"\"\"\n    Returns a string of the specified size containing random characters (uppercase/lowercase ascii letters and digits).\n\n    *Example:*\n\n    >>> random_string(9) # possible output: \"cx3QQbzYg\"\n\n    :param size: Desired string size\n    :type size: int\n    :return: Random string\n    \"\"\"\n    if not isinstance(size, int) or size < 1:\n        raise ValueError('size must be >= 1')\n\n    chars = string.ascii_letters + string.digits\n    buffer = [random.choice(chars) for _ in range(size)]\n    out = ''.join(buffer)\n\n    return out"
    },
    {
        "name": "secure_random_hex",
        "docstring": "Generates a random string using secure low level random generator (os.urandom).\n\n**Bear in mind**: due to hex conversion, the returned string will have a size that is exactly    the double of the given `byte_count`.\n\n*Example:*\n\n>>> secure_random_hex(9) # possible output: 'aac4cf1d1d87bd5036'\n\n:param byte_count: Number of random bytes to generate\n:type byte_count: int\n:return: Hexadecimal string representation of generated random bytes",
        "args": [
            "byte_count"
        ],
        "defaults": [],
        "code": "def secure_random_hex(byte_count: int) -> str:\n    \"\"\"\n    Generates a random string using secure low level random generator (os.urandom).\n\n    **Bear in mind**: due to hex conversion, the returned string will have a size that is exactly\\\n    the double of the given `byte_count`.\n\n    *Example:*\n\n    >>> secure_random_hex(9) # possible output: 'aac4cf1d1d87bd5036'\n\n    :param byte_count: Number of random bytes to generate\n    :type byte_count: int\n    :return: Hexadecimal string representation of generated random bytes\n    \"\"\"\n    if not isinstance(byte_count, int) or byte_count < 1:\n        raise ValueError('byte_count must be >= 1')\n\n    random_bytes = os.urandom(byte_count)\n    hex_bytes = binascii.hexlify(random_bytes)\n    hex_string = hex_bytes.decode()\n\n    return hex_string"
    },
    {
        "name": "roman_range",
        "docstring": "Similarly to native Python's `range()`, returns a Generator object which generates a new roman number\non each iteration instead of an integer.\n\n*Example:*\n\n>>> for n in roman_range(7): print(n)\n>>> # prints: I, II, III, IV, V, VI, VII\n>>> for n in roman_range(start=7, stop=1, step=-1): print(n)\n>>> # prints: VII, VI, V, IV, III, II, I\n\n:param stop: Number at which the generation must stop (must be <= 3999).\n:param start: Number at which the generation must start (must be >= 1).\n:param step: Increment of each generation step (default to 1).\n:return: Generator of roman numbers.",
        "args": [
            "stop",
            "start",
            "step"
        ],
        "defaults": [
            "1",
            "1"
        ],
        "code": "def roman_range(stop: int, start: int = 1, step: int = 1) -> Generator:\n    \"\"\"\n    Similarly to native Python's `range()`, returns a Generator object which generates a new roman number\n    on each iteration instead of an integer.\n\n    *Example:*\n\n    >>> for n in roman_range(7): print(n)\n    >>> # prints: I, II, III, IV, V, VI, VII\n    >>> for n in roman_range(start=7, stop=1, step=-1): print(n)\n    >>> # prints: VII, VI, V, IV, III, II, I\n\n    :param stop: Number at which the generation must stop (must be <= 3999).\n    :param start: Number at which the generation must start (must be >= 1).\n    :param step: Increment of each generation step (default to 1).\n    :return: Generator of roman numbers.\n    \"\"\"\n\n    def validate(arg_value, arg_name, allow_negative=False):\n        msg = '\"{}\" must be an integer in the range 1-3999'.format(arg_name)\n\n        if not isinstance(arg_value, int):\n            raise ValueError(msg)\n\n        if allow_negative:\n            arg_value = abs(arg_value)\n\n        if arg_value < 1 or arg_value > 3999:\n            raise ValueError(msg)\n\n    def generate():\n        current = start\n\n        # generate values for each step\n        while current != stop:\n            yield roman_encode(current)\n            current += step\n\n        # last value to return\n        yield roman_encode(current)\n\n    # checks each single argument value\n    validate(stop, 'stop')\n    validate(start, 'start')\n    validate(step, 'step', allow_negative=True)\n\n    # checks if the provided configuration leads to a feasible iteration with respect to boundaries or not\n    forward_exceed = step > 0 and (start > stop or start + step > stop)\n    backward_exceed = step < 0 and (start < stop or start + step < stop)\n    if forward_exceed or backward_exceed:\n        raise OverflowError('Invalid start/stop/step configuration')\n\n    return generate()"
    },
    {
        "name": "__init__",
        "docstring": ":param input_data: Any received object",
        "args": [
            "self",
            "input_data"
        ],
        "defaults": [],
        "code": "    def __init__(self, input_data: Any):\n        \"\"\"\n        :param input_data: Any received object\n        \"\"\"\n        type_name = type(input_data).__name__\n        msg = 'Expected \"str\", received \"{}\"'.format(type_name)\n        super().__init__(msg)"
    },
    {
        "name": "__init__",
        "docstring": null,
        "args": [
            "self",
            "input_string",
            "normalize"
        ],
        "defaults": [
            "True"
        ],
        "code": "    def __init__(self, input_string: str, normalize: bool = True):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string.replace('-', '') if normalize else input_string"
    },
    {
        "name": "is_isbn_13",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def is_isbn_13(self) -> bool:\n        if len(self.input_string) == 13:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    weight = 1 if (index % 2 == 0) else 3\n                    product += int(digit) * weight\n\n                return product % 10 == 0\n\n            except ValueError:\n                pass\n\n        return False"
    },
    {
        "name": "is_isbn_10",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n\n                return product % 11 == 0\n\n            except ValueError:\n                pass\n\n        return False"
    },
    {
        "name": "is_string",
        "docstring": "Checks if an object is a string.\n\n*Example:*\n\n>>> is_string('foo') # returns true\n>>> is_string(b'foo') # returns false\n\n:param obj: Object to test.\n:return: True if string, false otherwise.",
        "args": [
            "obj"
        ],
        "defaults": [],
        "code": "def is_string(obj: Any) -> bool:\n    \"\"\"\n    Checks if an object is a string.\n\n    *Example:*\n\n    >>> is_string('foo') # returns true\n    >>> is_string(b'foo') # returns false\n\n    :param obj: Object to test.\n    :return: True if string, false otherwise.\n    \"\"\"\n    return isinstance(obj, str)"
    },
    {
        "name": "is_full_string",
        "docstring": "Check if a string is not empty (it must contains at least one non space character).\n\n*Examples:*\n\n>>> is_full_string(None) # returns false\n>>> is_full_string('') # returns false\n>>> is_full_string(' ') # returns false\n>>> is_full_string('hello') # returns true\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if not empty, false otherwise.",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def is_full_string(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is not empty (it must contains at least one non space character).\n\n    *Examples:*\n\n    >>> is_full_string(None) # returns false\n    >>> is_full_string('') # returns false\n    >>> is_full_string(' ') # returns false\n    >>> is_full_string('hello') # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if not empty, false otherwise.\n    \"\"\"\n    return is_string(input_string) and input_string.strip() != ''"
    },
    {
        "name": "is_number",
        "docstring": "Checks if a string is a valid number.\n\nThe number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\nor use the \"scientific notation\" (eg: 1e5).\n\n*Examples:*\n\n>>> is_number('42') # returns true\n>>> is_number('19.99') # returns true\n>>> is_number('-9.12') # returns true\n>>> is_number('1e3') # returns true\n>>> is_number('1 2 3') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if the string represents a number, false otherwise",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def is_number(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid number.\n\n    The number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\n    or use the \"scientific notation\" (eg: 1e5).\n\n    *Examples:*\n\n    >>> is_number('42') # returns true\n    >>> is_number('19.99') # returns true\n    >>> is_number('-9.12') # returns true\n    >>> is_number('1e3') # returns true\n    >>> is_number('1 2 3') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if the string represents a number, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n\n    return NUMBER_RE.match(input_string) is not None"
    },
    {
        "name": "is_integer",
        "docstring": "Checks whether the given string represents an integer or not.\n\nAn integer may be signed or unsigned or use a \"scientific notation\".\n\n*Examples:*\n\n>>> is_integer('42') # returns true\n>>> is_integer('42.0') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' not in input_string"
    },
    {
        "name": "is_decimal",
        "docstring": "Checks whether the given string represents a decimal or not.\n\nA decimal may be signed or unsigned or use a \"scientific notation\".\n\n>>> is_decimal('42.0') # returns true\n>>> is_decimal('42') # returns false\n\n:param input_string: String to check\n:type input_string: str\n:return: True if integer, false otherwise",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' in input_string"
    },
    {
        "name": "is_url",
        "docstring": "Check if a string is a valid url.\n\n*Examples:*\n\n>>> is_url('http://www.mysite.com') # returns true\n>>> is_url('https://mysite.com') # returns true\n>>> is_url('.mysite.com') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n:type allowed_schemes: Optional[List[str]]\n:return: True if url, false otherwise",
        "args": [
            "input_string",
            "allowed_schemes"
        ],
        "defaults": [
            "None"
        ],
        "code": "def is_url(input_string: Any, allowed_schemes: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    valid = URL_RE.match(input_string) is not None\n\n    if allowed_schemes:\n        return valid and any([input_string.startswith(s) for s in allowed_schemes])\n\n    return valid"
    },
    {
        "name": "is_email",
        "docstring": "Check if a string is a valid email.\n\nReference: https://tools.ietf.org/html/rfc3696#section-3\n\n*Examples:*\n\n>>> is_email('my.email@the-provider.com') # returns true\n>>> is_email('@gmail.com') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if email, false otherwise.",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    # first simple \"pre check\": it must be a non empty string with max len 320 and cannot start with a dot\n    if not is_full_string(input_string) or len(input_string) > 320 or input_string.startswith('.'):\n        return False\n\n    try:\n        # we expect 2 tokens, one before \"@\" and one after, otherwise we have an exception and the email is not valid\n        head, tail = input_string.split('@')\n\n        # head's size must be <= 64, tail <= 255, head must not start with a dot or contain multiple consecutive dots\n        if len(head) > 64 or len(tail) > 255 or head.endswith('.') or ('..' in head):\n            return False\n\n        # removes escaped spaces, so that later on the test regex will accept the string\n        head = head.replace('\\\\ ', '')\n        if head.startswith('\"') and head.endswith('\"'):\n            head = head.replace(' ', '')[1:-1]\n\n        return EMAIL_RE.match(head + '@' + tail) is not None\n\n    except ValueError:\n        # borderline case in which we have multiple \"@\" signs but the head part is correctly escaped\n        if ESCAPED_AT_SIGN.search(input_string) is not None:\n            # replace \"@\" with \"a\" in the head\n            return is_email(ESCAPED_AT_SIGN.sub('a', input_string))\n\n        return False"
    },
    {
        "name": "is_credit_card",
        "docstring": "Checks if a string is a valid credit card number.\nIf card type is provided then it checks against that specific type only,\notherwise any known credit card number will be accepted.\n\nSupported card types are the following:\n\n- VISA\n- MASTERCARD\n- AMERICAN_EXPRESS\n- DINERS_CLUB\n- DISCOVER\n- JCB\n\n:param input_string: String to check.\n:type input_string: str\n:param card_type: Card type. Default to None (any card).\n:type card_type: str\n\n:return: True if credit card, false otherwise.",
        "args": [
            "input_string",
            "card_type"
        ],
        "defaults": [
            "None"
        ],
        "code": "def is_credit_card(input_string: Any, card_type: str = None) -> bool:\n    \"\"\"\n    Checks if a string is a valid credit card number.\n    If card type is provided then it checks against that specific type only,\n    otherwise any known credit card number will be accepted.\n\n    Supported card types are the following:\n\n    - VISA\n    - MASTERCARD\n    - AMERICAN_EXPRESS\n    - DINERS_CLUB\n    - DISCOVER\n    - JCB\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param card_type: Card type. Default to None (any card).\n    :type card_type: str\n\n    :return: True if credit card, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    if card_type:\n        if card_type not in CREDIT_CARDS:\n            raise KeyError(\n                'Invalid card type \"{}\". Valid types are: {}'.format(card_type, ', '.join(CREDIT_CARDS.keys()))\n            )\n        return CREDIT_CARDS[card_type].match(input_string) is not None\n\n    for c in CREDIT_CARDS:\n        if CREDIT_CARDS[c].match(input_string) is not None:\n            return True\n\n    return False"
    },
    {
        "name": "is_camel_case",
        "docstring": "Checks if a string is formatted as camel case.\n\nA string is considered camel case when:\n\n- it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n- it contains both lowercase and uppercase letters\n- it does not start with a number\n\n*Examples:*\n\n>>> is_camel_case('MyString') # returns true\n>>> is_camel_case('mystring') # returns false\n\n:param input_string: String to test.\n:type input_string: str\n:return: True for a camel case string, false otherwise.",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def is_camel_case(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and CAMEL_CASE_TEST_RE.match(input_string) is not None"
    },
    {
        "name": "is_snake_case",
        "docstring": "Checks if a string is formatted as \"snake case\".\n\nA string is considered snake case when:\n\n- it's composed only by lowercase/uppercase letters and digits\n- it contains at least one underscore (or provided separator)\n- it does not start with a number\n\n*Examples:*\n\n>>> is_snake_case('foo_bar_baz') # returns true\n>>> is_snake_case('foo') # returns false\n\n:param input_string: String to test.\n:type input_string: str\n:param separator: String to use as separator.\n:type separator: str\n:return: True for a snake case string, false otherwise.",
        "args": [
            "input_string",
            "separator"
        ],
        "defaults": [
            "'_'"
        ],
        "code": "def is_snake_case(input_string: Any, separator: str = '_') -> bool:\n    \"\"\"\n    Checks if a string is formatted as \"snake case\".\n\n    A string is considered snake case when:\n\n    - it's composed only by lowercase/uppercase letters and digits\n    - it contains at least one underscore (or provided separator)\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_snake_case('foo_bar_baz') # returns true\n    >>> is_snake_case('foo') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :param separator: String to use as separator.\n    :type separator: str\n    :return: True for a snake case string, false otherwise.\n    \"\"\"\n    if is_full_string(input_string):\n        re_map = {\n            '_': SNAKE_CASE_TEST_RE,\n            '-': SNAKE_CASE_TEST_DASH_RE\n        }\n        re_template = r'([a-z]+\\d*{sign}[a-z\\d{sign}]*|{sign}+[a-z\\d]+[a-z\\d{sign}]*)'\n        r = re_map.get(\n            separator,\n            re.compile(re_template.format(sign=re.escape(separator)), re.IGNORECASE)\n        )\n\n        return r.match(input_string) is not None\n\n    return False"
    },
    {
        "name": "is_json",
        "docstring": "Check if a string is a valid json.\n\n*Examples:*\n\n>>> is_json('{\"name\": \"Peter\"}') # returns true\n>>> is_json('[1, 2, 3]') # returns true\n>>> is_json('{nope}') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if json, false otherwise",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def is_json(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid json.\n\n    *Examples:*\n\n    >>> is_json('{\"name\": \"Peter\"}') # returns true\n    >>> is_json('[1, 2, 3]') # returns true\n    >>> is_json('{nope}') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if json, false otherwise\n    \"\"\"\n    if is_full_string(input_string) and JSON_WRAPPER_RE.match(input_string) is not None:\n        try:\n            return isinstance(json.loads(input_string), (dict, list))\n        except (TypeError, ValueError, OverflowError):\n            pass\n\n    return False"
    },
    {
        "name": "is_uuid",
        "docstring": "Check if a string is a valid UUID.\n\n*Example:*\n\n>>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n>>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n:param input_string: String to check.\n:type input_string: str\n:param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n:type allow_hex: bool\n:return: True if UUID, false otherwise",
        "args": [
            "input_string",
            "allow_hex"
        ],
        "defaults": [
            "False"
        ],
        "code": "def is_uuid(input_string: Any, allow_hex: bool = False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    # string casting is used to allow UUID itself as input data type\n    s = str(input_string)\n\n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n\n    return UUID_RE.match(s) is not None"
    },
    {
        "name": "is_ip_v4",
        "docstring": "Checks if a string is a valid ip v4.\n\n*Examples:*\n\n>>> is_ip_v4('255.200.100.75') # returns true\n>>> is_ip_v4('nope') # returns false (not an ip)\n>>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if an ip v4, false otherwise.",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string) or SHALLOW_IP_V4_RE.match(input_string) is None:\n        return False\n\n    # checks that each entry in the ip is in the valid range (0 to 255)\n    for token in input_string.split('.'):\n        if not (0 <= int(token) <= 255):\n            return False\n\n    return True"
    },
    {
        "name": "is_ip_v6",
        "docstring": "Checks if a string is a valid ip v6.\n\n*Examples:*\n\n>>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n>>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if a v6 ip, false otherwise.",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and IP_V6_RE.match(input_string) is not None"
    },
    {
        "name": "is_ip",
        "docstring": "Checks if a string is a valid ip (either v4 or v6).\n\n*Examples:*\n\n>>> is_ip('255.200.100.75') # returns true\n>>> is_ip('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n>>> is_ip('1.2.3') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if an ip, false otherwise.",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def is_ip(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip (either v4 or v6).\n\n    *Examples:*\n\n    >>> is_ip('255.200.100.75') # returns true\n    >>> is_ip('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip('1.2.3') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip, false otherwise.\n    \"\"\"\n    return is_ip_v6(input_string) or is_ip_v4(input_string)"
    },
    {
        "name": "is_palindrome",
        "docstring": "Checks if the string is a palindrome (https://en.wikipedia.org/wiki/Palindrome).\n\n*Examples:*\n\n>>> is_palindrome('LOL') # returns true\n>>> is_palindrome('Lol') # returns false\n>>> is_palindrome('Lol', ignore_case=True) # returns true\n>>> is_palindrome('ROTFL') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:param ignore_spaces: False if white spaces matter (default), true otherwise.\n:type ignore_spaces: bool\n:param ignore_case: False if char case matters (default), true otherwise.\n:type ignore_case: bool\n:return: True if the string is a palindrome (like \"otto\", or \"i topi non avevano nipoti\" if strict=False),    False otherwise",
        "args": [
            "input_string",
            "ignore_spaces",
            "ignore_case"
        ],
        "defaults": [
            "False",
            "False"
        ],
        "code": "def is_palindrome(input_string: Any, ignore_spaces: bool = False, ignore_case: bool = False) -> bool:\n    \"\"\"\n    Checks if the string is a palindrome (https://en.wikipedia.org/wiki/Palindrome).\n\n    *Examples:*\n\n    >>> is_palindrome('LOL') # returns true\n    >>> is_palindrome('Lol') # returns false\n    >>> is_palindrome('Lol', ignore_case=True) # returns true\n    >>> is_palindrome('ROTFL') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param ignore_spaces: False if white spaces matter (default), true otherwise.\n    :type ignore_spaces: bool\n    :param ignore_case: False if char case matters (default), true otherwise.\n    :type ignore_case: bool\n    :return: True if the string is a palindrome (like \"otto\", or \"i topi non avevano nipoti\" if strict=False),\\\n    False otherwise\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    if ignore_spaces:\n        input_string = SPACES_RE.sub('', input_string)\n\n    string_len = len(input_string)\n\n    # Traverse the string one char at step, and for each step compares the\n    # \"head_char\" (the one on the left of the string) to the \"tail_char\" (the one on the right).\n    # In this way we avoid to manipulate the whole string in advance if not necessary and provide a faster\n    # algorithm which can scale very well for long strings.\n    for index in range(string_len):\n        head_char = input_string[index]\n        tail_char = input_string[string_len - index - 1]\n\n        if ignore_case:\n            head_char = head_char.lower()\n            tail_char = tail_char.lower()\n\n        if head_char != tail_char:\n            return False\n\n    return True"
    },
    {
        "name": "is_pangram",
        "docstring": "Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n*Examples:*\n\n>>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n>>> is_pangram('hello world') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if the string is a pangram, False otherwise.",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def is_pangram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n    *Examples:*\n\n    >>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n    >>> is_pangram('hello world') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if the string is a pangram, False otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    return set(SPACES_RE.sub('', input_string)).issuperset(set(string.ascii_lowercase))"
    },
    {
        "name": "is_isogram",
        "docstring": "Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n*Examples:*\n\n>>> is_isogram('dermatoglyphics') # returns true\n>>> is_isogram('hello') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if isogram, false otherwise.",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def is_isogram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n    *Examples:*\n\n    >>> is_isogram('dermatoglyphics') # returns true\n    >>> is_isogram('hello') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if isogram, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and len(set(input_string)) == len(input_string)"
    },
    {
        "name": "is_slug",
        "docstring": "Checks if a given string is a slug (as created by `slugify()`).\n\n*Examples:*\n\n>>> is_slug('my-blog-post-title') # returns true\n>>> is_slug('My blog post title') # returns false\n\n:param input_string: String to check.\n:type input_string: str\n:param separator: Join sign used by the slug.\n:type separator: str\n:return: True if slug, false otherwise.",
        "args": [
            "input_string",
            "separator"
        ],
        "defaults": [
            "'-'"
        ],
        "code": "def is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    rex = r'^([a-z\\d]+' + re.escape(separator) + r'*?)*[a-z\\d]$'\n\n    return re.match(rex, input_string) is not None"
    },
    {
        "name": "contains_html",
        "docstring": "Checks if the given string contains HTML/XML tags.\n\nBy design, this function matches ANY type of tag, so don't expect to use it\nas an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n*Examples:*\n\n>>> contains_html('my string is <strong>bold</strong>') # returns true\n>>> contains_html('my string is not bold') # returns false\n\n:param input_string: Text to check\n:type input_string: str\n:return: True if string contains html, false otherwise.",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def contains_html(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string contains HTML/XML tags.\n\n    By design, this function matches ANY type of tag, so don't expect to use it\n    as an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n    *Examples:*\n\n    >>> contains_html('my string is <strong>bold</strong>') # returns true\n    >>> contains_html('my string is not bold') # returns false\n\n    :param input_string: Text to check\n    :type input_string: str\n    :return: True if string contains html, false otherwise.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return HTML_RE.search(input_string) is not None"
    },
    {
        "name": "words_count",
        "docstring": "Returns the number of words contained into the given string.\n\nThis method is smart, it does consider only sequence of one or more letter and/or numbers\nas \"words\", so a string like this: \"! @ # % ... []\" will return zero!\nMoreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\nwill be 4 not 1 (even if there are no spaces in the string).\n\n*Examples:*\n\n>>> words_count('hello world') # returns 2\n>>> words_count('one,two,three.stop') # returns 4\n\n:param input_string: String to check.\n:type input_string: str\n:return: Number of words.",
        "args": [
            "input_string"
        ],
        "defaults": [],
        "code": "def words_count(input_string: str) -> int:\n    \"\"\"\n    Returns the number of words contained into the given string.\n\n    This method is smart, it does consider only sequence of one or more letter and/or numbers\n    as \"words\", so a string like this: \"! @ # % ... []\" will return zero!\n    Moreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\n    will be 4 not 1 (even if there are no spaces in the string).\n\n    *Examples:*\n\n    >>> words_count('hello world') # returns 2\n    >>> words_count('one,two,three.stop') # returns 4\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: Number of words.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return len(WORDS_COUNT_RE.findall(input_string))"
    },
    {
        "name": "is_isbn_10",
        "docstring": "Checks if the given string represents a valid ISBN 10 (International Standard Book Number).\nBy default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\nfunction with `normalize=False` only digit-only strings will pass the validation.\n\n*Examples:*\n\n>>> is_isbn_10('1506715214') # returns true\n>>> is_isbn_10('150-6715214') # returns true\n>>> is_isbn_10('150-6715214', normalize=False) # returns false\n\n:param input_string: String to check.\n:param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n:return: True if valid ISBN 10, false otherwise.",
        "args": [
            "input_string",
            "normalize"
        ],
        "defaults": [
            "True"
        ],
        "code": "def is_isbn_10(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN 10 (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn_10('1506715214') # returns true\n    >>> is_isbn_10('150-6715214') # returns true\n    >>> is_isbn_10('150-6715214', normalize=False) # returns false\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN 10, false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_10()"
    },
    {
        "name": "is_isbn_13",
        "docstring": "Checks if the given string represents a valid ISBN 13 (International Standard Book Number).\nBy default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\nfunction with `normalize=False` only digit-only strings will pass the validation.\n\n*Examples:*\n\n>>> is_isbn_13('9780312498580') # returns true\n>>> is_isbn_13('978-0312498580') # returns true\n>>> is_isbn_13('978-0312498580', normalize=False) # returns false\n\n:param input_string: String to check.\n:param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n:return: True if valid ISBN 13, false otherwise.",
        "args": [
            "input_string",
            "normalize"
        ],
        "defaults": [
            "True"
        ],
        "code": "def is_isbn_13(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN 13 (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn_13('9780312498580') # returns true\n    >>> is_isbn_13('978-0312498580') # returns true\n    >>> is_isbn_13('978-0312498580', normalize=False) # returns false\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN 13, false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_13()"
    },
    {
        "name": "is_isbn",
        "docstring": "Checks if the given string represents a valid ISBN (International Standard Book Number).\nBy default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\nfunction with `normalize=False` only digit-only strings will pass the validation.\n\n*Examples:*\n\n>>> is_isbn('9780312498580') # returns true\n>>> is_isbn('1506715214') # returns true\n\n:param input_string: String to check.\n:param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n:return: True if valid ISBN (10 or 13), false otherwise.",
        "args": [
            "input_string",
            "normalize"
        ],
        "defaults": [
            "True"
        ],
        "code": "def is_isbn(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn('9780312498580') # returns true\n    >>> is_isbn('1506715214') # returns true\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN (10 or 13), false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_13() or checker.is_isbn_10()"
    }
]