[
    [
        "def reverse(input_string: str) -> str:\n    \"\"\"\n    Returns the string with its chars reversed.\n\n    *Example:*\n\n    >>> reverse('hello') # returns 'olleh'\n\n    :param input_string: String to revert.\n    :type input_string: str\n    :return: Reversed string.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n\n    return input_string[::-1]",
        "def reverse(input_string: str) -> str:\n    \"\"\"\n    Returns the string with its chars reversed.\n\n    *Example:*\n\n    >>> reverse('hello') # returns 'olleh'\n\n    :param input_string: String to revert.\n    :type input_string: str\n    :return: Reversed string.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n\n    return input_string[::-1]",
        "def reverse(input_string: str) -> str:\n    \"\"\"\n    Returns the string with its chars reversed.\n\n    *Example:*\n\n    >>> reverse('hello') # returns 'olleh'\n\n    :param input_string: String to revert.\n    :type input_string: str\n    :return: Reversed string.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n\n    return input_string[::-1]",
        "def reverse(input_string: str) -> str:\n    \"\"\"\n    Returns the string with its chars reversed.\n\n    *Example:*\n\n    >>> reverse('hello') # returns 'olleh'\n\n    :param input_string: String to revert.\n    :type input_string: str\n    :return: Reversed string.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n\n    return input_string[::-1]",
        "def reverse(input_string: str) -> str:\n    \"\"\"\n    Returns the string with its chars reversed.\n\n    *Example:*\n\n    >>> reverse('hello') # returns 'olleh'\n\n    :param input_string: String to revert.\n    :type input_string: str\n    :return: Reversed string.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n\n    return input_string[::-1]"
    ],
    [
        "def camel_case_to_snake(input_string, separator='_'):\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n    if not isinstance(separator, str):\n        raise TypeError(\"separator must be a string\")\n    \n    if any(char.isspace() for char in input_string) or not input_string:\n        return input_string\n    \n    result = []\n    \n    for index, char in enumerate(input_string):\n        if char.isupper():\n            if index > 0:\n                result.append(separator)\n            result.append(char.lower())\n        else:\n            result.append(char)\n    \n    return ''.join(result)",
        "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n    \n    if not isinstance(separator, str):\n        raise TypeError(\"separator must be a string\")\n    \n    if any(not char.isalnum() and char != '_' for char in input_string):\n        return input_string\n\n    snake_case_string = \"\"\n    for index, char in enumerate(input_string):\n        if char.isupper():\n            if index != 0:\n                snake_case_string += separator\n            snake_case_string += char.lower()\n        else:\n            snake_case_string += char\n            \n    return snake_case_string",
        "def camel_case_to_snake(input_string, separator='_'):\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n    if not isinstance(separator, str):\n        raise TypeError(\"separator must be a string\")\n    \n    result = []\n    for index, char in enumerate(input_string):\n        if char.isupper():\n            if index != 0:\n                result.append(separator)\n            result.append(char.lower())\n        elif char.islower():\n            result.append(char)\n        else:\n            return input_string  # Return original if invalid character found\n    \n    return ''.join(result)",
        "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n    \n    if not isinstance(separator, str):\n        raise TypeError(\"separator must be a string\")\n\n    if any(char.isspace() for char in input_string) or any(not char.isalnum() and char != '_' for char in input_string):\n        return input_string\n    \n    snake_case_string = \"\"\n    \n    for index, char in enumerate(input_string):\n        if char.isupper():\n            if index > 0:\n                snake_case_string += separator\n            snake_case_string += char.lower()\n        else:\n            snake_case_string += char\n\n    return snake_case_string",
        "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n    if not isinstance(separator, str):\n        raise TypeError(\"separator must be a string\")\n    \n    result = []\n    for i, char in enumerate(input_string):\n        if char.isupper():\n            if i > 0:\n                result.append(separator)\n            result.append(char.lower())\n        elif not char.isalnum():\n            return input_string  # Invalid character found\n        else:\n            result.append(char)\n    \n    snake_case_string = ''.join(result)\n    \n    return snake_case_string if snake_case_string != input_string else input_string"
    ],
    [
        "def snake_case_to_camel(input_string: str, upper_case_first: bool = True, separator: str = '_') -> str:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    if not all(c.islower() or c.isdigit() or c == separator for c in input_string) or input_string.startswith(separator) or input_string.endswith(separator):\n        return input_string\n\n    components = input_string.split(separator)\n\n    if upper_case_first:\n        components[0] = components[0].capitalize()\n    else:\n        components[0] = components[0].lower()\n\n    for i in range(1, len(components)):\n        components[i] = components[i].capitalize()\n\n    return ''.join(components)",
        "def snake_case_to_camel(input_string: str, upper_case_first: bool = True, separator: str = '_') -> str:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Check if the input string is valid snake_case\n    if not all(c.islower() or c.isdigit() or c == separator for c in input_string) or input_string.startswith(separator) or input_string.endswith(separator) or separator * 2 in input_string:\n        return input_string\n\n    components = input_string.split(separator)\n\n    if upper_case_first:\n        components[0] = components[0].capitalize()\n    else:\n        components[0] = components[0].lower()\n\n    # Capitalize the first letter of each subsequent component\n    for i in range(1, len(components)):\n        components[i] = components[i].capitalize()\n\n    return ''.join(components)",
        "def snake_case_to_camel(input_string: str, upper_case_first: bool = True, separator: str = '_') -> str:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    if not all(c.islower() or c.isdigit() or c == separator for c in input_string) or \\\n       input_string.startswith(separator) or input_string.endswith(separator) or \\\n       separator * 2 in input_string:\n        return input_string\n\n    components = input_string.split(separator)\n\n    if upper_case_first:\n        components[0] = components[0].capitalize()\n    else:\n        components[0] = components[0].lower()\n\n    components[1:] = [c.capitalize() for c in components[1:]]\n\n    return ''.join(components)",
        "def snake_case_to_camel(input_string: str, upper_case_first: bool = True, separator: str = '_') -> str:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    if not all(c.islower() or c.isdigit() or c == separator for c in input_string) or input_string.startswith(separator) or input_string.endswith(separator):\n        return input_string\n\n    components = input_string.split(separator)\n    \n    if upper_case_first:\n        camel_case = ''.join(component.capitalize() for component in components)\n    else:\n        camel_case = components[0] + ''.join(component.capitalize() for component in components[1:])\n    \n    return camel_case",
        "def snake_case_to_camel(input_string: str, upper_case_first: bool = True, separator: str = '_') -> str:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    if not all(c.islower() or c.isdigit() or c == separator for c in input_string) or input_string.startswith(separator) or input_string.endswith(separator):\n        return input_string\n\n    components = input_string.split(separator)\n    \n    if upper_case_first:\n        components[0] = components[0].capitalize()\n    else:\n        components[0] = components[0].lower()\n\n    components[1:] = [word.capitalize() for word in components[1:]]\n\n    return ''.join(components)"
    ],
    [
        "import re\n\ndef strip_html(input_string: str, keep_tag_content: bool = False) -> str:\n    \"\"\"\n    Remove html code contained into the given string.\n\n    *Examples:*\n\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>') # returns 'test: '\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>', keep_tag_content=True) # returns 'test: click here'\n\n    :param input_string: String to manipulate.\n    :type input_string: str\n    :param keep_tag_content: True to preserve tag content, False to remove tag and its content too (default).\n    :type keep_tag_content: bool\n    :return: String with html removed.\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n\n    if keep_tag_content:\n        # Regex to extract contents of HTML tags\n        return re.sub(r'<[^>]+>', '', input_string)\n    else:\n        # Regex to remove HTML tags and their contents\n        return re.sub(r'<.*?>.*?</.*?>|<[^>]+>', '', input_string)",
        "import re\n\ndef strip_html(input_string: str, keep_tag_content: bool = False) -> str:\n    \"\"\"\n    Remove html code contained into the given string.\n\n    *Examples:*\n\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>') # returns 'test: '\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>', keep_tag_content=True) # returns 'test: click here'\n\n    :param input_string: String to manipulate.\n    :type input_string: str\n    :param keep_tag_content: True to preserve tag content, False to remove tag and its content too (default).\n    :type keep_tag_content: bool\n    :return: String with html removed.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    if keep_tag_content:\n        # Remove HTML tags but keep the content\n        return re.sub(r'<[^>]+>', '', input_string)\n    else:\n        # Remove HTML tags and their content\n        return re.sub(r'<[^>]+>.*?</[^>]+>', '', input_string)",
        "import re\n\ndef strip_html(input_string: str, keep_tag_content: bool = False) -> str:\n    \"\"\"\n    Remove html code contained into the given string.\n\n    *Examples:*\n\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>') # returns 'test: '\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>', keep_tag_content=True) # returns 'test: click here'\n\n    :param input_string: String to manipulate.\n    :type input_string: str\n    :param keep_tag_content: True to preserve tag content, False to remove tag and its content too (default).\n    :type keep_tag_content: bool\n    :return: String with html removed.\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    if keep_tag_content:\n        # Regex to extract content within the HTML tags\n        return re.sub(r'<[^>]+>', '', input_string)\n    else:\n        # Regex to remove the whole HTML (tags and content)\n        return re.sub(r'<.*?>.*?</.*?>', '', input_string)",
        "import re\n\ndef strip_html(input_string: str, keep_tag_content: bool = False) -> str:\n    \"\"\"\n    Remove html code contained into the given string.\n\n    *Examples:*\n\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>') # returns 'test: '\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>', keep_tag_content=True) # returns 'test: click here'\n\n    :param input_string: String to manipulate.\n    :type input_string: str\n    :param keep_tag_content: True to preserve tag content, False to remove tag and its content too (default).\n    :type keep_tag_content: bool\n    :return: String with html removed.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n    \n    if keep_tag_content:\n        # Regex to only remove tags but keep their content\n        return re.sub(r'<.*?>', '', input_string)\n    else:\n        # Regex to remove tags and their content\n        return re.sub(r'<.*?>.*?(?=<|$)', '', input_string)",
        "import re\n\ndef strip_html(input_string: str, keep_tag_content: bool = False) -> str:\n    \"\"\"\n    Remove html code contained into the given string.\n\n    *Examples:*\n\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>') # returns 'test: '\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>', keep_tag_content=True) # returns 'test: click here'\n\n    :param input_string: String to manipulate.\n    :type input_string: str\n    :param keep_tag_content: True to preserve tag content, False to remove tag and its content too (default).\n    :type keep_tag_content: bool\n    :return: String with html removed.\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    if keep_tag_content:\n        # Regex to remove HTML tags but keep the content\n        return re.sub(r'<[^>]+>', '', input_string)\n    else:\n        # Regex to remove HTML tags and their content\n        return re.sub(r'<[^>]*>.*?</[^>]*>', '', input_string, flags=re.DOTALL)"
    ],
    [
        "import re\n\ndef prettify(input_string: str) -> str:\n    if not isinstance(input_string, str) or not input_string:\n        raise ValueError(\"Input must be a non-empty string.\")\n    \n    input_string = input_string.strip()\n    \n    # Capitalize first letters\n    input_string = re.sub(r'(?<!\\w)([A-Za-z])', lambda m: m.group(0).upper(), input_string)\n    input_string = re.sub(r'([.!?])\\s*([a-z])', lambda m: m.group(1) + ' ' + m.group(2).upper(), input_string)\n    \n    # Remove multiple sequential spaces\n    input_string = re.sub(r'\\s{2,}', ' ', input_string)\n    \n    # Handle removing empty lines\n    input_string = re.sub(r'\\n+', '\\n', input_string).strip()\n    \n    # Ensure punctuation spacing\n    input_string = re.sub(r'([.!?])\\s*', r'\\1 ', input_string)\n    \n    # Ensure there is one space around arithmetic operators\n    input_string = re.sub(r'\\s*([\\+\\-\\*/=])\\s*', r' \\1 ', input_string)\n    \n    # Handle quotes\n    input_string = re.sub(r'\\s*(\")', r' \"\\1', input_string)\n    input_string = re.sub(r'(\")\\s*', r'\\1 ', input_string)\n    \n    # Handle brackets\n    input_string = re.sub(r'\\s*(\\()', r' \\1', input_string)\n    input_string = re.sub(r'(\\))\\s*', r'\\1 ', input_string)\n    \n    # Percentage sign formatting\n    input_string = re.sub(r'(\\d+)\\s*%', r'\\1%', input_string)\n    \n    # Saxon genitive formatting\n    input_string = re.sub(r'(\\w+)\\'\\s*s', r'\\1\\'s', input_string)\n    \n    return input_string.strip()",
        "import re\n\ndef prettify(input_string: str) -> str:\n    if not isinstance(input_string, str) or not input_string:\n        raise ValueError(\"Input must be a non-empty string.\")\n    \n    # Trim leading and trailing spaces\n    input_string = input_string.strip()\n\n    # Capitalize the first letter of the string and letters after '.', '!', '?'\n    def capitalize_after_punctuation(match):\n        return match.group(1) + match.group(2).upper()\n\n    input_string = re.sub(r'(^|\\.)\\s*([a-z])', capitalize_after_punctuation, input_string.capitalize())\n\n    # Replace multiple spaces with a single space\n    input_string = re.sub(r'\\s{2,}', ' ', input_string)\n    \n    # Remove empty lines\n    input_string = re.sub(r'\\n\\s*\\n', '\\n', input_string)\n\n    # Ensure correct spacing around punctuation\n    input_string = re.sub(r'([.?!])\\s+', r'\\1 ', input_string)  # one space after ., !, ?\n    input_string = re.sub(r'(?<!\\s)([.?!])', r'\\1 ', input_string)  # ensure space after ., !, ?\n    input_string = re.sub(r'\\s*([.?!])', r'\\1', input_string)  # remove space before ., !, ?\n\n    # Ensure spacing around arithmetic operators\n    input_string = re.sub(r'\\s*([+\\-*/=])\\s*', r' \\1 ', input_string)\n    \n    # Handle double quotes\n    input_string = re.sub(r'\\s*(\"\\s*|\\s*\")', r'\"', input_string)\n    input_string = re.sub(r'\"(.*?)\"', lambda x: f'\"{x.group(1).strip()}\"', input_string)\n\n    # Handle round brackets\n    input_string = re.sub(r'\\s*[\\(\\s]*|\\s*[\\)\\s]*', '', input_string)  # remove extra spaces around parentheses\n    input_string = re.sub(r'\\s*\\(\\s*', ' (', input_string)  # add space before '('\n    input_string = re.sub(r'\\s*\\)\\s*', ' ) ', input_string)  # add space after ')'\n\n    # Percentage sign formatting\n    input_string = re.sub(r'(\\d)\\s*%', r'\\1%', input_string)\n\n    # Fix Saxon genitive\n    input_string = re.sub(r\"(\\b\\w+)\\s*'s\", r\"\\1's\", input_string)\n\n    return input_string.strip()",
        "def prettify(input_string: str) -> str:\n    import re\n\n    if not isinstance(input_string, str) or not input_string:\n        raise ValueError(\"Input must be a non-empty string\")\n\n    # Trim leading and trailing spaces\n    input_string = input_string.strip()\n\n    # Capitalize first letter and after '.', '!', or '?'\n    input_string = re.sub(r'(?<=\\.|\\!|\\?|\\n)(\\s*)(\\w)', lambda m: m.group(0) + m.group(2).upper(), input_string)\n    input_string = input_string.capitalize()\n\n    # Remove multiple sequential spaces and empty lines\n    input_string = re.sub(r'\\n+', '\\n', input_string)\n    input_string = re.sub(r'\\s{2,}', ' ', input_string)\n\n    # Handle punctuation spaces\n    input_string = re.sub(r'([?!.,])\\s*', r'\\1 ', input_string)\n    input_string = re.sub(r'\\s*([?!.,])', r'\\1', input_string)\n\n    # ARITHMETIC OPERATORS\n    input_string = re.sub(r'\\s*([\\+\\-\\*/=])\\s*', r' \\1 ', input_string)\n\n    # Text inside double quotes\n    input_string = re.sub(r'\"\\s*', ' \"', input_string)\n    input_string = re.sub(r'\\s*\"', '\"', input_string)\n\n    # Text inside round brackets\n    input_string = re.sub(r'\\(\\s*', ' (', input_string)\n    input_string = re.sub(r'\\s*\\)', ')', input_string)\n    \n    # Percentage formatting\n    input_string = re.sub(r'(\\d)\\s*%', r'\\1%', input_string)\n\n    # Saxon genitive\n    input_string = re.sub(r\"(\\w)'s\", r\"\\1's\", input_string)\n\n    # Final trimming of spaces\n    input_string = re.sub(r'\\s+', ' ', input_string).strip()\n\n    return input_string",
        "import re\n\ndef prettify(input_string: str) -> str:\n    if not isinstance(input_string, str) or not input_string:\n        raise ValueError(\"Input must be a non-empty string\")\n\n    # Step 1: Trim leading and trailing spaces\n    input_string = input_string.strip()\n\n    # Step 2: Capitalize the first letter and letters after punctuation\n    def capitalize_after_punct(text):\n        sentences = re.split(r'([.!?])', text)\n        for i in range(1, len(sentences), 2):\n            sentences[i] = sentences[i].strip().capitalize()\n        return ''.join(sentences)\n\n    input_string = capitalize_after_punct(input_string)\n\n    # Step 3: Remove multiple sequential spaces and empty lines\n    input_string = re.sub(r'\\s+', ' ', input_string)\n    \n    # Step 4: Proper handling of the punctuation\n    input_string = re.sub(r'([,.!?])\\s*', r'\\1 ', input_string)\n    input_string = re.sub(r'([,.!?]) +', r'\\1 ', input_string)\n\n    # Step 5: Handling spaces around arithmetic operators\n    input_string = re.sub(r'\\s*([\\+\\-\\*/=])\\s*', r' \\1 ', input_string)\n\n    # Step 6: Formatting double quotes and round brackets\n    input_string = re.sub(r'\\s+\"([^\"]+?)\"\\s*', r' \"\\1\" ', input_string)\n    input_string = re.sub(r'\\s+\\([\\s]*(.*?)\\s+\\)', r' (\\1) ', input_string)\n\n    # Step 7: Correct formatting for percentage signs\n    input_string = re.sub(r'(\\d)\\s*%', r'\\1%', input_string)\n\n    # Step 8: Fix Saxon genitive\n    input_string = re.sub(r\"(\\w)'\\s+s\\b\", r\"\\1's\", input_string)\n\n    # Step 9: Final trim and correction\n    return input_string.strip()",
        "def prettify(input_string: str) -> str:\n    import re\n\n    if not isinstance(input_string, str) or not input_string:\n        raise ValueError(\"Input must be a non-empty string.\")\n\n    # Trim the string\n    input_string = input_string.strip()\n\n    # Function to capitalize the first letter of a sentence\n    def capitalize_sentences(text):\n        return re.sub(r'([.?!]\\s*)(\\w)', lambda x: x.group(0) + x.group(2).upper(), text.capitalize())\n\n    # Capitalize the first letter and after ., ?, !\n    input_string = capitalize_sentences(input_string)\n\n    # Remove multiple spaces and normalize other spaces\n    input_string = re.sub(r'\\s+', ' ', input_string)\n\n    # Remove empty lines\n    input_string = re.sub(r'\\n+', '\\n', input_string)\n\n    # Format for arithmetic operators\n    input_string = re.sub(r'\\s*([\\+\\-\\*/=])\\s*', r' \\1 ', input_string)\n\n    # Ensure one space after punctuation marks\n    input_string = re.sub(r'([,?.!])\\s*', r'\\1 ', input_string)\n\n    # Handle double quotes\n    input_string = re.sub(r'\\s*\"\\s*', ' \" ', input_string)\n    input_string = re.sub(r'\\s*\"\\s*', ' \" ', input_string)\n\n    # Handle round brackets\n    input_string = re.sub(r'\\s*\\(\\s*', ' (', input_string)\n    input_string = re.sub(r'\\s*\\)\\s*', ') ', input_string)\n\n    # Ensure percentage sign has no space before\n    input_string = re.sub(r'(\\d)\\s*%', r'\\1%', input_string)\n\n    # Fix Saxon genitive\n    input_string = re.sub(r\"(\\w) ' s\", r\"\\1's\", input_string)\n\n    # Final cleanup\n    input_string = input_string.strip()\n    \n    return input_string"
    ],
    [
        "import unicodedata\n\ndef asciify(input_string: str) -> str:\n    \"\"\"\n    Force string content to be ascii-only by translating all non-ascii chars into the closest possible representation\n    (eg: \u00f3 -> o, \u00cb -> E, \u00e7 -> c...).\n\n    **Bear in mind**: Some chars may be lost if impossible to translate.\n\n    *Example:*\n\n    >>> asciify('\u00e8\u00e9\u00f9\u00fa\u00f2\u00f3\u00e4\u00e5\u00eb\u00fd\u00f1\u00c5\u00c0\u00c1\u00c7\u00cc\u00cd\u00d1\u00d3\u00cb') # returns 'eeuuooaaeynAAACIINOE'\n\n    :param input_string: String to convert\n    :return: Ascii utf-8 string\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    # Normalize the string to decompose combined characters\n    normalized = unicodedata.normalize('NFKD', input_string)\n    \n    # Encode the normalized string to ASCII and ignore errors\n    ascii_bytes = normalized.encode('ascii', 'ignore')\n    \n    # Decode the bytes back to a UTF-8 string\n    ascii_string = ascii_bytes.decode('utf-8')\n    \n    return ascii_string",
        "import unicodedata\n\ndef asciify(input_string: str) -> str:\n    \"\"\"\n    Force string content to be ascii-only by translating all non-ascii chars into the closest possible representation\n    (eg: \u00f3 -> o, \u00cb -> E, \u00e7 -> c...).\n\n    **Bear in mind**: Some chars may be lost if impossible to translate.\n\n    *Example:*\n\n    >>> asciify('\u00e8\u00e9\u00f9\u00fa\u00f2\u00f3\u00e4\u00e5\u00eb\u00fd\u00f1\u00c5\u00c0\u00c1\u00c7\u00cc\u00cd\u00d1\u00d3\u00cb') # returns 'eeuuooaaeynAAACIINOE'\n\n    :param input_string: String to convert\n    :return: Ascii utf-8 string\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Normalize the input string to get the closest ASCII representation\n    normalized = unicodedata.normalize('NFKD', input_string)\n    \n    # Encode the normalized string to ASCII, ignoring errors\n    ascii_bytes = normalized.encode('ascii', 'ignore')\n    \n    # Decode the bytes back to a string\n    ascii_string = ascii_bytes.decode('utf-8')\n    \n    return ascii_string",
        "import unicodedata\n\ndef asciify(input_string: str) -> str:\n    \"\"\"\n    Force string content to be ascii-only by translating all non-ascii chars into the closest possible representation\n    (eg: \u00f3 -> o, \u00cb -> E, \u00e7 -> c...).\n\n    **Bear in mind**: Some chars may be lost if impossible to translate.\n\n    *Example:*\n\n    >>> asciify('\u00e8\u00e9\u00f9\u00fa\u00f2\u00f3\u00e4\u00e5\u00eb\u00fd\u00f1\u00c5\u00c0\u00c1\u00c7\u00cc\u00cd\u00d1\u00d3\u00cb') # returns 'eeuuooaaeynAAACIINOE'\n\n    :param input_string: String to convert\n    :return: Ascii utf-8 string\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(f\"Expected a string, got {type(input_string).__name__}\")\n\n    normalized = unicodedata.normalize('NFKD', input_string)\n    ascii_bytes = normalized.encode('ascii', 'ignore')\n    ascii_string = ascii_bytes.decode('utf-8')\n\n    return ascii_string",
        "import unicodedata\n\ndef asciify(input_string: str) -> str:\n    \"\"\"\n    Force string content to be ascii-only by translating all non-ascii chars into the closest possible representation\n    (eg: \u00f3 -> o, \u00cb -> E, \u00e7 -> c...).\n\n    **Bear in mind**: Some chars may be lost if impossible to translate.\n\n    *Example:*\n\n    >>> asciify('\u00e8\u00e9\u00f9\u00fa\u00f2\u00f3\u00e4\u00e5\u00eb\u00fd\u00f1\u00c5\u00c0\u00c1\u00c7\u00cc\u00cd\u00d1\u00d3\u00cb') # returns 'eeuuooaaeynAAACIINOE'\n\n    :param input_string: String to convert\n    :return: Ascii utf-8 string\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(f\"Input must be a string, got {type(input_string).__name__}\")\n\n    # \"NFKD\" is the algorithm which is able to successfully translate the most of non-ascii chars\n    normalized = unicodedata.normalize('NFKD', input_string)\n\n    # encode string forcing ascii and ignore any errors (unrepresentable chars will be stripped out)\n    ascii_bytes = normalized.encode('ascii', 'ignore')\n\n    # turns encoded bytes into an utf-8 string\n    ascii_string = ascii_bytes.decode('utf-8')\n\n    return ascii_string",
        "import unicodedata\n\ndef asciify(input_string: str) -> str:\n    \"\"\"\n    Force string content to be ascii-only by translating all non-ascii chars into the closest possible representation\n    (eg: \u00f3 -> o, \u00cb -> E, \u00e7 -> c...).\n\n    **Bear in mind**: Some chars may be lost if impossible to translate.\n\n    *Example:*\n\n    >>> asciify('\u00e8\u00e9\u00f9\u00fa\u00f2\u00f3\u00e4\u00e5\u00eb\u00fd\u00f1\u00c5\u00c0\u00c1\u00c7\u00cc\u00cd\u00d1\u00d3\u00cb') # returns 'eeuuooaaeynAAACIINOE'\n\n    :param input_string: String to convert\n    :return: Ascii utf-8 string\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(f\"Expected input to be a string, got {type(input_string).__name__}\")\n\n    # \"NFKD\" is the algorithm which is able to successfully translate the most of non-ascii chars\n    normalized = unicodedata.normalize('NFKD', input_string)\n\n    # encode string forcing ascii and ignore any errors (unrepresentable chars will be stripped out)\n    ascii_bytes = normalized.encode('ascii', 'ignore')\n\n    # turns encoded bytes into an utf-8 string\n    ascii_string = ascii_bytes.decode('utf-8')\n\n    return ascii_string"
    ],
    [
        "import re\n\ndef asciify(input_string: str) -> str:\n    # Placeholder for the asciify function which should convert non-ASCII characters\n    return input_string.encode('ascii', 'ignore').decode('ascii')\n\ndef slugify(input_string: str, separator: str = '-') -> str:\n    if not isinstance(input_string, str) or not isinstance(separator, str):\n        raise TypeError(\"Both input_string and separator must be of type str.\")\n    \n    # Convert to lower case\n    input_string = input_string.lower()\n    \n    # Remove leading and trailing spaces\n    input_string = input_string.strip()\n    \n    # Remove punctuation and non-alphanumeric characters (keep spaces)\n    input_string = re.sub(r'[^a-z0-9\\s]', '', input_string)\n    \n    # Split by whitespace\n    words = input_string.split()\n    \n    # Asciify each word and join using the separator\n    slug = separator.join(asciify(word) for word in words)\n    \n    return slug",
        "import re\n\ndef asciify(input_string: str) -> str:\n    return input_string.encode('ascii', 'ignore').decode('ascii')\n\ndef slugify(input_string: str, separator: str = '-') -> str:\n    if not isinstance(input_string, str) or not isinstance(separator, str):\n        raise TypeError(\"Both input_string and separator must be strings.\")\n\n    # Convert to lower case\n    input_string = input_string.lower()\n\n    # Remove spaces\n    input_string = input_string.strip()\n\n    # Remove punctuation and non-alphanumeric characters\n    input_string = re.sub(r'[^\\w\\s-]', '', input_string)\n\n    # Replace spaces and multiple hyphens with the separator\n    input_string = re.sub(r'[\\s]+', ' ', input_string)\n    input_string = input_string.replace(' ', separator)\n\n    # Asciify the string\n    input_string = asciify(input_string)\n\n    return input_string",
        "import re\n\ndef asciify(input_string: str) -> str:\n    # This example function should convert non-ASCII characters to ASCII.\n    return input_string.encode('ascii', 'ignore').decode('ascii')\n\ndef slugify(input_string: str, separator: str = '-') -> str:\n    if not isinstance(input_string, str) or not isinstance(separator, str):\n        raise TypeError(\"Input and separator must be of type str\")\n    \n    # Convert to lowercase\n    input_string = input_string.lower()\n    \n    # Remove extra spaces using regex and also remove punctuation\n    input_string = re.sub(r'\\s+', ' ', input_string).strip()  # Normalize spaces\n    input_string = re.sub(r'[^\\w\\s-]', '', input_string)  # Remove punctuation\n    \n    # Split the string into words\n    words = input_string.split()\n    \n    # Encoding characters into ASCII\n    words = [asciify(word) for word in words]\n    \n    # Join the words using the specified separator\n    slug = separator.join(words)\n    \n    return slug",
        "import re\n\ndef asciify(input_string: str) -> str:\n    return input_string.encode('ascii', 'ignore').decode('ascii')\n\ndef slugify(input_string: str, separator: str = '-') -> str:\n    if not isinstance(input_string, str) or not isinstance(separator, str):\n        raise TypeError(\"Both input_string and separator must be strings.\")\n\n    # Convert to lower case\n    input_string = input_string.lower().strip()\n\n    # Remove non-alphanumeric characters and punctuation\n    input_string = re.sub(r'[^a-z0-9\\s]', '', input_string)\n\n    # Split into words\n    words = input_string.split()\n\n    # Asciify and join words\n    slug = asciify(separator.join(words))\n\n    return slug",
        "import re\n\ndef asciify(text: str) -> str:\n    return text.encode('ascii', 'ignore').decode('ascii')\n\ndef slugify(input_string: str, separator: str = '-') -> str:\n    if not isinstance(input_string, str) or not isinstance(separator, str):\n        raise TypeError(\"input_string and separator must be strings\")\n    \n    # Convert to lower case\n    input_string = input_string.lower()\n    \n    # Remove all punctuation and non-alphanumeric characters\n    input_string = re.sub(r'[^a-z0-9\\s]', '', input_string)\n    \n    # Remove extra spaces and split into words\n    words = re.sub(r'\\s+', ' ', input_string).strip().split(' ')\n    \n    # Encode characters to ASCII\n    words = [asciify(word) for word in words if word]\n    \n    # Join words using the separator\n    slug = separator.join(words)\n    \n    return slug"
    ],
    [
        "def booleanize(input_string: str) -> bool:\n    \"\"\"\n    Turns a string into a boolean based on its content (CASE INSENSITIVE).\n\n    A positive boolean (True) is returned if the string value is one of the following:\n\n    - \"true\"\n    - \"1\"\n    - \"yes\"\n    - \"y\"\n\n    Otherwise False is returned.\n\n    *Examples:*\n\n    >>> booleanize('true') # returns True\n    >>> booleanize('YES') # returns True\n    >>> booleanize('nope') # returns False\n\n    :param input_string: String to convert\n    :type input_string: str\n    :return: True if the string contains a boolean-like positive value, false otherwise\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n    \n    positive_bools = {\"true\", \"1\", \"yes\", \"y\"}\n    return input_string.lower() in positive_bools",
        "def booleanize(input_string: str) -> bool:\n    \"\"\"\n    Turns a string into a boolean based on its content (CASE INSENSITIVE).\n\n    A positive boolean (True) is returned if the string value is one of the following:\n\n    - \"true\"\n    - \"1\"\n    - \"yes\"\n    - \"y\"\n\n    Otherwise False is returned.\n\n    *Examples:*\n\n    >>> booleanize('true') # returns True\n    >>> booleanize('YES') # returns True\n    >>> booleanize('nope') # returns False\n\n    :param input_string: String to convert\n    :type input_string: str\n    :return: True if the string contains a boolean-like positive value, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n\n    positive_values = {'true', '1', 'yes', 'y'}\n    return input_string.lower() in positive_values",
        "def booleanize(input_string: str) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n\n    input_string = input_string.lower()\n    valid_true_values = {\"true\", \"1\", \"yes\", \"y\"}\n\n    return input_string in valid_true_values",
        "def booleanize(input_string: str) -> bool:\n    \"\"\"\n    Turns a string into a boolean based on its content (CASE INSENSITIVE).\n\n    A positive boolean (True) is returned if the string value is one of the following:\n\n    - \"true\"\n    - \"1\"\n    - \"yes\"\n    - \"y\"\n\n    Otherwise False is returned.\n\n    *Examples:*\n\n    >>> booleanize('true') # returns True\n    >>> booleanize('YES') # returns True\n    >>> booleanize('nope') # returns False\n\n    :param input_string: String to convert\n    :type input_string: str\n    :return: True if the string contains a boolean-like positive value, false otherwise\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n    \n    positive_values = {'true', '1', 'yes', 'y'}\n    return input_string.lower() in positive_values",
        "def booleanize(input_string: str) -> bool:\n    \"\"\"\n    Turns a string into a boolean based on its content (CASE INSENSITIVE).\n\n    A positive boolean (True) is returned if the string value is one of the following:\n\n    - \"true\"\n    - \"1\"\n    - \"yes\"\n    - \"y\"\n\n    Otherwise False is returned.\n\n    *Examples:*\n\n    >>> booleanize('true') # returns True\n    >>> booleanize('YES') # returns True\n    >>> booleanize('nope') # returns False\n\n    :param input_string: String to convert\n    :type input_string: str\n    :return: True if the string contains a boolean-like positive value, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n\n    valid_positive_bools = {\"true\", \"1\", \"yes\", \"y\"}\n    return input_string.lower() in valid_positive_bools"
    ],
    [
        "def strip_margin(input_string: str) -> str:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    lines = input_string.splitlines()\n    # Find the minimum indentation\n    min_indent = float('inf')\n    for line in lines:\n        stripped_line = line.lstrip()\n        if stripped_line:  # Skip empty lines\n            leading_spaces = len(line) - len(stripped_line)\n            min_indent = min(min_indent, leading_spaces)\n\n    # Remove the minimum indentation from each line\n    stripped_lines = [line[min_indent:] if len(line) > min_indent else line for line in lines]\n    return '\\n'.join(stripped_lines).rstrip()  # Join trimmed lines and remove trailing spaces",
        "def strip_margin(input_string: str) -> str:\n    \"\"\"\n    Removes tab indentation from multi line strings (inspired by analogous Scala function).\n\n    *Example:*\n\n    >>> strip_margin('''\n    >>>                 line 1\n    >>>                 line 2\n    >>>                 line 3\n    >>> ''')\n    >>> # returns:\n    >>> '''\n    >>> line 1\n    >>> line 2\n    >>> line 3\n    >>> '''\n\n    :param input_string: String to format\n    :type input_string: str\n    :return: A string without left margins\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    lines = input_string.splitlines()\n    # Find the minimum leading whitespace in non-empty lines\n    min_indent = float('inf')\n    for line in lines:\n        stripped_line = line.lstrip()\n        if stripped_line:  # Only consider lines that are not empty\n            leading_whitespace = len(line) - len(stripped_line)\n            min_indent = min(min_indent, leading_whitespace)\n\n    # Remove the minimum leading whitespace from each line\n    stripped_lines = [line[min_indent:] if len(line) > min_indent else '' for line in lines]\n    result = '\\n'.join(stripped_lines).strip()  # Join and strip leading/trailing whitespace\n    return result",
        "def strip_margin(input_string: str) -> str:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    lines = input_string.splitlines()\n    # Find the minimum leading whitespace across non-empty lines\n    min_indent = float('inf')\n    for line in lines:\n        stripped_line = line.lstrip()\n        if stripped_line:  # Only consider non-empty lines\n            leading_spaces = len(line) - len(stripped_line)\n            min_indent = min(min_indent, leading_spaces)\n\n    # Remove the minimum indent from each line\n    stripped_lines = [line[min_indent:] if len(line) > min_indent else line for line in lines]\n    \n    return '\\n'.join(stripped_lines).rstrip()",
        "def strip_margin(input_string: str) -> str:\n    \"\"\"\n    Removes tab indentation from multi line strings (inspired by analogous Scala function).\n\n    :param input_string: String to format\n    :type input_string: str\n    :return: A string without left margins\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n\n    lines = input_string.splitlines()\n    \n    # Determine the minimum indentation\n    min_indent = None\n    for line in lines:\n        stripped_line = line.lstrip()\n        if stripped_line:  # Check if line is not empty\n            current_indent = len(line) - len(stripped_line)\n            if min_indent is None or current_indent < min_indent:\n                min_indent = current_indent\n    \n    # Strip the identified margin from each line\n    if min_indent is not None:\n        lines = [line[min_indent:] for line in lines]\n\n    # Join the processed lines back together\n    result = \"\\n\".join(lines).strip()\n    return result",
        "def strip_margin(input_string: str) -> str:\n    \"\"\"\n    Removes tab indentation from multi line strings (inspired by analogous Scala function).\n\n    *Example:*\n\n    >>> strip_margin('''\n    >>>                 line 1\n    >>>                 line 2\n    >>>                 line 3\n    >>> ''')\n    >>> # returns:\n    >>> '''\n    >>> line 1\n    >>> line 2\n    >>> line 3\n    >>> '''\n\n    :param input_string: String to format\n    :type input_string: str\n    :return: A string without left margins\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be of type str\")\n\n    lines = input_string.splitlines()\n    # Find the minimum leading whitespace\n    min_indentation = float('inf')\n    \n    for line in lines:\n        stripped_line = line.lstrip()\n        if stripped_line:  # Only consider lines that contain content\n            leading_spaces = len(line) - len(stripped_line)\n            min_indentation = min(min_indentation, leading_spaces)\n\n    # Now create the result by stripping leading whitespace up to the minimum indentation\n    result_lines = []\n    for line in lines:\n        result_lines.append(line[min_indentation:])\n\n    # Join the result lines into a final string\n    return '\\n'.join(result_lines)"
    ],
    [
        "def decompress(input_string: str, encoding: str = 'utf-8') -> str:\n    \"\"\"\n    Restore a previously compressed string (obtained using `compress()`) back to its original state.\n\n    :param input_string: String to restore.\n    :type input_string: str\n    :param encoding: Original string encoding.\n    :type encoding: str\n    :return: Decompressed string.\n    \"\"\"\n    \n    __require_valid_input_and_encoding(input_string, encoding)\n\n    # turns input string into a sequence of bytes\n    # (the string is assumed to be a previously compressed string, therefore we have to decode it using base64)\n    input_bytes = base64.urlsafe_b64decode(input_string)\n\n    # decompress bytes using zlib\n    decompressed_bytes = zlib.decompress(input_bytes)\n\n    # decode the decompressed bytes to get the original string back\n    original_string = decompressed_bytes.decode(encoding)\n\n    return original_string",
        "def decompress(input_string: str, encoding: str = 'utf-8') -> str:\n    \"\"\"\n    Restore a previously compressed string (obtained using `compress()`) back to its original state.\n\n    :param input_string: String to restore.\n    :type input_string: str\n    :param encoding: Original string encoding.\n    :type encoding: str\n    :return: Decompressed string.\n    \"\"\"\n    __require_valid_input_and_encoding(input_string, encoding)\n\n    # turns input string into a sequence of bytes\n    # (the string is assumed to be a previously compressed string, therefore we have to decode it using base64)\n    input_bytes = base64.urlsafe_b64decode(input_string)\n\n    # decompress bytes using zlib\n    decompressed_bytes = zlib.decompress(input_bytes)\n\n    # decode the decompressed bytes to get the original string back\n    original_string = decompressed_bytes.decode(encoding)\n\n    return original_string",
        "def decompress(input_string: str, encoding: str = 'utf-8') -> str:\n    \"\"\"\n    Restore a previously compressed string (obtained using `compress()`) back to its original state.\n\n    :param input_string: String to restore.\n    :type input_string: str\n    :param encoding: Original string encoding.\n    :type encoding: str\n    :return: Decompressed string.\n    \"\"\"\n    __require_valid_input_and_encoding(input_string, encoding)\n\n    # turns input string into a sequence of bytes\n    # (the string is assumed to be a previously compressed string, therefore we have to decode it using base64)\n    input_bytes = base64.urlsafe_b64decode(input_string)\n\n    # decompress bytes using zlib\n    decompressed_bytes = zlib.decompress(input_bytes)\n\n    # decode the decompressed bytes to get the original string back\n    original_string = decompressed_bytes.decode(encoding)\n\n    return original_string",
        "def decompress(input_string: str, encoding: str = 'utf-8') -> str:\n    \"\"\"\n    Restore a previously compressed string (obtained using `compress()`) back to its original state.\n\n    :param input_string: String to restore.\n    :type input_string: str\n    :param encoding: Original string encoding.\n    :type encoding: str\n    :return: Decompressed string.\n    \"\"\"\n    __require_valid_input_and_encoding(input_string, encoding)\n\n    # turns input string into a sequence of bytes\n    # (the string is assumed to be a previously compressed string, therefore we have to decode it using base64)\n    input_bytes = base64.urlsafe_b64decode(input_string)\n\n    # decompress bytes using zlib\n    decompressed_bytes = zlib.decompress(input_bytes)\n\n    # decode the decompressed bytes to get the original string back\n    original_string = decompressed_bytes.decode(encoding)\n\n    return original_string",
        "def decompress(input_string: str, encoding: str = 'utf-8') -> str:\n    \"\"\"\n    Restore a previously compressed string (obtained using `compress()`) back to its original state.\n\n    :param input_string: String to restore.\n    :type input_string: str\n    :param encoding: Original string encoding.\n    :type encoding: str\n    :return: Decompressed string.\n    \"\"\"\n\n    # Validate input parameters\n    __require_valid_input_and_encoding(input_string, encoding)\n\n    # Decode the input string from base64\n    input_bytes = base64.urlsafe_b64decode(input_string)\n\n    # Decompress the byte data\n    decompressed_bytes = zlib.decompress(input_bytes)\n\n    # Decode the decompressed bytes to get the original string\n    original_string = decompressed_bytes.decode(encoding)\n\n    return original_string"
    ],
    [
        "def roman_encode(input_number: Union[str, int]) -> str:\n    if isinstance(input_number, str):\n        input_number = int(input_number)\n    \n    if not isinstance(input_number, int) or input_number < 1 or input_number > 3999:\n        raise ValueError(\"Input must be a positive integer between 1 and 3999.\")\n\n    roman_numerals = [\n        (1000, \"M\"),\n        (900, \"CM\"),\n        (500, \"D\"),\n        (400, \"CD\"),\n        (100, \"C\"),\n        (90, \"XC\"),\n        (50, \"L\"),\n        (40, \"XL\"),\n        (10, \"X\"),\n        (9, \"IX\"),\n        (5, \"V\"),\n        (4, \"IV\"),\n        (1, \"I\"),\n    ]\n    \n    result = []\n    \n    for value, numeral in roman_numerals:\n        while input_number >= value:\n            result.append(numeral)\n            input_number -= value\n    \n    return ''.join(result)",
        "def roman_encode(input_number: Union[str, int]) -> str:\n    if isinstance(input_number, str):\n        if not input_number.isdigit() or int(input_number) < 1 or int(input_number) > 3999:\n            raise ValueError(\"Input must be a positive integer in the range 1-3999\")\n        input_number = int(input_number)\n    elif not isinstance(input_number, int) or input_number < 1 or input_number > 3999:\n        raise ValueError(\"Input must be a positive integer in the range 1-3999\")\n    \n    roman_numerals = [\n        (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n        (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n        (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'),\n        (1, 'I')\n    ]\n    \n    result = \"\"\n    for value, numeral in roman_numerals:\n        while input_number >= value:\n            result += numeral\n            input_number -= value\n            \n    return result",
        "def roman_encode(input_number: Union[str, int]) -> str:\n    if isinstance(input_number, str):\n        if not input_number.isdigit() or not (1 <= int(input_number) <= 3999):\n            raise ValueError(\"Input must be a positive integer within the range 1-3999\")\n        input_number = int(input_number)\n    elif not isinstance(input_number, int) or not (1 <= input_number <= 3999):\n        raise ValueError(\"Input must be a positive integer within the range 1-3999\")\n    \n    roman_numerals = [\n        (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n        (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n        (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'),\n        (1, 'I')\n    ]\n    \n    result = \"\"\n    for value, numeral in roman_numerals:\n        while input_number >= value:\n            result += numeral\n            input_number -= value\n            \n    return result",
        "from typing import Union\n\ndef roman_encode(input_number: Union[str, int]) -> str:\n    if isinstance(input_number, str):\n        input_number = int(input_number)\n    \n    if not isinstance(input_number, int) or input_number < 1 or input_number > 3999:\n        raise ValueError(\"Input must be a positive integer between 1 and 3999 inclusive.\")\n    \n    roman_numerals = [\n        (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n        (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n        (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\n    ]\n    \n    result = []\n    \n    for value, numeral in roman_numerals:\n        while input_number >= value:\n            result.append(numeral)\n            input_number -= value\n            \n    return ''.join(result)",
        "def roman_encode(input_number: Union[str, int]) -> str:\n    if isinstance(input_number, str):\n        input_number = int(input_number)\n    \n    if not isinstance(input_number, int) or input_number < 1 or input_number > 3999:\n        raise ValueError(\"Input must be a positive integer between 1 and 3999 inclusive.\")\n    \n    roman_numerals = [\n        (1000, 'M'),\n        (900, 'CM'),\n        (500, 'D'),\n        (400, 'CD'),\n        (100, 'C'),\n        (90, 'XC'),\n        (50, 'L'),\n        (40, 'XL'),\n        (10, 'X'),\n        (9, 'IX'),\n        (5, 'V'),\n        (4, 'IV'),\n        (1, 'I'),\n    ]\n    \n    result = []\n    \n    for (integer, roman) in roman_numerals:\n        while input_number >= integer:\n            result.append(roman)\n            input_number -= integer\n    \n    return ''.join(result)"
    ],
    [
        "def roman_decode(input_string: str) -> int:\n    \"\"\"\n    Decode a roman number string into an integer if the provided string is valid.\n\n    *Example:*\n\n    >>> roman_decode('VII') # returns 7\n\n    :param input_string: (Assumed) Roman number\n    :type input_string: str\n    :return: Integer value\n    \"\"\"\n    \n    if not isinstance(input_string, str) or not input_string:\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n\n    roman_numerals = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    prev_value = 0\n\n    for char in reversed(input_string):\n        if char not in roman_numerals:\n            raise ValueError(f'Invalid Roman numeral character: {char}')\n        \n        value = roman_numerals[char]\n        \n        if value < prev_value:\n            total -= value\n        else:\n            total += value\n            \n        prev_value = value\n\n    return total",
        "def roman_decode(input_string: str) -> int:\n    if not isinstance(input_string, str) or not input_string:\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n    \n    roman_numerals = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    \n    # Validate input characters\n    for char in input_string:\n        if char not in roman_numerals:\n            raise ValueError(f'Invalid Roman numeral: {char}')\n    \n    total = 0\n    prev_value = 0\n    \n    for char in reversed(input_string):\n        value = roman_numerals[char]\n        if value < prev_value:\n            total -= value\n        else:\n            total += value\n        prev_value = value\n    \n    return total",
        "def roman_decode(input_string: str) -> int:\n    \"\"\"\n    Decode a roman number string into an integer if the provided string is valid.\n\n    *Example:*\n\n    >>> roman_decode('VII') # returns 7\n\n    :param input_string: (Assumed) Roman number\n    :type input_string: str\n    :return: Integer value\n    \"\"\"\n    \n    if not isinstance(input_string, str) or not input_string:\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n    \n    roman_mapping = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    }\n    \n    total = 0\n    prev_value = 0\n\n    for char in reversed(input_string):\n        if char not in roman_mapping:\n            raise ValueError(f'Invalid Roman numeral character: {char}')\n        \n        current_value = roman_mapping[char]\n        if current_value < prev_value:\n            total -= current_value\n        else:\n            total += current_value\n        \n        prev_value = current_value\n\n    return total",
        "def roman_decode(input_string: str) -> int:\n    \"\"\"\n    Decode a roman number string into an integer if the provided string is valid.\n\n    *Example:*\n\n    >>> roman_decode('VII') # returns 7\n\n    :param input_string: (Assumed) Roman number\n    :type input_string: str\n    :return: Integer value\n    \"\"\"\n    if not isinstance(input_string, str) or not input_string:\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n\n    roman_numerals = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    }\n\n    total = 0\n    prev_value = 0\n\n    for char in reversed(input_string):\n        if char not in roman_numerals:\n            raise ValueError(f'Invalid Roman numeral character: {char}')\n        \n        current_value = roman_numerals[char]\n\n        if current_value < prev_value:\n            total -= current_value\n        else:\n            total += current_value\n\n        prev_value = current_value\n\n    return total",
        "def roman_decode(input_string: str) -> int:\n    \"\"\"\n    Decode a roman number string into an integer if the provided string is valid.\n\n    *Example:*\n\n    >>> roman_decode('VII') # returns 7\n\n    :param input_string: (Assumed) Roman number\n    :type input_string: str\n    :return: Integer value\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n    \n    if not input_string:\n        raise ValueError(\"Input string cannot be empty.\")\n    \n    roman_values = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    }\n    \n    total = 0\n    prev_value = 0\n    \n    for char in reversed(input_string):\n        if char not in roman_values:\n            raise ValueError(f\"Invalid Roman numeral character: '{char}'\")\n        \n        current_value = roman_values[char]\n        \n        if current_value < prev_value:\n            total -= current_value\n        else:\n            total += current_value\n        \n        prev_value = current_value\n    \n    return total"
    ],
    [
        "def is_string(obj: Any) -> bool:\n    \"\"\"\n    Checks if an object is a string.\n\n    *Example:*\n\n    >>> is_string('foo') # returns true\n    >>> is_string(b'foo') # returns false\n\n    :param obj: Object to test.\n    :return: True if string, false otherwise.\n    \"\"\"\n    return isinstance(obj, str)",
        "def is_string(obj: Any) -> bool:\n    \"\"\"\n    Checks if an object is a string.\n\n    *Example:*\n\n    >>> is_string('foo') # returns true\n    >>> is_string(b'foo') # returns false\n\n    :param obj: Object to test.\n    :return: True if string, false otherwise.\n    \"\"\"\n    return isinstance(obj, str)",
        "def is_string(obj: Any) -> bool:\n    \"\"\"\n    Checks if an object is a string.\n\n    *Example:*\n\n    >>> is_string('foo') # returns true\n    >>> is_string(b'foo') # returns false\n\n    :param obj: Object to test.\n    :return: True if string, false otherwise.\n    \"\"\"\n    return isinstance(obj, str)",
        "def is_string(obj: Any) -> bool:\n    \"\"\"\n    Checks if an object is a string.\n\n    *Example:*\n\n    >>> is_string('foo') # returns true\n    >>> is_string(b'foo') # returns false\n\n    :param obj: Object to test.\n    :return: True if string, false otherwise.\n    \"\"\"\n    return isinstance(obj, str)",
        "def is_string(obj: Any) -> bool:\n    \"\"\"\n    Checks if an object is a string.\n\n    *Example:*\n\n    >>> is_string('foo') # returns true\n    >>> is_string(b'foo') # returns false\n\n    :param obj: Object to test.\n    :return: True if string, false otherwise.\n    \"\"\"\n    return isinstance(obj, str)"
    ],
    [
        "def is_full_string(input_string: Any) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n    if input_string is None or input_string == '':\n        return False\n    return bool(input_string.strip())",
        "def is_full_string(input_string: Any) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n    \n    if input_string is None or input_string == '':\n        return False\n    \n    stripped_string = input_string.strip()\n    \n    return len(stripped_string) > 0",
        "def is_full_string(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is not empty (it must contains at least one non space character).\n\n    *Examples:*\n\n    >>> is_full_string(None) # returns false\n    >>> is_full_string('') # returns false\n    >>> is_full_string(' ') # returns false\n    >>> is_full_string('hello') # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if not empty, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n    \n    if input_string is None or input_string.strip() == '':\n        return False\n    \n    return True",
        "def is_full_string(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is not empty (it must contains at least one non space character).\n\n    *Examples:*\n\n    >>> is_full_string(None) # returns false\n    >>> is_full_string('') # returns false\n    >>> is_full_string(' ') # returns false\n    >>> is_full_string('hello') # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if not empty, false otherwise.\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n    \n    if input_string is None or input_string == '':\n        return False\n    \n    return bool(input_string.strip())",
        "def is_full_string(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is not empty (it must contains at least one non space character).\n\n    *Examples:*\n\n    >>> is_full_string(None) # returns false\n    >>> is_full_string('') # returns false\n    >>> is_full_string(' ') # returns false\n    >>> is_full_string('hello') # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if not empty, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n\n    if input_string is None or input_string == '':\n        return False\n\n    return bool(input_string.strip())"
    ],
    [
        "import re\n\ndef is_number(input_string: str) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    pattern = r'^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?$'\n    return re.fullmatch(pattern, input_string) is not None",
        "import re\n\ndef is_number(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid number.\n\n    The number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\n    or use the \"scientific notation\" (eg: 1e5).\n\n    *Examples:*\n\n    >>> is_number('42') # returns true\n    >>> is_number('19.99') # returns true\n    >>> is_number('-9.12') # returns true\n    >>> is_number('1e3') # returns true\n    >>> is_number('1 2 3') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if the string represents a number, false otherwise\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Regular expression pattern for a valid number\n    pattern = r'^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?$'\n    \n    # Check if the input string matches the pattern\n    return re.match(pattern, input_string) is not None",
        "import re\n\ndef is_number(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid number.\n\n    The number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\n    or use the \"scientific notation\" (eg: 1e5).\n\n    *Examples:*\n\n    >>> is_number('42') # returns true\n    >>> is_number('19.99') # returns true\n    >>> is_number('-9.12') # returns true\n    >>> is_number('1e3') # returns true\n    >>> is_number('1 2 3') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if the string represents a number, false otherwise\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Regular expression pattern for a valid number\n    pattern = r'^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$'\n    \n    # Check if the input_string matches the pattern\n    return bool(re.match(pattern, input_string))",
        "import re\n\ndef is_number(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid number.\n\n    The number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\n    or use the \"scientific notation\" (eg: 1e5).\n\n    *Examples:*\n\n    >>> is_number('42') # returns true\n    >>> is_number('19.99') # returns true\n    >>> is_number('-9.12') # returns true\n    >>> is_number('1e3') # returns true\n    >>> is_number('1 2 3') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if the string represents a number, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    pattern = r'^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?$'\n    return re.match(pattern, input_string) is not None",
        "import re\n\ndef is_number(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid number.\n\n    The number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\n    or use the \"scientific notation\" (eg: 1e5).\n\n    *Examples:*\n\n    >>> is_number('42') # returns true\n    >>> is_number('19.99') # returns true\n    >>> is_number('-9.12') # returns true\n    >>> is_number('1e3') # returns true\n    >>> is_number('1 2 3') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if the string represents a number, false otherwise\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    pattern = r'^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?$'\n    return re.match(pattern, input_string) is not None"
    ],
    [
        "import re\n\ndef is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n\n    # Regex to match signed or unsigned integers\n    pattern = r'^[+-]?(\\d+)$'\n\n    # Check if the input string matches the pattern\n    return bool(re.match(pattern, input_string))",
        "import re\n\ndef is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n    \n    # Remove leading/trailing whitespace\n    input_string = input_string.strip()\n\n    # Regular expression to match an integer\n    integer_pattern = r'^[+-]?\\d+$'\n    \n    # Check if the input string matches the integer pattern\n    return bool(re.match(integer_pattern, input_string))",
        "import re\n\ndef is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n\n    # Regular expression to match an integer\n    pattern = r'^[+-]?\\d+$'\n    \n    # Check for empty or whitespace strings\n    if not input_string.strip():\n        return False\n\n    return bool(re.match(pattern, input_string))",
        "import re\n\ndef is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n    \n    # Regular expression to match an integer\n    integer_pattern = r'^[+-]?\\d+$'\n    \n    return bool(re.match(integer_pattern, input_string))",
        "import re\n\ndef is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n\n    input_string = input_string.strip()  # Remove leading and trailing whitespace\n    if input_string == \"\":\n        return False\n\n    # Regular expression to match integer values\n    pattern = r'^[+-]?\\d+$'\n    return bool(re.match(pattern, input_string))"
    ],
    [
        "import re\n\ndef is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    pattern = r'^[+-]?(\\d+\\.\\d+|\\.\\d+|\\d+\\.\\d*[eE][+-]?\\d+|\\d+[eE][+-]?\\d+)$'\n    return bool(re.match(pattern, input_string))",
        "import re\n\ndef is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    pattern = r'^[+-]?(\\d+\\.\\d+|\\d+\\.\\d*e[+-]?\\d+|\\.\\d+|\\.\\d+e[+-]?\\d+)$'\n    return bool(re.match(pattern, input_string))",
        "import re\n\ndef is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Regular expression pattern for validating decimal numbers\n    pattern = r'^[+-]?(\\d+\\.\\d+|\\d*\\.\\d+|\\d+\\.\\d*[eE][+-]?\\d+|\\d*[eE][+-]?\\d+)$'\n    \n    return bool(re.match(pattern, input_string))",
        "import re\n\ndef is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    # Regular expression pattern for a decimal number\n    pattern = r'^[+-]?(\\d*\\.\\d+|\\d+\\.\\d*)([eE][+-]?\\d+)?$'\n    \n    return bool(re.match(pattern, input_string))",
        "import re\n\ndef is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Regular expression pattern for decimal numbers\n    decimal_pattern = r'^[+-]?(\\d+\\.\\d+|\\.\\d+|\\d+\\.\\d*[eE][+-]?\\d+|\\d*[eE][+-]?\\d+)$'\n    \n    return bool(re.match(decimal_pattern, input_string))"
    ],
    [
        "import re\nfrom typing import Any, List, Optional\n\ndef is_url(input_string: Any, allowed_schemes: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n\n    # Regular expression to validate URLs\n    url_pattern = re.compile(\n        r'^(https?|ftp)://'  # scheme\n        r'([\\da-z.-]+)\\.([a-z.]{2,6})'  # domain and TLD\n        r'[/\\w .-]*)*\\/?$'  # path\n    )\n    \n    # Check if the input string matches the URL pattern\n    valid = url_pattern.match(input_string) is not None\n\n    if allowed_schemes:\n        # Check if the scheme is allowed\n        scheme = input_string.split('://')[0] if '://' in input_string else ''\n        return valid and scheme in allowed_schemes\n\n    return valid",
        "import re\nfrom typing import Any, Optional, List\n\ndef is_url(input_string: Any, allowed_schemes: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n\n    # Regular expression for validating a URL\n    URL_RE = re.compile(\n        r'^(https?|ftp)://'  # Protocol\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}|[A-Z0-9-]{2,})|'  # Domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|'  # ...or IPv4\n        r'\\[?[A-F0-9]*:[A-F0-9:]+\\]?)'  # ...or IPv6\n        r'(\\:\\d+)?'  # Port\n        r'(\\/[-A-Z0-9+&@#\\/%?=~_|!:,\\.;]*[-A-Z0-9+&@#\\/%=~_|])?$', re.IGNORECASE)\n\n    valid = URL_RE.match(input_string) is not None\n\n    if allowed_schemes:\n        valid_scheme = any(input_string.startswith(f'{scheme}://') for scheme in allowed_schemes)\n        return valid and valid_scheme\n\n    return valid",
        "def is_url(input_string: Any, allowed_schemes: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    # Regular expression to match a valid URL\n    import re\n    URL_RE = re.compile(\n        r'^(?P<scheme>https?://|ftp://)'  # Scheme\n        r'(?P<host>[a-zA-Z0-9.-]+)'        # Hostname\n        r'(:\\d+)?'                         # Optional port\n        r'(/(?P<path>.*))?$'              # Optional path\n    )\n\n    valid = URL_RE.match(input_string) is not None\n\n    if allowed_schemes:\n        scheme = input_string.split('://')[0] + '://'\n        return valid and any(scheme.startswith(s) for s in allowed_schemes)\n\n    return valid",
        "import re\nfrom typing import Any, Optional, List\n\ndef is_url(input_string: Any, allowed_schemes: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n\n    # Regular expression for validating a URL\n    URL_RE = re.compile(\n        r'^(https?://|ftp://|www\\.|ftp\\.)'  # Scheme part\n        r'([a-zA-Z0-9-]+\\.[a-zA-Z]{2,}|'  # Domain part\n        r'localhost|'  # localhost\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|'  # IPv4\n        r'\\[?[a-fA-F0-9]*:[a-fA-F0-9:]+\\]?)'  # IPv6\n        r'(:\\d+)?'  # Optional port\n        r'(/.*)?$'  # Optional path\n    )\n    \n    valid = URL_RE.match(input_string) is not None\n\n    if allowed_schemes:\n        return valid and any(input_string.startswith(scheme + '://') for scheme in allowed_schemes)\n\n    return valid",
        "import re\nfrom typing import Any, List, Optional\n\ndef is_url(input_string: Any, allowed_schemes: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n\n    # Regular expression for validating a URL\n    URL_RE = re.compile(\n        r'^(https?|ftp)://'  # scheme\n        r'(?:(?:[A-Z0-9](?:-?[A-Z0-9])*)?[A-Z0-9]\\.)+(?:[A-Z]{2,}|[A-Z0-9-]{2,}\\.[A-Z]{2,})'  # domain\n        r'(?::\\d+)?'  # optional port\n        r'(?:/[^?\\s]*)?'  # optional path\n        r'(?:\\?[^#\\s]*)?'  # optional query\n        r'(?:#[^\\s]*)?$',  # optional fragment\n        re.IGNORECASE)\n\n    valid = URL_RE.match(input_string) is not None\n\n    if allowed_schemes:\n        return valid and any(input_string.lower().startswith(f\"{scheme}://\") for scheme in allowed_schemes)\n\n    return valid"
    ],
    [
        "import re\nfrom typing import Any\n\ndef is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        return False\n\n    # Regular expression for validating an Email\n    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    \n    return bool(re.match(email_regex, input_string))",
        "import re\nfrom typing import Any\n\ndef is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        return False\n    \n    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(email_regex, input_string))",
        "import re\nfrom typing import Any\n\ndef is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        return False\n\n    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return re.match(email_regex, input_string) is not None",
        "import re\nfrom typing import Any\n\ndef is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        return False\n\n    # Regex for validating an email\n    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    \n    return re.match(email_regex, input_string) is not None",
        "import re\nfrom typing import Any\n\ndef is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        return False\n    \n    # Regular expression for validating an Email\n    email_regex = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n    \n    # Check if the input_string matches the regex\n    return re.match(email_regex, input_string) is not None"
    ],
    [
        "def is_credit_card(input_string: Any, card_type: str = None) -> bool:\n    \"\"\"\n    Checks if a string is a valid credit card number.\n    If card type is provided then it checks against that specific type only,\n    otherwise any known credit card number will be accepted.\n\n    Supported card types are the following:\n\n    - VISA\n    - MASTERCARD\n    - AMERICAN_EXPRESS\n    - DINERS_CLUB\n    - DISCOVER\n    - JCB\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param card_type: Card type. Default to None (any card).\n    :type card_type: str\n\n    :return: True if credit card, false otherwise.\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n\n    if not input_string.isdigit():\n        return False\n\n    def luhn_check(card_number: str) -> bool:\n        total = 0\n        reverse_digits = card_number[::-1]\n        for i, digit in enumerate(reverse_digits):\n            n = int(digit)\n            if i % 2 == 1:  # Double every second digit\n                n *= 2\n                if n > 9:  # Subtract 9 if the result is greater than 9\n                    n -= 9\n            total += n\n        return total % 10 == 0\n\n    # Credit card type validation\n    if card_type:\n        if card_type not in ['VISA', 'MASTERCARD', 'AMERICAN_EXPRESS', 'DINERS_CLUB', 'DISCOVER', 'JCB']:\n            raise KeyError('Invalid card type \"{}\". Valid types are: VISA, MASTERCARD, AMERICAN_EXPRESS, DINERS_CLUB, DISCOVER, JCB'.format(card_type))\n        \n        if card_type == 'VISA':\n            if len(input_string) in [13, 16] and input_string.startswith('4'):\n                return luhn_check(input_string)\n        elif card_type == 'MASTERCARD':\n            if len(input_string) == 16 and input_string[:2] in ['51', '52', '53', '54', '55']:\n                return luhn_check(input_string)\n        elif card_type == 'AMERICAN_EXPRESS':\n            if len(input_string) == 15 and input_string.startswith(('34', '37')):\n                return luhn_check(input_string)\n        elif card_type == 'DINERS_CLUB':\n            if len(input_string) == 14 and input_string.startswith(('30', '36', '38', '39')):\n                return luhn_check(input_string)\n        elif card_type == 'DISCOVER':\n            if len(input_string) == 16 and input_string.startswith('6011'):\n                return luhn_check(input_string)\n        elif card_type == 'JCB':\n            if len(input_string) in [16, 15] and input_string.startswith(('35', '2131', '1800')):\n                return luhn_check(input_string)\n\n    # General validation for any known card format\n    if luhn_check(input_string):\n        if (len(input_string) == 16 and input_string.startswith('4')) or \\\n           (len(input_string) in [13, 16] and input_string.startswith(('51', '52', '53', '54', '55'))) or \\\n           (len(input_string) == 15 and input_string.startswith(('34', '37'))) or \\\n           (len(input_string) == 14 and input_string.startswith(('30', '36', '38'))) or \\\n           (len(input_string) == 16 and input_string.startswith('6011')) or \\\n           (len(input_string) in [15, 16] and input_string.startswith(('35', '2131', '1800'))):\n            return True\n\n    return False",
        "def is_credit_card(input_string: Any, card_type: str = None) -> bool:\n    \"\"\"\n    Checks if a string is a valid credit card number.\n    If card type is provided then it checks against that specific type only,\n    otherwise any known credit card number will be accepted.\n\n    Supported card types are the following:\n\n    - VISA\n    - MASTERCARD\n    - AMERICAN_EXPRESS\n    - DINERS_CLUB\n    - DISCOVER\n    - JCB\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param card_type: Card type. Default to None (any card).\n    :type card_type: str\n\n    :return: True if credit card, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    if not input_string.isdigit():\n        return False\n\n    def luhn_check(number: str) -> bool:\n        total = 0\n        reverse_digits = number[::-1]\n        for i, digit in enumerate(reverse_digits):\n            n = int(digit)\n            if i % 2 == 1:  # Double every second digit\n                n *= 2\n                if n > 9:\n                    n -= 9\n            total += n\n        return total % 10 == 0\n\n    CREDIT_CARDS = {\n        \"VISA\": lambda x: len(x) in [13, 16] and x[0] == '4',\n        \"MASTERCARD\": lambda x: len(x) == 16 and x[0] in ['5'] and x[1] in ['1', '2', '3', '4', '5'],\n        \"AMERICAN_EXPRESS\": lambda x: len(x) == 15 and x[:2] in ['34', '37'],\n        \"DINERS_CLUB\": lambda x: len(x) == 14 and x[:2] in ['36', '38', '39'],\n        \"DISCOVER\": lambda x: len(x) == 16 and x[:4] == '6011',\n        \"JCB\": lambda x: len(x) in [16, 15] and x[:4] in ['3528', '3589']\n    }\n\n    if card_type:\n        if card_type not in CREDIT_CARDS:\n            raise KeyError(\n                f'Invalid card type \"{card_type}\". Valid types are: {\", \".join(CREDIT_CARDS.keys())}'\n            )\n        return CREDIT_CARDS[card_type](input_string) and luhn_check(input_string)\n\n    for c in CREDIT_CARDS:\n        if CREDIT_CARDS[c](input_string) and luhn_check(input_string):\n            return True\n\n    return False",
        "def is_credit_card(input_string: Any, card_type: str = None) -> bool:\n    \"\"\"\n    Checks if a string is a valid credit card number.\n    If card type is provided then it checks against that specific type only,\n    otherwise any known credit card number will be accepted.\n\n    Supported card types are the following:\n\n    - VISA\n    - MASTERCARD\n    - AMERICAN_EXPRESS\n    - DINERS_CLUB\n    - DISCOVER\n    - JCB\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param card_type: Card type. Default to None (any card).\n    :type card_type: str\n\n    :return: True if credit card, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n\n    if not input_string.isdigit():\n        return False\n\n    card_length = len(input_string)\n    \n    if card_type:\n        if card_type == \"VISA\":\n            return card_length in [13, 16] and input_string.startswith('4') and luhn_check(input_string)\n        elif card_type == \"MASTERCARD\":\n            return card_length == 16 and input_string.startswith(('51', '52', '53', '54', '55')) and luhn_check(input_string)\n        elif card_type == \"AMERICAN_EXPRESS\":\n            return card_length == 15 and input_string.startswith(('34', '37')) and luhn_check(input_string)\n        elif card_type == \"DINERS_CLUB\":\n            return card_length == 14 and input_string.startswith(('38', '39')) and luhn_check(input_string)\n        elif card_type == \"DISCOVER\":\n            return card_length == 16 and input_string.startswith(('6011', '65')) and luhn_check(input_string)\n        elif card_type == \"JCB\":\n            return card_length in [15, 16] and input_string.startswith(('3528', '3589')) and luhn_check(input_string)\n        else:\n            raise KeyError(\n                'Invalid card type \"{}\". Valid types are: VISA, MASTERCARD, AMERICAN_EXPRESS, DINERS_CLUB, DISCOVER, JCB'.format(card_type)\n            )\n\n    # General validation checks for any known card type\n    if (card_length in [13, 16] and input_string.startswith('4')) or (card_length == 16 and input_string.startswith(('51','52','53','54','55'))) or (card_length == 15 and input_string.startswith(('34','37'))):\n        return luhn_check(input_string)\n\n    return False\n\ndef luhn_check(card_number: str) -> bool:\n    digits = [int(d) for d in card_number]\n    checksum = 0\n    \n    # Reverse the card number and process digits\n    for i in range(len(digits)):\n        if i % 2 == 0:  # From right to left, double every second digit\n            checksum += digits[-(i + 1)]\n        else:\n            double_digit = digits[-(i + 1)] * 2\n            checksum += double_digit if double_digit < 10 else double_digit - 9\n    \n    return checksum % 10 == 0",
        "def is_credit_card(input_string: Any, card_type: str = None) -> bool:\n    \"\"\"\n    Checks if a string is a valid credit card number.\n    If card type is provided then it checks against that specific type only,\n    otherwise any known credit card number will be accepted.\n\n    Supported card types are the following:\n\n    - VISA\n    - MASTERCARD\n    - AMERICAN_EXPRESS\n    - DINERS_CLUB\n    - DISCOVER\n    - JCB\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param card_type: Card type. Default to None (any card).\n    :type card_type: str\n\n    :return: True if credit card, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError('Input must be a string')\n    \n    input_string = input_string.replace(' ', '')  # Remove any spaces\n\n    if not input_string.isdigit():\n        return False\n    \n    def luhn_check(card_number: str) -> bool:\n        total = 0\n        reverse_digits = card_number[::-1]\n        \n        for i, digit in enumerate(reverse_digits):\n            n = int(digit)\n            if i % 2 == 1:  # Double every second digit\n                n *= 2\n                if n > 9:  # Subtract 9 from numbers over 9\n                    n -= 9\n            total += n\n        \n        return total % 10 == 0\n\n    CREDIT_CARDS = {\n        'VISA': r'^4[0-9]{12}(?:[0-9]{3})?$',\n        'MASTERCARD': r'^5[1-5][0-9]{14}$',\n        'AMERICAN_EXPRESS': r'^3[47][0-9]{13}$',\n        'DINERS_CLUB': r'^3(?:0[0-5]|[68][0-9])[0-9]{11}$',\n        'DISCOVER': r'^6(?:011|5[0-9]{2})[0-9]{12}$',\n        'JCB': r'^(?:2131|1800|35\\d{3})\\d{11}$',\n    }\n\n    if card_type:\n        if card_type not in CREDIT_CARDS:\n            raise KeyError(\n                'Invalid card type \"{}\". Valid types are: {}'.format(card_type, ', '.join(CREDIT_CARDS.keys()))\n            )\n        is_valid = re.match(CREDIT_CARDS[card_type], input_string) is not None\n        return is_valid and luhn_check(input_string)\n\n    for c in CREDIT_CARDS:\n        if re.match(CREDIT_CARDS[c], input_string):\n            return luhn_check(input_string)\n    \n    return False",
        "def is_credit_card(input_string: str, card_type: str = None) -> bool:\n    \"\"\"\n    Checks if a string is a valid credit card number.\n    If card type is provided then it checks against that specific type only,\n    otherwise any known credit card number will be accepted.\n\n    Supported card types are the following:\n\n    - VISA\n    - MASTERCARD\n    - AMERICAN_EXPRESS\n    - DINERS_CLUB\n    - DISCOVER\n    - JCB\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param card_type: Card type. Default to None (any card).\n    :type card_type: str\n\n    :return: True if credit card, false otherwise.\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    if not input_string.isdigit():\n        return False\n    \n    credit_cards = {\n        'VISA': (r'^4[0-9]{12}(?:[0-9]{3})?$'),  # 13 or 16 digits\n        'MASTERCARD': (r'^[5][1-5][0-9]{14}$'),  # 16 digits\n        'AMERICAN_EXPRESS': (r'^[34|37][0-9]{13}$'),  # 15 digits\n        'DINERS_CLUB': (r'^(30[0-5]|36|38)[0-9]{11}$'),  # 14 digits\n        'DISCOVER': (r'^(6011|65[0-9]{2}|64[4-9][0-9])[0-9]{12}$'),  # 16 digits\n        'JCB': (r'^(?:2131|1800|35\\d{3})\\d{11}$')  # 15 digits\n    }\n\n    def luhn_check(card_number):\n        def digits_of(n):\n            return [int(d) for d in str(n)]\n        \n        digits = digits_of(card_number)\n        odd_digits = digits[-1::-2]\n        even_digits = digits[-2::-2]\n        return (sum(odd_digits) + sum(sum(digits_of(d * 2)) for d in even_digits)) % 10 == 0\n\n    if card_type:\n        if card_type not in credit_cards:\n            raise KeyError(\n                f'Invalid card type \"{card_type}\". Valid types are: {\", \".join(credit_cards.keys())}'\n            )\n        return bool(re.match(credit_cards[card_type][0], input_string)) and luhn_check(input_string)\n\n    for card in credit_cards:\n        if bool(re.match(credit_cards[card][0], input_string)) and luhn_check(input_string):\n            return True\n\n    return False"
    ],
    [
        "import re\n\ndef is_camel_case(input_string: any) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    if len(input_string) == 0 or input_string[0].isdigit():\n        return False\n    \n    camel_case_pattern = re.compile(r'^(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]*$')\n    \n    return camel_case_pattern.match(input_string) is not None",
        "import re\n\ndef is_camel_case(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    if input_string[0].isdigit():\n        return False\n    \n    camel_case_pattern = re.compile(r'^(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]+$')\n    return bool(camel_case_pattern.match(input_string))",
        "import re\nfrom typing import Any\n\ndef is_camel_case(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    if input_string[0].isdigit():\n        return False\n    \n    if not re.match(r'^[a-zA-Z0-9]+$', input_string):\n        return False\n    \n    has_lower = any(c.islower() for c in input_string)\n    has_upper = any(c.isupper() for c in input_string)\n\n    return has_lower and has_upper",
        "import re\nfrom typing import Any\n\ndef is_camel_case(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    if input_string[0].isdigit():\n        return False\n    \n    # Regular expression for camel case validation\n    CAMEL_CASE_TEST_RE = re.compile(r'^[a-zA-Z][a-zA-Z0-9]*$')\n    \n    # Check for at least one lowercase and one uppercase letter\n    has_lower = any(c.islower() for c in input_string)\n    has_upper = any(c.isupper() for c in input_string)\n    \n    return bool(CAMEL_CASE_TEST_RE.match(input_string)) and has_lower and has_upper",
        "import re\n\ndef is_camel_case(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    if len(input_string) == 0 or input_string[0].isdigit():\n        return False\n\n    camel_case_pattern = re.compile(r'^(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]*$')\n    return camel_case_pattern.match(input_string) is not None"
    ],
    [
        "def is_snake_case(input_string: any, separator: str = '_') -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    if input_string[0].isdigit():\n        return False\n    \n    if separator not in input_string:\n        return False\n    \n    valid_characters = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' + separator)\n    \n    for char in input_string:\n        if char not in valid_characters:\n            return False\n    \n    return True",
        "def is_snake_case(input_string: Any, separator: str = '_') -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be of type str.\")\n    \n    if input_string[0].isdigit():\n        return False\n    \n    if separator not in input_string:\n        return False\n    \n    for char in input_string:\n        if not (char.islower() or char.isupper() or char.isdigit() or char == separator):\n            return False\n    \n    return True",
        "def is_snake_case(input_string: any, separator: str = '_') -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n    \n    if input_string[0].isdigit():\n        return False\n    \n    if separator not in input_string:\n        return False\n    \n    valid_characters = set(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\" + separator)\n    \n    for char in input_string:\n        if char not in valid_characters:\n            return False\n            \n    return True",
        "def is_snake_case(input_string: Any, separator: str = '_') -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    if input_string.startswith(tuple('0123456789')):\n        return False\n    \n    if separator not in input_string:\n        return False\n    \n    if any(char not in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' + separator for char in input_string):\n        return False\n    \n    return True",
        "def is_snake_case(input_string: Any, separator: str = '_') -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n    \n    if input_string[0].isdigit():\n        return False\n    \n    if separator not in input_string:\n        return False\n    \n    allowed_characters = set(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\" + separator)\n    \n    for char in input_string:\n        if char not in allowed_characters:\n            return False\n    \n    return True"
    ],
    [
        "import json\n\ndef is_json(input_string: any) -> bool:\n    \"\"\"\n    Check if a string is a valid json.\n\n    *Examples:*\n\n    >>> is_json('{\"name\": \"Peter\"}') # returns true\n    >>> is_json('[1, 2, 3]') # returns true\n    >>> is_json('{nope}') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if json, false otherwise\n    \"\"\"\n    if isinstance(input_string, str):\n        try:\n            json.loads(input_string)\n            return True\n        except json.JSONDecodeError:\n            return False\n    return False",
        "import json\n\ndef is_json(input_string: str) -> bool:\n    \"\"\"\n    Check if a string is a valid json.\n\n    *Examples:*\n\n    >>> is_json('{\"name\": \"Peter\"}') # returns true\n    >>> is_json('[1, 2, 3]') # returns true\n    >>> is_json('{nope}') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if json, false otherwise\n    \"\"\"\n    if isinstance(input_string, str):\n        try:\n            json.loads(input_string)\n            return True\n        except json.JSONDecodeError:\n            return False\n    return False",
        "import json\n\ndef is_json(input_string: str) -> bool:\n    \"\"\"\n    Check if a string is a valid json.\n\n    *Examples:*\n\n    >>> is_json('{\"name\": \"Peter\"}') # returns true\n    >>> is_json('[1, 2, 3]') # returns true\n    >>> is_json('{nope}') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if json, false otherwise\n    \"\"\"\n    if isinstance(input_string, str):\n        try:\n            json.loads(input_string)\n            return True\n        except json.JSONDecodeError:\n            return False\n    return False",
        "import json\n\ndef is_json(input_string: str) -> bool:\n    \"\"\"\n    Check if a string is a valid json.\n\n    *Examples:*\n\n    >>> is_json('{\"name\": \"Peter\"}') # returns true\n    >>> is_json('[1, 2, 3]') # returns true\n    >>> is_json('{nope}') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if json, false otherwise\n    \"\"\"\n    if isinstance(input_string, str):\n        try:\n            json.loads(input_string)\n            return True\n        except json.JSONDecodeError:\n            return False\n    return False",
        "import json\n\ndef is_json(input_string: str) -> bool:\n    \"\"\"\n    Check if a string is a valid json.\n\n    *Examples:*\n\n    >>> is_json('{\"name\": \"Peter\"}') # returns true\n    >>> is_json('[1, 2, 3]') # returns true\n    >>> is_json('{nope}') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if json, false otherwise\n    \"\"\"\n    if isinstance(input_string, str):\n        try:\n            json.loads(input_string)\n            return True\n        except json.JSONDecodeError:\n            return False\n    return False"
    ],
    [
        "import re\n\ndef is_uuid(input_string: str, allow_hex: bool = False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    # Regular expression for standard UUID format\n    UUID_RE = re.compile(r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$', re.IGNORECASE)\n    \n    # Regular expression for hex UUID format\n    UUID_HEX_OK_RE = re.compile(r'^[0-9a-f]{32}$', re.IGNORECASE)\n\n    # Convert input to string\n    s = str(input_string)\n\n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n\n    return UUID_RE.match(s) is not None",
        "import re\n\n# Regular expression for matching a standard UUID format\nUUID_RE = re.compile(r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$')\n# Regular expression for matching a hex representation of a UUID\nUUID_HEX_OK_RE = re.compile(r'^[0-9a-f]{32}$')\n\ndef is_uuid(input_string: any, allow_hex: bool = False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    s = input_string.strip()\n    \n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n\n    return UUID_RE.match(s) is not None",
        "import re\n\n# Regular expression for standard UUID\nUUID_RE = re.compile(r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$')\n# Regular expression for UUID in hexadecimal format\nUUID_HEX_OK_RE = re.compile(r'^[0-9a-f]{32}$')\n\ndef is_uuid(input_string: any, allow_hex: bool = False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n    \n    s = input_string\n    \n    if allow_hex:\n        return bool(UUID_HEX_OK_RE.match(s))\n    \n    return bool(UUID_RE.match(s))",
        "import re\n\n# Regular expression for validating standard UUIDs (with hyphens)\nUUID_RE = re.compile(r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$', re.IGNORECASE)\n\n# Regular expression for validating UUIDs in hex format (no hyphens)\nUUID_HEX_OK_RE = re.compile(r'^[0-9a-f]{32}$', re.IGNORECASE)\n\ndef is_uuid(input_string: any, allow_hex: bool = False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    # string casting is used to allow UUID itself as input data type\n    s = str(input_string)\n\n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n\n    return UUID_RE.match(s) is not None",
        "import re\n\ndef is_uuid(input_string: any, allow_hex: bool = False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    \n    # string casting is used to allow UUID itself as input data type\n    s = str(input_string)\n\n    # UUID regex pattern for standard format\n    UUID_RE = re.compile(\n        r'^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$',\n        re.IGNORECASE\n    )\n\n    # UUID hex pattern (32 hexadecimal digits without hyphens)\n    UUID_HEX_OK_RE = re.compile(r'^[a-f0-9]{32}$', re.IGNORECASE)\n\n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n\n    return UUID_RE.match(s) is not None"
    ],
    [
        "def is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n    \n    segments = input_string.split('.')\n    \n    if len(segments) != 4:\n        return False\n    \n    for segment in segments:\n        if not segment.isdigit():\n            return False\n        num = int(segment)\n        if num < 0 or num > 255:\n            return False\n    \n    return True",
        "def is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n    \n    segments = input_string.split('.')\n    \n    if len(segments) != 4:\n        return False\n    \n    for segment in segments:\n        if not segment.isdigit():\n            return False\n        num = int(segment)\n        if num < 0 or num > 255:\n            return False\n    \n    return True",
        "def is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n\n    segments = input_string.split('.')\n    \n    if len(segments) != 4:\n        return False\n\n    for segment in segments:\n        if not segment.isdigit():\n            return False\n        if not (0 <= int(segment) <= 255):\n            return False\n\n    return True",
        "def is_ip_v4(input_string: Any) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n    \n    segments = input_string.split('.')\n    \n    if len(segments) != 4:\n        return False\n    \n    for segment in segments:\n        if not segment.isdigit():\n            return False\n        if not 0 <= int(segment) <= 255:\n            return False\n        \n    return True",
        "def is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n\n    if not isinstance(input_string, str):\n        raise TypeError(f'Expected \"str\", received \"{type(input_string).__name__}\"')\n\n    segments = input_string.split('.')\n    \n    if len(segments) != 4:\n        return False\n\n    for segment in segments:\n        if not segment.isdigit():\n            return False\n        num = int(segment)\n        if num < 0 or num > 255:\n            return False\n\n    return True"
    ],
    [
        "import re\nfrom typing import Any\n\ndef is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Define the pattern for a valid IPv6 address\n    pattern = r'^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|(?:[0-9a-fA-F]{1,4}:){1,7}:|' \\\n              r'(?:[0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|(?:[0-9a-fA-F]{1,4}:){1,5}(?::[0-9a-fA-F]{1,4}){1,2}|' \\\n              r'(?:[0-9a-fA-F]{1,4}:){1,4}(?::[0-9a-fA-F]{1,4}){1,3}|(?:[0-9a-fA-F]{1,4}:){1,3}(?::[0-9a-fA-F]{1,4}){1,4}|' \\\n              r'(?:[0-9a-fA-F]{1,4}:){1,2}(?::[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:(?::[0-9a-fA-F]{1,4}){1,6}|' \\\n              r':(?::[0-9a-fA-F]{1,4}){1,7}$'\n    \n    # Use a regular expression to match the pattern\n    if re.fullmatch(pattern, input_string):\n        return True\n    else:\n        return False",
        "import re\n\ndef is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    pattern = r'^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9]))\\.){3,3}(25[0-5]|(2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9]))|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9]))\\.){3,3}(25[0-5]|(2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9]))))$'\n\n    return re.fullmatch(pattern, input_string) is not None",
        "import re\n\ndef is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Regular expression pattern for matching IPv6 addresses\n    ipv6_pattern = r'^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|(?:[0-9a-fA-F]{1,4}:){1,7}:|' \\\n                   r'(?:[0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|' \\\n                   r'(?:[0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|' \\\n                   r'(?:[0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|' \\\n                   r'(?:[0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|' \\\n                   r'(?:[0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|' \\\n                   r'[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|' \\\n                   r':((:[0-9a-fA-F]{1,4}){1,7}|:)$'\n    \n    return bool(re.fullmatch(ipv6_pattern, input_string))",
        "import re\n\ndef is_ip_v6(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    pattern = r'^([\\da-fA-F]{1,4}:){7}[\\da-fA-F]{1,4}$|' \\\n              r'^([\\da-fA-F]{1,4}:){1,7}:$|' \\\n              r'^([\\da-fA-F]{1,4}:){1,6}:[\\da-fA-F]{1,4}$|' \\\n              r'^([\\da-fA-F]{1,4}:){1,5}(:[\\da-fA-F]{1,4}){1,2}$|' \\\n              r'^([\\da-fA-F]{1,4}:){1,4}(:[\\da-fA-F]{1,4}){1,3}$|' \\\n              r'^([\\da-fA-F]{1,4}:){1,3}(:[\\da-fA-F]{1,4}){1,4}$|' \\\n              r'^([\\da-fA-F]{1,4}:){1,2}(:[\\da-fA-F]{1,4}){1,5}$|' \\\n              r'^[\\da-fA-F]{1,4}:((:[\\da-fA-F]{1,4}){1,6})$|' \\\n              r'^:((:[\\da-fA-F]{1,4}){1,7}|:)$|' \\\n              r'^:([\\da-fA-F]{1,4}:){1,6}([\\da-fA-F]{1,4})$|' \\\n              r'^[\\da-fA-F]{1,4}:((:[\\da-fA-F]{1,4}){1,5}:|:)$|' \\\n              r'^([\\da-fA-F]{1,4}:){1,5}:([\\da-fA-F]{1,4}){1,1}$'\n\n    return re.fullmatch(pattern, input_string) is not None",
        "import re\nfrom typing import Any\n\ndef is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    # Regular expression pattern for validating an IPv6 address\n    pattern = r'^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$|^::|^(([0-9a-fA-F]{1,4}:){0,6}([0-9a-fA-F]{1,4}|:))$|^([0-9a-fA-F]{1,4}:){1,7}:$|^([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}$|^([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}$|^([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}$|^([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}$|^([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}$|^[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6}|:)$|^:((:[0-9a-fA-F]{1,4}){1,7}|:)$|^fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}$|^(?:[0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[0-9a-fA-F]{1,4})$'\n    \n    return re.fullmatch(pattern, input_string) is not None"
    ],
    [
        "def is_ip(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip (either v4 or v6).\n\n    *Examples:*\n\n    >>> is_ip('255.200.100.75') # returns true\n    >>> is_ip('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip('1.2.3') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    return is_ip_v6(input_string) or is_ip_v4(input_string)",
        "def is_ip(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip (either v4 or v6).\n\n    *Examples:*\n\n    >>> is_ip('255.200.100.75') # returns true\n    >>> is_ip('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip('1.2.3') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n\n    return is_ip_v6(input_string) or is_ip_v4(input_string)",
        "def is_ip(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip (either v4 or v6).\n\n    *Examples:*\n\n    >>> is_ip('255.200.100.75') # returns true\n    >>> is_ip('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip('1.2.3') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    return is_ip_v6(input_string) or is_ip_v4(input_string)",
        "def is_ip(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip (either v4 or v6).\n\n    *Examples:*\n\n    >>> is_ip('255.200.100.75') # returns true\n    >>> is_ip('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip('1.2.3') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip, false otherwise.\n    \"\"\"\n    from re import fullmatch\n    \n    def is_ip_v4(ip: str) -> bool:\n        octets = ip.split('.')\n        if len(octets) != 4:\n            return False\n        for octet in octets:\n            if not octet.isdigit() or not (0 <= int(octet) <= 255) or (octet != '0' and octet.startswith('0')):\n                return False\n        return True\n\n    def is_ip_v6(ip: str) -> bool:\n        IPV6_RE = r'^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|' \\\n                  r'^(?:[0-9a-fA-F]{1,4}:){1,7}:|' \\\n                  r'^(?:[0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|' \\\n                  r'^(?:[0-9a-fA-F]{1,4}:){1,5}(?::[0-9a-fA-F]{1,4}){1,2}|' \\\n                  r'^(?:[0-9a-fA-F]{1,4}:){1,4}(?::[0-9a-fA-F]{1,4}){1,3}|' \\\n                  r'^(?:[0-9a-fA-F]{1,4}:){1,3}(?::[0-9a-fA-F]{1,4}){1,4}|' \\\n                  r'^(?:[0-9a-fA-F]{1,4}:){1,2}(?::[0-9a-fA-F]{1,4}){1,5}|' \\\n                  r'^[0-9a-fA-F]{1,4}:(?::[0-9a-fA-F]{1,4}){1,6}|' \\\n                  r'^\\:(?::[0-9a-fA-F]{1,4}){1,7}|::|' \\\n                  r'^[0-9a-fA-F]{1,4}:(?::[0-9a-fA-F]{1,4}){0,6}\\:[0-9a-fA-F]{1,4}$'\n        return fullmatch(IPV6_RE, ip) is not None\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    return is_ip_v6(input_string) or is_ip_v4(input_string)",
        "def is_ip(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip (either v4 or v6).\n\n    *Examples:*\n\n    >>> is_ip('255.200.100.75') # returns true\n    >>> is_ip('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip('1.2.3') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    return is_ip_v6(input_string) or is_ip_v4(input_string)"
    ],
    [
        "def is_palindrome(input_string: Any, ignore_spaces: bool = False, ignore_case: bool = False) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError('input_string must be a string')\n    \n    if ignore_spaces:\n        input_string = ''.join(input_string.split())\n    \n    if ignore_case:\n        input_string = input_string.lower()\n    \n    return input_string == input_string[::-1]",
        "def is_palindrome(input_string: Any, ignore_spaces: bool = False, ignore_case: bool = False) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    if ignore_spaces:\n        input_string = ''.join(input_string.split())\n    \n    if ignore_case:\n        input_string = input_string.lower()\n    \n    return input_string == input_string[::-1]",
        "def is_palindrome(input_string: Any, ignore_spaces: bool = False, ignore_case: bool = False) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    if ignore_spaces:\n        processed_string = ''.join(input_string.split())\n    else:\n        processed_string = input_string\n\n    if ignore_case:\n        processed_string = processed_string.lower()\n    \n    return processed_string == processed_string[::-1]",
        "def is_palindrome(input_string: Any, ignore_spaces: bool = False, ignore_case: bool = False) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    if ignore_spaces:\n        input_string = input_string.replace(\" \", \"\")\n    \n    if ignore_case:\n        input_string = input_string.lower()\n    \n    return input_string == input_string[::-1]",
        "def is_palindrome(input_string: Any, ignore_spaces: bool = False, ignore_case: bool = False) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    if ignore_spaces:\n        input_string = input_string.replace(\" \", \"\")\n    \n    if ignore_case:\n        input_string = input_string.lower()\n    \n    return input_string == input_string[::-1]"
    ],
    [
        "def is_pangram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n    *Examples:*\n\n    >>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n    >>> is_pangram('hello world') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if the string is a pangram, False otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    input_string = input_string.lower()\n    alphabet_set = set(\"abcdefghijklmnopqrstuvwxyz\")\n    input_set = set(input_string)\n\n    return alphabet_set <= input_set",
        "def is_pangram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n    *Examples:*\n\n    >>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n    >>> is_pangram('hello world') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if the string is a pangram, False otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    input_string = input_string.lower()\n    alphabet_set = set('abcdefghijklmnopqrstuvwxyz')\n    input_set = set(input_string)\n    \n    return alphabet_set.issubset(input_set)",
        "def is_pangram(input_string: any) -> bool:\n    \"\"\"\n    Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n    *Examples:*\n\n    >>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n    >>> is_pangram('hello world') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if the string is a pangram, False otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    input_string = input_string.lower()\n    alphabet_set = set('abcdefghijklmnopqrstuvwxyz')\n    input_set = set(input_string)\n\n    return alphabet_set <= input_set",
        "def is_pangram(input_string: Any) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    input_string = input_string.lower()\n    alphabet_set = set('abcdefghijklmnopqrstuvwxyz')\n    input_set = set(input_string)\n    \n    return alphabet_set.issubset(input_set)",
        "def is_pangram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n    *Examples:*\n\n    >>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n    >>> is_pangram('hello world') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if the string is a pangram, False otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    input_string = input_string.lower()\n    alphabet_set = set('abcdefghijklmnopqrstuvwxyz')\n    input_set = set(input_string)\n    \n    return alphabet_set.issubset(input_set)"
    ],
    [
        "def is_isogram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n    *Examples:*\n\n    >>> is_isogram('dermatoglyphics') # returns true\n    >>> is_isogram('hello') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if isogram, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    input_string = input_string.lower()\n    seen_characters = set()\n    \n    for char in input_string:\n        if char in seen_characters:\n            return False\n        seen_characters.add(char)\n    \n    return True",
        "def is_isogram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n    *Examples:*\n\n    >>> is_isogram('dermatoglyphics') # returns true\n    >>> is_isogram('hello') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if isogram, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    input_string = input_string.lower()\n    seen_chars = set()\n\n    for char in input_string:\n        if char in seen_chars:\n            return False\n        seen_chars.add(char)\n\n    return True",
        "def is_isogram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n    *Examples:*\n\n    >>> is_isogram('dermatoglyphics') # returns true\n    >>> is_isogram('hello') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if isogram, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    input_string = input_string.lower()\n    seen_chars = set()\n    \n    for char in input_string:\n        if char in seen_chars:\n            return False\n        seen_chars.add(char)\n    \n    return True",
        "def is_isogram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n    *Examples:*\n\n    >>> is_isogram('dermatoglyphics') # returns true\n    >>> is_isogram('hello') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if isogram, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    input_string = input_string.lower()\n    seen_characters = set()\n    \n    for char in input_string:\n        if char in seen_characters:\n            return False\n        seen_characters.add(char)\n    \n    return True",
        "def is_isogram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n    *Examples:*\n\n    >>> is_isogram('dermatoglyphics') # returns true\n    >>> is_isogram('hello') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if isogram, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    input_string = input_string.lower()\n    seen_characters = set()\n    \n    for char in input_string:\n        if char in seen_characters:\n            return False\n        seen_characters.add(char)\n    \n    return True"
    ],
    [
        "def is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    if not is_string(input_string):\n        raise TypeError(\"input_string must be a string\")\n    \n    if not is_string(separator):\n        raise TypeError(\"separator must be a string\")\n    \n    # Normalize the string\n    normalized_slug = slugify(input_string, separator)\n    \n    # Check if the normalized slug matches the input string exactly\n    if normalized_slug != input_string.lower():\n        return False\n\n    # Check for invalid cases\n    if normalized_slug.startswith(separator) or normalized_slug.endswith(separator):\n        return False\n    \n    if separator * 2 in normalized_slug:\n        return False\n    \n    return True",
        "def is_slug(input_string: Any, separator: str = '-') -> bool:\n    if not is_string(input_string):\n        raise TypeError(\"input_string must be a string.\")\n    if not is_string(separator):\n        raise TypeError(\"separator must be a string.\")\n    \n    # Normalize the input string\n    normalized = slugify(input_string, separator)\n    \n    # Check for invalid conditions: consecutive separators or start/end with separator\n    if (normalized.startswith(separator) or normalized.endswith(separator) or\n        separator * 2 in normalized):\n        return False\n    \n    # Validate that it contains only allowed characters\n    for char in normalized:\n        if not (char.isalnum() or char == separator):\n            return False\n    \n    return True",
        "def is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    if not is_string(input_string):\n        raise TypeError(\"input_string must be a string\")\n    \n    if not is_string(separator):\n        raise TypeError(\"separator must be a string\")\n\n    normalized_slug = slugify(input_string, separator)\n    \n    # Check the rules for a valid slug\n    if normalized_slug.startswith(separator) or normalized_slug.endswith(separator):\n        return False\n    \n    if separator * 2 in normalized_slug:\n        return False\n    \n    return True",
        "def is_slug(input_string: Any, separator: str = '-') -> bool:\n    if not is_string(input_string):\n        raise TypeError(\"input_string must be a string.\")\n    \n    if not is_string(separator):\n        raise TypeError(\"separator must be a string.\")\n\n    # Normalize the input_string using slugify function\n    normalized = slugify(input_string, separator)\n\n    # Check for invalid slug criteria\n    if normalized.startswith(separator) or normalized.endswith(separator):\n        return False\n        \n    # Check for consecutive separators\n    if separator * 2 in normalized:\n        return False\n    \n    return True",
        "def is_slug(input_string: Any, separator: str = '-') -> bool:\n    if not is_string(input_string):\n        raise TypeError(\"Input string should be of type str.\")\n\n    if not is_string(separator):\n        raise TypeError(\"Separator should be of type str.\")\n\n    # Normalize the input string\n    normalized_slug = slugify(input_string, separator)\n\n    # Check if it complies with slug format rules\n    if (normalized_slug.startswith(separator) or\n        normalized_slug.endswith(separator) or\n        separator * 2 in normalized_slug):\n        return False\n\n    # It should contain only allowed characters\n    allowed_chars = set('abcdefghijklmnopqrstuvwxyz0123456789' + separator)\n    return all(char in allowed_chars for char in normalized_slug)"
    ],
    [
        "import re\n\ndef contains_html(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string contains HTML/XML tags.\n\n    By design, this function matches ANY type of tag, so don't expect to use it\n    as an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n    *Examples:*\n\n    >>> contains_html('my string is <strong>bold</strong>') # returns true\n    >>> contains_html('my string is not bold') # returns false\n\n    :param input_string: Text to check\n    :type input_string: str\n    :return: True if string contains html, false otherwise.\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    # Regex pattern to find any HTML/XML tags\n    pattern = r'<[^>]+>'\n    \n    # Search for the pattern in the input string\n    return bool(re.search(pattern, input_string))",
        "import re\n\ndef contains_html(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string contains HTML/XML tags.\n\n    By design, this function matches ANY type of tag, so don't expect to use it\n    as an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n    *Examples:*\n\n    >>> contains_html('my string is <strong>bold</strong>') # returns true\n    >>> contains_html('my string is not bold') # returns false\n\n    :param input_string: Text to check\n    :type input_string: str\n    :return: True if string contains html, false otherwise.\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Regex pattern to search for HTML/XML tags\n    pattern = r'<[^>]+>'\n    return bool(re.search(pattern, input_string))",
        "import re\n\ndef contains_html(input_string: str) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    # Regex pattern to detect HTML/XML tags\n    pattern = re.compile(r'<[^>]+>')\n    \n    # Search for any matches\n    return bool(pattern.search(input_string))",
        "import re\n\ndef contains_html(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string contains HTML/XML tags.\n\n    By design, this function matches ANY type of tag, so don't expect to use it\n    as an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n    *Examples:*\n\n    >>> contains_html('my string is <strong>bold</strong>') # returns true\n    >>> contains_html('my string is not bold') # returns false\n\n    :param input_string: Text to check\n    :type input_string: str\n    :return: True if string contains html, false otherwise.\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    # Regular expression to find any HTML/XML-like tags\n    pattern = r\"<[^>]+>\"\n    \n    # Use re.search to find any match in the input string\n    return bool(re.search(pattern, input_string))",
        "import re\n\ndef contains_html(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string contains HTML/XML tags.\n\n    By design, this function matches ANY type of tag, so don't expect to use it\n    as an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n    *Examples:*\n\n    >>> contains_html('my string is <strong>bold</strong>') # returns true\n    >>> contains_html('my string is not bold') # returns false\n\n    :param input_string: Text to check\n    :type input_string: str\n    :return: True if string contains html, false otherwise.\n    \"\"\"\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    # Regex pattern to find HTML/XML tags\n    pattern = r'<[^>]+>'\n    \n    # Search for tags in the input string\n    return bool(re.search(pattern, input_string))"
    ],
    [
        "import re\n\ndef words_count(input_string: str) -> int:\n    \"\"\"\n    Returns the number of words contained into the given string.\n\n    This method is smart, it does consider only sequence of one or more letter and/or numbers\n    as \"words\", so a string like this: \"! @ # % ... []\" will return zero!\n    Moreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\n    will be 4 not 1 (even if there are no spaces in the string).\n\n    *Examples:*\n\n    >>> words_count('hello world') # returns 2\n    >>> words_count('one,two,three.stop') # returns 4\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: Number of words.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n\n    # Use a regular expression to find words\n    words = re.findall(r'\\b\\w+\\b', input_string)\n    return len(words)",
        "import re\n\ndef words_count(input_string: str) -> int:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    # Regular expression pattern to match words (letters and/or numbers)\n    pattern = r'[a-zA-Z0-9]+'\n    words = re.findall(pattern, input_string)\n    \n    return len(words)",
        "import re\n\ndef words_count(input_string: str) -> int:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Use regex to find all sequences of alphanumeric characters\n    words = re.findall(r'\\b\\w+\\b', input_string)\n    \n    # Return the count of words found\n    return len(words)",
        "import re\n\ndef words_count(input_string: str) -> int:\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n\n    # Define a regex pattern to match words (alphanumeric sequences)\n    pattern = r'\\b\\w+\\b'\n\n    # Find all matches in the input string\n    matches = re.findall(pattern, input_string)\n\n    # Return the count of matches found\n    return len(matches)",
        "import re\n\ndef words_count(input_string: str) -> int:\n    \"\"\"\n    Returns the number of words contained into the given string.\n\n    This method is smart, it does consider only sequence of one or more letter and/or numbers\n    as \"words\", so a string like this: \"! @ # % ... []\" will return zero!\n    Moreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\n    will be 4 not 1 (even if there are no spaces in the string).\n\n    *Examples:*\n\n    >>> words_count('hello world') # returns 2\n    >>> words_count('one,two,three.stop') # returns 4\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: Number of words.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Use regex to find sequences of alphanumeric characters\n    words = re.findall(r'\\b\\w+\\b', input_string)\n    \n    return len(words)"
    ],
    [
        "def is_isbn_10(input_string: str, normalize: bool = True) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    if normalize:\n        input_string = input_string.replace('-', '')\n\n    if len(input_string) != 10:\n        return False\n\n    product = 0\n    for index, char in enumerate(input_string):\n        if char.isdigit():\n            product += int(char) * (index + 1)\n        elif index == 9 and char == 'X':  # Handle 'X' for the last character\n            product += 10 * (index + 1)\n        else:\n            return False\n\n    return product % 11 == 0",
        "def is_isbn_10(input_string: str, normalize: bool = True) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n\n    if normalize:\n        input_string = input_string.replace(\"-\", \"\")\n\n    if len(input_string) != 10:\n        return False\n\n    product = 0\n    for index, char in enumerate(input_string):\n        if char.isdigit():\n            product += int(char) * (index + 1)\n        elif index == 9 and char == 'X':\n            product += 10 * (index + 1)\n        else:\n            return False\n\n    return product % 11 == 0",
        "def is_isbn_10(input_string: str, normalize: bool = True) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    if normalize:\n        input_string = input_string.replace('-', '')\n    \n    if len(input_string) != 10:\n        return False\n    \n    total = 0\n    \n    for i in range(10):\n        if i == 9 and input_string[i].upper() == 'X':  # Check for 'X' in the last position\n            total += 10 * (i + 1)\n        elif input_string[i].isdigit():\n            total += int(input_string[i]) * (i + 1)\n        else:\n            return False\n    \n    return total % 11 == 0",
        "def is_isbn_10(input_string: str, normalize: bool = True) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    if normalize:\n        input_string = input_string.replace('-', '')\n\n    if len(input_string) != 10:\n        return False\n\n    checksum = 0\n    for i in range(10):\n        char = input_string[i]\n        if char.isdigit():\n            checksum += int(char) * (i + 1)\n        elif i == 9 and char == 'X':  # Last character can be 'X'\n            checksum += 10 * (i + 1)\n        else:\n            return False\n\n    return checksum % 11 == 0",
        "def is_isbn_10(input_string: str, normalize: bool = True) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    if normalize:\n        input_string = input_string.replace(\"-\", \"\")\n    \n    if len(input_string) != 10:\n        return False\n    \n    product = 0\n    for index in range(10):\n        if index < 9:\n            if not input_string[index].isdigit():\n                return False\n            product += int(input_string[index]) * (index + 1)\n        else:\n            if input_string[index] == 'X':\n                product += 10 * (index + 1)\n            elif input_string[index].isdigit():\n                product += int(input_string[index]) * (index + 1)\n            else:\n                return False\n    \n    return product % 11 == 0"
    ],
    [
        "def is_isbn_13(input_string: str, normalize: bool = True) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n    if not isinstance(normalize, bool):\n        raise TypeError(\"normalize must be a boolean\")\n    \n    if normalize:\n        input_string = input_string.replace('-', '')\n    \n    if len(input_string) != 13:\n        return False\n    \n    if not input_string.isdigit():\n        return False\n    \n    total = 0\n    for i, digit in enumerate(input_string[:-1]):\n        weight = 1 if i % 2 == 0 else 3\n        total += int(digit) * weight\n    \n    checksum = (10 - (total % 10)) % 10\n    \n    return checksum == int(input_string[-1])",
        "def is_isbn_13(input_string: str, normalize: bool = True) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n    if not isinstance(normalize, bool):\n        raise TypeError(\"normalize must be a boolean\")\n\n    if normalize:\n        input_string = input_string.replace('-', '')\n\n    if len(input_string) != 13:\n        return False\n\n    if not input_string.isdigit():\n        return False\n\n    total = 0\n    for i in range(12):\n        weight = 1 if i % 2 == 0 else 3\n        total += int(input_string[i]) * weight\n\n    checksum_digit = (10 - (total % 10)) % 10\n    return checksum_digit == int(input_string[12])",
        "def is_isbn_13(input_string: str, normalize: bool = True) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n    if not isinstance(normalize, bool):\n        raise TypeError(\"normalize must be a boolean\")\n\n    if normalize:\n        input_string = input_string.replace('-', '')\n\n    if len(input_string) != 13:\n        return False\n\n    if not input_string.isdigit():\n        return False\n\n    checksum = 0\n    for i in range(12):\n        digit = int(input_string[i])\n        weight = 1 if i % 2 == 0 else 3\n        checksum += digit * weight\n\n    checksum_digit = (10 - (checksum % 10)) % 10\n\n    return checksum_digit == int(input_string[12])",
        "def is_isbn_13(input_string: str, normalize: bool = True) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n    if not isinstance(normalize, bool):\n        raise TypeError(\"normalize must be a boolean\")\n\n    if normalize:\n        input_string = input_string.replace('-', '')\n\n    if len(input_string) != 13:\n        return False\n    \n    if not input_string.isdigit():\n        return False\n\n    total = 0\n    for i in range(12):\n        digit = int(input_string[i])\n        weight = 1 if i % 2 == 0 else 3\n        total += digit * weight\n\n    checksum = (10 - (total % 10)) % 10\n    return checksum == int(input_string[12])",
        "def is_isbn_13(input_string: str, normalize: bool = True) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    if not isinstance(normalize, bool):\n        raise TypeError(\"Normalize must be a boolean\")\n\n    if normalize:\n        input_string = input_string.replace(\"-\", \"\")\n\n    if len(input_string) != 13:\n        return False\n\n    if not input_string.isdigit():\n        return False\n\n    checksum = 0\n    for i, digit in enumerate(input_string[:-1]):\n        weight = 1 if i % 2 == 0 else 3\n        checksum += int(digit) * weight\n\n    checksum_digit = (10 - (checksum % 10)) % 10\n\n    return checksum_digit == int(input_string[-1])"
    ],
    [
        "def is_isbn(input_string: str, normalize: bool = True) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    if normalize:\n        input_string = input_string.replace(\"-\", \"\")\n\n    length = len(input_string)\n\n    if length not in [10, 13]:\n        return False\n\n    def validate_isbn10(isbn: str) -> bool:\n        if len(isbn) != 10 or not all(c.isdigit() or c == 'X' for c in isbn):\n            return False\n        total = 0\n        for i in range(10):\n            if isbn[i] == 'X':\n                total += 10 * (10 - i)\n            else:\n                total += int(isbn[i]) * (10 - i)\n        return total % 11 == 0\n\n    def validate_isbn13(isbn: str) -> bool:\n        if len(isbn) != 13 or not isbn.isdigit():\n            return False\n        total = sum(int(isbn[i]) * (1 if i % 2 == 0 else 3) for i in range(12))\n        checksum = (10 - (total % 10)) % 10\n        return int(isbn[12]) == checksum\n\n    if length == 10:\n        return validate_isbn10(input_string)\n    elif length == 13:\n        return validate_isbn13(input_string)\n\n    return False",
        "def is_isbn(input_string: str, normalize: bool = True) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n\n    if normalize:\n        input_string = input_string.replace(\"-\", \"\")\n\n    if len(input_string) not in {10, 13}:\n        return False\n\n    def validate_isbn10(isbn):\n        if len(isbn) != 10 or not all(c.isdigit() or c == 'X' for c in isbn):\n            return False\n        checksum = sum((10 - i) * (10 if c == 'X' else int(c)) for i, c in enumerate(isbn))\n        return checksum % 11 == 0\n\n    def validate_isbn13(isbn):\n        if len(isbn) != 13 or not all(c.isdigit() for c in isbn):\n            return False\n        checksum = sum(int(c) * (1 if i % 2 == 0 else 3) for i, c in enumerate(isbn))\n        return checksum % 10 == 0\n\n    if len(input_string) == 10:\n        return validate_isbn10(input_string)\n    elif len(input_string) == 13:\n        return validate_isbn13(input_string)\n\n    return False",
        "def is_isbn(input_string: str, normalize: bool = True) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    if normalize:\n        input_string = input_string.replace(\"-\", \"\")\n    \n    length = len(input_string)\n    \n    if length == 10:\n        return is_valid_isbn10(input_string)\n    elif length == 13:\n        return is_valid_isbn13(input_string)\n    else:\n        return False\n\ndef is_valid_isbn10(isbn: str) -> bool:\n    if not all(c in \"0123456789X\" for c in isbn):\n        return False\n\n    sum = 0\n    for i in range(10):\n        if isbn[i] == 'X' and i == 9:\n            sum += 10\n        else:\n            sum += int(isbn[i]) * (10 - i)\n    \n    return sum % 11 == 0\n\ndef is_valid_isbn13(isbn: str) -> bool:\n    if not isbn.isdigit():\n        return False\n\n    sum = 0\n    for i in range(12):\n        if i % 2 == 0:\n            sum += int(isbn[i])\n        else:\n            sum += int(isbn[i]) * 3\n    \n    check_digit = (10 - (sum % 10)) % 10\n    return int(isbn[12]) == check_digit",
        "def is_isbn(input_string: str, normalize: bool = True) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    if normalize:\n        input_string = input_string.replace('-', '')\n    \n    length = len(input_string)\n    \n    if length == 10:\n        # Validate ISBN-10\n        if not all(c.isdigit() or c == 'X' for c in input_string):\n            return False\n        checksum = sum((10 - i) * (10 if c == 'X' else int(c)) for i, c in enumerate(input_string))\n        return checksum % 11 == 0\n    \n    elif length == 13:\n        # Validate ISBN-13\n        if not input_string.isdigit():\n            return False\n        checksum = sum(int(c) * (1 if i % 2 == 0 else 3) for i, c in enumerate(input_string))\n        return checksum % 10 == 0\n    \n    return False",
        "def is_isbn(input_string: str, normalize: bool = True) -> bool:\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be a string\")\n\n    if normalize:\n        input_string = input_string.replace('-', '')\n\n    length = len(input_string)\n    if length not in (10, 13):\n        return False\n\n    def validate_isbn10(isbn):\n        if len(isbn) != 10 or not all(c.isdigit() or c == 'X' for c in isbn):\n            return False\n        checksum = 0\n        for i, char in enumerate(isbn):\n            if char == 'X' and i == 9:\n                checksum += 10\n            else:\n                checksum += int(char) * (10 - i)\n        return checksum % 11 == 0\n\n    def validate_isbn13(isbn):\n        if len(isbn) != 13 or not isbn.isdigit():\n            return False\n        checksum = sum(int(isbn[i]) * (1 if i % 2 == 0 else 3) for i in range(12))\n        return (10 - (checksum % 10)) % 10 == int(isbn[-1])\n\n    if length == 10:\n        return validate_isbn10(input_string)\n    elif length == 13:\n        return validate_isbn13(input_string)\n\n    return False"
    ],
    [
        "import uuid\n\ndef uuid(as_hex: bool = False) -> str:\n    \"\"\"\n    Generated an UUID string (using `uuid.uuid4()`).\n\n    *Examples:*\n\n    >>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n    >>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n    :param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n    :return: uuid string.\n    \"\"\"\n    uid = uuid.uuid4()\n\n    if as_hex:\n        return uid.hex\n\n    return str(uid)",
        "import uuid\n\ndef uuid(as_hex: bool = False) -> str:\n    \"\"\"\n    Generated an UUID string (using `uuid.uuid4()`).\n\n    *Examples:*\n\n    >>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n    >>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n    :param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n    :return: uuid string.\n    \"\"\"\n    uid = uuid.uuid4()\n\n    if as_hex:\n        return uid.hex\n\n    return str(uid)",
        "import uuid\n\ndef uuid(as_hex: bool = False) -> str:\n    \"\"\"\n    Generated an UUID string (using `uuid.uuid4()`).\n\n    *Examples:*\n\n    >>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n    >>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n    :param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n    :return: uuid string.\n    \"\"\"\n    uid = uuid.uuid4()\n\n    if as_hex:\n        return uid.hex\n\n    return str(uid)",
        "import uuid\n\ndef uuid(as_hex: bool = False) -> str:\n    \"\"\"\n    Generated an UUID string (using `uuid.uuid4()`).\n\n    *Examples:*\n\n    >>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n    >>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n    :param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n    :return: uuid string.\n    \"\"\"\n    uid = uuid.uuid4()\n\n    if as_hex:\n        return uid.hex\n\n    return str(uid)",
        "import uuid\n\ndef uuid(as_hex: bool = False) -> str:\n    \"\"\"\n    Generated an UUID string (using `uuid.uuid4()`).\n\n    *Examples:*\n\n    >>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n    >>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n    :param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n    :return: uuid string.\n    \"\"\"\n    uid = uuid.uuid4()\n\n    if as_hex:\n        return uid.hex\n\n    return str(uid)"
    ],
    [
        "import os\n\ndef secure_random_hex(byte_count: int) -> str:\n    if byte_count < 0:\n        raise ValueError(\"byte_count must be a non-negative integer\")\n    \n    random_bytes = os.urandom(byte_count)\n    return random_bytes.hex()",
        "import os\n\ndef secure_random_hex(byte_count: int) -> str:\n    if byte_count < 0:\n        raise ValueError(\"byte_count must be a non-negative integer\")\n    \n    random_bytes = os.urandom(byte_count)\n    return random_bytes.hex()",
        "import os\n\ndef secure_random_hex(byte_count: int) -> str:\n    if byte_count < 0:\n        raise ValueError(\"byte_count must be a non-negative integer\")\n    random_bytes = os.urandom(byte_count)\n    return random_bytes.hex()",
        "import os\n\ndef secure_random_hex(byte_count: int) -> str:\n    if byte_count < 0:\n        raise ValueError(\"byte_count must be a non-negative integer\")\n    \n    random_bytes = os.urandom(byte_count)\n    return random_bytes.hex()",
        "import os\n\ndef secure_random_hex(byte_count: int) -> str:\n    if byte_count < 0:\n        raise ValueError(\"byte_count must be a non-negative integer\")\n    \n    random_bytes = os.urandom(byte_count)\n    return random_bytes.hex()"
    ],
    [
        "def roman_range(stop: int, start: int = 1, step: int = 1) -> Generator:\n    if not isinstance(stop, int) or stop < 1 or stop > 3999:\n        raise ValueError(\"stop must be an integer between 1 and 3999 inclusive.\")\n    if not isinstance(start, int) or start < 1:\n        raise ValueError(\"start must be an integer greater than or equal to 1.\")\n    if not isinstance(step, int) or step == 0:\n        raise ValueError(\"step must be a non-zero integer.\")\n    \n    if (step > 0 and start > stop) or (step < 0 and start < stop):\n        return  # No numbers to generate if start is not in the correct direction relative to stop\n\n    def int_to_roman(num: int) -> str:\n        val = [\n            1000, 900, 500, 400,\n            100, 90, 50, 40,\n            10, 9, 5, 4,\n            1\n        ]\n        syms = [\n            \"M\", \"CM\", \"D\", \"CD\",\n            \"C\", \"XC\", \"L\", \"XL\",\n            \"X\", \"IX\", \"V\", \"IV\",\n            \"I\"\n        ]\n        roman_num = ''\n        for i in range(len(val)):\n            count = num // val[i]\n            roman_num += syms[i] * count\n            num -= val[i] * count\n        return roman_num\n\n    current = start\n    while (step > 0 and current <= stop) or (step < 0 and current >= stop):\n        yield int_to_roman(current)\n        current += step",
        "def roman_range(stop: int, start: int = 1, step: int = 1) -> Generator:\n    if not isinstance(stop, int) or not (1 <= stop <= 3999):\n        raise ValueError(\"stop must be an integer between 1 and 3999.\")\n    if not isinstance(start, int) or start < 1:\n        raise ValueError(\"start must be an integer greater than or equal to 1.\")\n    if not isinstance(step, int) or step == 0:\n        raise ValueError(\"step must be a non-zero integer.\")\n    \n    if (step > 0 and start > stop) or (step < 0 and start < stop):\n        raise ValueError(\"Invalid range for the given start, stop, and step values.\")\n    \n    def int_to_roman(num: int) -> str:\n        val = [\n            1000, 900, 500, 400,\n            100, 90, 50, 40,\n            10, 9, 5, 4,\n            1\n        ]\n        syms = [\n            \"M\", \"CM\", \"D\", \"CD\",\n            \"C\", \"XC\", \"L\", \"XL\",\n            \"X\", \"IX\", \"V\", \"IV\",\n            \"I\"\n        ]\n        roman_num = ''\n        for i in range(len(val)):\n            while num >= val[i]:\n                roman_num += syms[i]\n                num -= val[i]\n        return roman_num\n    \n    current = start\n    while (step > 0 and current <= stop) or (step < 0 and current >= stop):\n        yield int_to_roman(current)\n        current += step",
        "def roman_range(stop: int, start: int = 1, step: int = 1) -> Generator:\n    if not isinstance(stop, int) or stop < 1 or stop > 3999:\n        raise ValueError(\"stop must be an integer between 1 and 3999\")\n    if not isinstance(start, int) or start < 1:\n        raise ValueError(\"start must be an integer greater than or equal to 1\")\n    if not isinstance(step, int) or step == 0:\n        raise ValueError(\"step must be a non-zero integer\")\n    if (step > 0 and start > stop) or (step < 0 and start < stop):\n        raise ValueError(\"Incompatible start, stop, and step values\")\n\n    def int_to_roman(num: int) -> str:\n        val = [\n            1000, 900, 500, 400,\n            100, 90, 50, 40,\n            10, 9, 5, 4,\n            1\n        ]\n        syms = [\n            \"M\", \"CM\", \"D\", \"CD\",\n            \"C\", \"XC\", \"L\", \"XL\",\n            \"X\", \"IX\", \"V\", \"IV\",\n            \"I\"\n        ]\n        roman_num = ''\n        i = 0\n        while num > 0:\n            for _ in range(num // val[i]):\n                roman_num += syms[i]\n                num -= val[i]\n            i += 1\n        return roman_num\n\n    current = start\n    while (step > 0 and current <= stop) or (step < 0 and current >= stop):\n        yield int_to_roman(current)\n        current += step",
        "def roman_range(stop: int, start: int = 1, step: int = 1) -> Generator:\n    if not isinstance(stop, int) or stop < 1 or stop > 3999:\n        raise ValueError(\"stop must be an integer between 1 and 3999.\")\n    if not isinstance(start, int) or start < 1:\n        raise ValueError(\"start must be an integer greater than or equal to 1.\")\n    if not isinstance(step, int) or step == 0:\n        raise ValueError(\"step must be a non-zero integer.\")\n    \n    if step > 0 and start > stop:\n        return\n    if step < 0 and start < stop:\n        return\n\n    def to_roman(n: int) -> str:\n        val = [\n            1000, 900, 500, 400,\n            100, 90, 50, 40,\n            10, 9, 5, 4,\n            1\n        ]\n        syms = [\n            \"M\", \"CM\", \"D\", \"CD\",\n            \"C\", \"XC\", \"L\", \"XL\",\n            \"X\", \"IX\", \"V\", \"IV\",\n            \"I\"\n        ]\n        roman_num = ''\n        for i in range(len(val)):\n            while n >= val[i]:\n                roman_num += syms[i]\n                n -= val[i]\n        return roman_num\n\n    current = start\n    while (step > 0 and current <= stop) or (step < 0 and current >= stop):\n        yield to_roman(current)\n        current += step",
        "def roman_range(stop: int, start: int = 1, step: int = 1) -> Generator:\n    if not isinstance(stop, int) or stop < 1 or stop > 3999:\n        raise ValueError(\"Stop must be an integer between 1 and 3999\")\n    if not isinstance(start, int) or start < 1:\n        raise ValueError(\"Start must be an integer greater than or equal to 1\")\n    if not isinstance(step, int) or step == 0:\n        raise ValueError(\"Step must be a non-zero integer\")\n    \n    if (step > 0 and start > stop) or (step < 0 and start < stop):\n        raise ValueError(\"Invalid range parameters: start must be less than stop for positive step and vice versa.\")\n    \n    current = start\n    \n    def int_to_roman(num):\n        val = [\n            1000, 900, 500, 400,\n            100, 90, 50, 40,\n            10, 9, 5, 4,\n            1\n            ]\n        syms = [\n            \"M\", \"CM\", \"D\", \"CD\",\n            \"C\", \"XC\", \"L\", \"XL\",\n            \"X\", \"IX\", \"V\", \"IV\",\n            \"I\"\n            ]\n        roman_num = ''\n        for i in range(len(val)):\n            while num >= val[i]:\n                roman_num += syms[i]\n                num -= val[i]\n        return roman_num\n\n    while (step > 0 and current <= stop) or (step < 0 and current >= stop):\n        yield int_to_roman(current)\n        current += step"
    ]
]